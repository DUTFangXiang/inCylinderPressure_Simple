#include <stdio.h>
#include <math.h>
#include <FileCtrl.hpp>
#include "lFileHead.h"
#include "DataProcess.h"
#include "lFormMain.h"
const float PI        = 3.1415926;
const float fRa       = 287.06;
const float fRb	      = 286.41;
const float VSCOPE    = 3.0;   //AD转换器的测量范围   FX注释：VSCOPE    = 2.0; -> 3.0
const float VCAPCATOR = 14700.0;
const int   iCurveDataLength = 3600;
const int   DATA_LENGTH  = 32768;
const float COMBUSTION_LEVEL = 1.8;
const float OIL_LEVEL        = 500.0;
const float OIL_DELTA        = 0.0;     //供油开始角度的修正值 原来取为1.9度

const int IHALFWINDOW = 300;  //计算相似性时的一半窗宽
const int ICOLENGTH = 100;    //计算相似性时的相互移动的点数

const float fRad = 3.1415926/180.0;
const float fFLTH = 14.28894;
const float fgf0 = 5.29;


const float fModal[] = {
//                    0.437467,0.441275,0.445133,0.448993,0.452903,
//                    0.456836,0.460806,0.464813,0.46882,0.472901,
//                    0.47699,0.481108,0.485256,0.489448,0.49367,
//                    0.497913,0.502185,0.506494,0.510832,0.515207,
                    0.519611,0.524043,0.528504,0.532983,0.537517,
                    0.542069,0.546658,0.551255,0.555898,0.560576,
                    0.565271,0.569991,0.574757,0.579537,0.584342,
                    0.589191,0.594054,0.598939,0.603847,0.60881,
                    0.613772,0.618766,0.623781,0.628815,0.633891,
                    0.638962,0.644098,0.649215,0.654348,0.659533,
                    0.664719,0.669932,0.675158,0.680382,0.685656,
                    0.69094,0.696205,0.701519,0.706811,0.71215,
                    0.717479,0.722825,0.728173,0.733535,0.738881,
                    0.744254,0.749623,0.754986,0.760373,0.76572,
                    0.771104,0.776443,0.781809,0.787151,0.792491,
                    0.797813,0.80313,0.808423,0.813708,0.818956,
                    0.824211,0.829424,0.834621,0.839781,0.84493,
                    0.850028
        };         //压力升高率数据模板，共有66个数据 ,第一个数据点出现在上止点前35度左右
/*                 //局部极大值出现在上止点前16度
                    0.259961,0.262194,0.26444,0.266719,0.269015,
                    0.271337,0.273674,0.27604,0.278417,0.280825,
                    0.283258,0.285711,0.288183,0.290674,0.293204,
                    0.295746,0.298316,0.300902,0.303519,0.306165,
                    0.308823,0.311514,0.314234,0.316962,0.319728,
                    0.322523,0.32534,0.328178,0.331033,0.33394,
                    0.336856,0.339803,0.342766,0.345765,0.348801,
                    0.351845,0.35493,0.358038,0.361167,0.364335,
                    0.36753,0.370748,0.373994,0.377262,0.38058,
                    0.38391,0.387269,0.390667,0.394077,0.397538,
                    0.401011,0.404531,0.408068,0.411622,0.415235,
                    0.418866,0.422526,0.426222,0.429921,0.433689,
                    0.437467,0.441275,0.445133,0.448993,0.452903,
                    0.456836,0.460806,0.464813,0.46882,0.472901,
                    0.47699,0.481108,0.485256,0.489448,0.49367,
                    0.497913,0.502185,0.506494,0.510832,0.515207,
                    0.519611,0.524043,0.528504,0.532983,0.537517,
                    0.542069,0.546658,0.551255,0.555898,0.560576,
                    0.565271,0.569991,0.574757,0.579537,0.584342,
                    0.589191,0.594054,0.598939,0.603847,0.60881,
                    0.613772,0.618766,0.623781,0.628815,0.633891,
                    0.638962,0.644098,0.649215,0.654348,0.659533,
                    0.664719,0.669932,0.675158,0.680382,0.685656,
                    0.69094,0.696205,0.701519,0.706811,0.71215,
                    0.717479,0.722825,0.728173,0.733535,0.738881,
                    0.744254,0.749623,0.754986,0.760373,0.76572,
                    0.771104,0.776443,0.781809,0.787151,0.792491,
                    0.797813,0.80313,0.808423,0.813708,0.818956,
                    0.824211,0.829424,0.834621,0.839781,0.84493,
                    0.850028
*/


float hl[55] = {   //滤波器设置
//600Hz
-0.00016124,-0.00004993,0.00008655,0.00027878,
0.00055971,0.00096303,0.00152146,0.00226498,0.00321908,
0.00440319,0.00582919,0.00750034,0.00941040,0.01154324,
0.01387282,0.01636360,0.01897136,0.02164444,0.02432534,
0.02695259,0.02946284,0.03179311,0.03388304,0.03567711,
0.03712672,0.03819199,0.03884333,0.03906250,0.03884333,
0.03819199,0.03712672,0.03567711,0.03388304,0.03179311,
0.02946284,0.02695259,0.02432534,0.02164444,0.01897136,
0.01636360,0.01387283,0.01154324,0.00941040,0.00750034,
0.00582919,0.00440319,0.00321908,0.00226498,0.00152146,
0.00096303,0.00055971,0.00027878,0.00008655,-0.00004993,
-0.00016124
};

float hm[55] = {   //滤波器设置
//900Hz
-0.00091199,-0.00101474,-0.00116930,-0.00136743,
-0.00158383,-0.00177568,-0.00188382,-0.00183550,-0.00154863,
-0.00093721,0.00008221,0.00158380,0.00362557,0.00624318,
0.00944470,0.01320696,0.01747365,0.02215551,0.02713276,
0.03225951,0.03737016,0.04228725,0.04683048,0.05082615,
0.05411659,0.05656885,0.05808219,0.05859375,0.05808219,
0.05656885,0.05411659,0.05082615,0.04683048,0.04228725,
0.03737016,0.03225951,0.02713276,0.02215551,0.01747365,
0.01320696,0.00944470,0.00624318,0.00362557,0.00158380,
0.00008221,-0.00093721,-0.00154863,-0.00183550,-0.00188382,
-0.00177568,-0.00158383,-0.00136743,-0.00116930,-0.00101474,
-0.00091199
};

float hh[55] = {   //滤波器设置
//800Hz
-0.00090253,-0.00091256,-0.00095629,-0.00101043,
-0.00103933,-0.00099622,-0.00082553,-0.00046602,0.00014543,
0.00106949,0.00235992,0.00405915,0.00619427,0.00877363,
0.01178438,0.01519115,0.01893587,0.02293902,0.02710204,
0.03131106,0.03544153,0.03936365,0.04294835,0.04607340,
0.04862921,0.05052434,0.05168996,0.05208333,0.05168996,
0.05052434,0.04862921,0.04607340,0.04294835,0.03936365,
0.03544153,0.03131107,0.02710205,0.02293902,0.01893587,
0.01519115,0.01178438,0.00877363,0.00619427,0.00405915,
0.00235992,0.00106949,0.00014543,-0.00046602,-0.00082553,
-0.00099622,-0.00103933,-0.00101043,-0.00095629,-0.00091256,
-0.00090253
};

/*    //采样频率为12000*2.56Hz时的滤波器
//400Hz
0.00075754,0.00086406,0.00104648,0.00132019,
0.00169878,0.00219357,0.00281308,0.00356266,0.00444413,
0.00545561,0.00659132,0.00784168,0.00919332,0.01062937,
0.01212975,0.01367167,0.01523007,0.01677829,0.01828869,
0.01973337,0.02108489,0.02231698,0.02340524,0.02432777,
0.02506580,0.02560416,0.02593172,0.02604167,0.02593172,
0.02560416,0.02506580,0.02432777,0.02340524,0.02231698,
0.02108489,0.01973337,0.01828869,0.01677829,0.01523007,
0.01367167,0.01212976,0.01062937,0.00919332,0.00784168,
0.00659133,0.00545561,0.00444413,0.00356266,0.00281308,
0.00219357,0.00169879,0.00132019,0.00104648,0.00086406,
0.00075754

//500Hz
0.00035020,0.00047229,0.00064960,0.00090653,
0.00126686,0.00175277,0.00238380,0.00317584,0.00414032,
0.00528342,0.00660555,0.00810092,0.00975747,0.01155686,
0.01347481,0.01548160,0.01754283,0.01962032,0.02167317,
0.02365898,0.02553513,0.02726006,0.02879458,0.03010313,
0.03115489,0.03192478,0.03239430,0.03255209,0.03239430,
0.03192478,0.03115489,0.03010313,0.02879458,0.02726006,
0.02553513,0.02365899,0.02167317,0.01962032,0.01754284,
0.01548160,0.01347481,0.01155686,0.00975747,0.00810092,
0.00660555,0.00528342,0.00414032,0.00317584,0.00238380,
0.00175277,0.00126686,0.00090653,0.00064960,0.00047229,
0.00035020

//600Hz
-0.00016124,-0.00004993,0.00008655,0.00027878,
0.00055971,0.00096303,0.00152146,0.00226498,0.00321908,
0.00440319,0.00582919,0.00750034,0.00941040,0.01154324,
0.01387282,0.01636360,0.01897136,0.02164444,0.02432534,
0.02695259,0.02946284,0.03179311,0.03388304,0.03567711,
0.03712672,0.03819199,0.03884333,0.03906250,0.03884333,
0.03819199,0.03712672,0.03567711,0.03388304,0.03179311,
0.02946284,0.02695259,0.02432534,0.02164444,0.01897136,
0.01636360,0.01387283,0.01154324,0.00941040,0.00750034,
0.00582919,0.00440319,0.00321908,0.00226498,0.00152146,
0.00096303,0.00055971,0.00027878,0.00008655,-0.00004993,
-0.00016124

//650Hz
-0.00040847,-0.00031521,-0.00021297,-0.00007012,
0.00014945,0.00048451,0.00097448,0.00165721,0.00256674,
0.00373106,0.00517012,0.00689408,0.00890198,0.01118082,
0.01370527,0.01643783,0.01932967,0.02232197,0.02534774,
0.02833416,0.03120517,0.03388431,0.03629769,0.03837687,
0.04006162,0.04130229,0.04206193,0.04231771,0.04206193,
0.04130229,0.04006162,0.03837687,0.03629769,0.03388431,
0.03120517,0.02833417,0.02534775,0.02232197,0.01932967,
0.01643783,0.01370527,0.01118082,0.00890198,0.00689408,
0.00517012,0.00373106,0.00256674,0.00165721,0.00097448,
0.00048451,0.00014945,-0.00007012,-0.00021297,-0.00031521,
-0.00040847

//700Hz
-0.00062475,-0.00055835,-0.00049865,-0.00041481,
-0.00026903,-0.00001843,0.00038273,0.00098037,0.00181780,
0.00293286,0.00435518,0.00610367,0.00818450,0.01058961,
0.01329583,0.01626481,0.01944364,0.02276626,0.02615558,
0.02952620,0.03278765,0.03584797,0.03861745,0.04101243,
0.04295881,0.04439531,0.04527612,0.04557291,0.04527612,
0.04439531,0.04295881,0.04101243,0.03861745,0.03584797,
0.03278765,0.02952620,0.02615558,0.02276626,0.01944364,
0.01626481,0.01329583,0.01058961,0.00818450,0.00610367,
0.00435518,0.00293286,0.00181780,0.00098037,0.00038273,
-0.00001843,-0.00026903,-0.00041481,-0.00049865,-0.00055835,
-0.00062475

//800Hz
-0.00090253,-0.00091256,-0.00095629,-0.00101043,
-0.00103933,-0.00099622,-0.00082553,-0.00046602,0.00014543,
0.00106949,0.00235992,0.00405915,0.00619427,0.00877363,
0.01178438,0.01519115,0.01893587,0.02293902,0.02710204,
0.03131106,0.03544153,0.03936365,0.04294835,0.04607340,
0.04862921,0.05052434,0.05168996,0.05208333,0.05168996,
0.05052434,0.04862921,0.04607340,0.04294835,0.03936365,
0.03544153,0.03131107,0.02710205,0.02293902,0.01893587,
0.01519115,0.01178438,0.00877363,0.00619427,0.00405915,
0.00235992,0.00106949,0.00014543,-0.00046602,-0.00082553,
-0.00099622,-0.00103933,-0.00101043,-0.00095629,-0.00091256,
-0.00090253

//900Hz
-0.00091199,-0.00101474,-0.00116930,-0.00136743,
-0.00158383,-0.00177568,-0.00188382,-0.00183550,-0.00154863,
-0.00093721,0.00008221,0.00158380,0.00362557,0.00624318,
0.00944470,0.01320696,0.01747365,0.02215551,0.02713276,
0.03225951,0.03737016,0.04228725,0.04683048,0.05082615,
0.05411659,0.05656885,0.05808219,0.05859375,0.05808219,
0.05656885,0.05411659,0.05082615,0.04683048,0.04228725,
0.03737016,0.03225951,0.02713276,0.02215551,0.01747365,
0.01320696,0.00944470,0.00624318,0.00362557,0.00158380,
0.00008221,-0.00093721,-0.00154863,-0.00183550,-0.00188382,
-0.00177568,-0.00158383,-0.00136743,-0.00116930,-0.00101474,
-0.00091199

//1000Hz
-0.00065033,-0.00083665,-0.00108319,-0.00140151,
-0.00178426,-0.00220165,-0.00259989,-0.00290211,-0.00301174,
-0.00281831,-0.00220533,-0.00105965,0.00071829,0.00320432,
0.00644123,0.01043119,0.01513067,0.02044841,0.02624669,
0.03234620,0.03853408,0.04457482,0.05022327,0.05523891,
0.05940029,0.06251872,0.06445011,0.06510417,0.06445011,
0.06251872,0.05940029,0.05523891,0.05022327,0.04457482,
0.03853408,0.03234620,0.02624669,0.02044841,0.01513067,
0.01043119,0.00644123,0.00320432,0.00071829,-0.00105965,
-0.00220533,-0.00281831,-0.00301174,-0.00290211,-0.00259989,
-0.00220165,-0.00178426,-0.00140151,-0.00108319,-0.00083665,
-0.00065033
*/
/*  //采样频率为8000*2.56时的滤波器
// 100Hz
0.000707,0.000742,0.000832,0.000978,
0.001180,0.001436,0.001743,0.002099,0.002498,
0.002937,0.003410,0.003911,0.004433,0.004969,
0.005511,0.006053,0.006586,0.007104,0.007598,
0.008061,0.008488,0.008871,0.009205,0.009486,
0.009708,0.009870,0.009967,0.010000,0.009967,
0.009870,0.009708,0.009486,0.009205,0.008871,
0.008488,0.008061,0.007598,0.007104,0.006586,
0.006053,0.005511,0.004969,0.004433,0.003911,
0.003410,0.002937,0.002498,0.002099,0.001743,
0.001436,0.001180,0.000978,0.000832,0.000742,
0.000707
//200Hz
0.000936,0.001015,0.001176,0.001426,
0.001770,0.002213,0.002755,0.003396,0.004133,
0.004960,0.005871,0.006855,0.007899,0.008992,
0.010116,0.011256,0.012394,0.013512,0.014592,
0.015616,0.016567,0.017428,0.018184,0.018822,
0.019330,0.019700,0.019925,0.020000,0.019925,
0.019700,0.019330,0.018822,0.018184,0.017428,
0.016567,0.015616,0.014592,0.013512,0.012394,
0.011256,0.010116,0.008992,0.007899,0.006855,
0.005871,0.004960,0.004133,0.003396,0.002755,
0.002213,0.001770,0.001426,0.001176,0.001015,
0.000936
*/

/*
//300Hz
0.000530,0.000649,0.000832,0.001101,
0.001476,0.001974,0.002610,0.003396,0.004338,
0.005439,0.006696,0.008102,0.009644,0.011303,
0.013057,0.014878,0.016736,0.018598,0.020428,
0.022190,0.023848,0.025367,0.026715,0.027861,
0.028781,0.029453,0.029862,0.030000,0.029862,
0.029453,0.028781,0.027861,0.026715,0.025367,
0.023848,0.022190,0.020428,0.018598,0.016736,
0.014878,0.013057,0.011303,0.009644,0.008102,
0.006696,0.005439,0.004338,0.003396,0.002610,
0.001974,0.001476,0.001101,0.000832,0.000649,
0.000530
*/

/*
//400Hz
-0.000235,-0.000128,0.000000,0.000179,
0.000444,0.000829,0.001370,0.002099,0.003043,
0.004224,0.005657,0.007346,0.009286,0.011463,
0.013850,0.016410,0.019099,0.021863,0.024641,
0.027369,0.029981,0.032408,0.034588,0.036461,
0.037976,0.039089,0.039771,0.040000,0.039771,
0.039089,0.037976,0.036461,0.034588,0.032408,
0.029981,0.027369,0.024641,0.021863,0.019099,
0.016410,0.013850,0.011463,0.009286,0.007346,
0.005657,0.004224,0.003043,0.002099,0.001370,
0.000829,0.000444,0.000179,0.000000,-0.000128,
-0.000235
*/

/*
   //500Hz
-0.000840,-0.000823,-0.000832,-0.000840,
-0.000810,-0.000696,-0.000445,-0.000000,0.000695,
0.001694,0.003042,0.004772,0.006904,0.009441,
0.012365,0.015638,0.019204,0.022988,0.026898,
0.030829,0.034669,0.038301,0.041609,0.044486,
0.046834,0.048572,0.049640,0.050000,0.049640,
0.048572,0.046834,0.044486,0.041609,0.038301,
0.034669,0.030829,0.026898,0.022988,0.019204,
0.015638,0.012365,0.009441,0.006904,0.004772,
0.003042,0.001694,0.000695,-0.000000,-0.000445,
-0.000696,-0.000810,-0.000840,-0.000832,-0.000823,
-0.000840,
*/
/*
  //600Hz
-0.000877,-0.000999,-0.001176,-0.001404,
-0.001659,-0.001902,-0.002073,-0.002099,-0.001892,
-0.001363,-0.000421,0.001017,0.003017,0.005622,
0.008846,0.012669,0.017039,0.021863,0.027018,
0.032352,0.037687,0.042837,0.047606,0.051809,
0.055276,0.057862,0.059460,0.060000,0.059460,
0.057862,0.055276,0.051809,0.047606,0.042837,
0.037687,0.032352,0.027018,0.021863,0.017039,
0.012669,0.008846,0.005622,0.003017,0.001017,
-0.000421,-0.001363,-0.001892,-0.002099,-0.002073,
-0.001902,-0.001659,-0.001404,-0.001176,-0.000999,
-0.000877
*/
/*
//650Hz
-0.000656,-0.000842,-0.001087,-0.001404,
-0.001784,-0.002198,-0.002592,-0.002888,-0.002991,
-0.002791,-0.002170,-0.001017,0.000766,0.003256,
0.006493,0.010481,0.015175,0.020483,0.026268,
0.032352,0.038522,0.044543,0.050173,0.055171,
0.059317,0.062424,0.064348,0.065000,0.064348,
0.062424,0.059317,0.055171,0.050173,0.044543,
0.038522,0.032352,0.026268,0.020483,0.015175,
0.010481,0.006493,0.003256,0.000766,-0.001017,
-0.002170,-0.002791,-0.002991,-0.002888,-0.002592,
-0.002198,-0.001784,-0.001404,-0.001087,-0.000842,
-0.000656
*/
//700Hz
/*
-0.000319,-0.000545,-0.000832,-0.001207,
-0.001679,-0.002235,-0.002831,-0.003396,-0.003826,
-0.003996,-0.003766,-0.002989,-0.001527,0.000733,
0.003872,0.007921,0.012858,0.018598,0.024993,
0.031841,0.038891,0.045855,0.052431,0.058315,
0.063227,0.066925,0.069221,0.070000,0.069221,
0.066925,0.063227,0.058315,0.052431,0.045855,
0.038891,0.031841,0.024993,0.018598,0.012858,
0.007921,0.003872,0.000733,-0.001527,-0.002989,
-0.003766,-0.003996,-0.003826,-0.003396,-0.002831,
-0.002235,-0.001679,-0.001207,-0.000832,-0.000545,
-0.000319
*/

/*
   //800Hz
0.000454,0.000253,-0.000000,-0.000355,
-0.000860,-0.001542,-0.002401,-0.003396,-0.004436,
-0.005385,-0.006062,-0.006255,-0.005739,-0.004296,
-0.001739,0.002061,0.007158,0.013512,0.020984,
0.029331,0.038221,0.047249,0.055964,0.063902,
0.070618,0.075723,0.078914,0.080000,0.078914,
0.075723,0.070618,0.063902,0.055964,0.047249,
0.038221,0.029331,0.020984,0.013512,0.007158,
0.002061,-0.001739,-0.004296,-0.005739,-0.006255,
-0.006062,-0.005385,-0.004436,-0.003396,-0.002401,
-0.001542,-0.000860,-0.000355,-0.000000,0.000253,
0.000454
*/
/*
    //900Hz
0.000920,0.000892,0.000832,0.000688,
0.000389,-0.000141,-0.000963,-0.002099,-0.003512,
-0.005097,-0.006670,-0.007975,-0.008700,-0.008507,
-0.007064,-0.004089,0.000611,0.007104,0.015307,
0.024977,0.035710,0.046969,0.058120,0.068481,
0.077381,0.084222,0.088529,0.090000,0.088529,
0.084222,0.077381,0.068481,0.058120,0.046969,
0.035710,0.024977,0.015307,0.007104,0.000611,
-0.004089,-0.007064,-0.008507,-0.008700,-0.007975,
-0.006670,-0.005097,-0.003512,-0.002099,-0.000963,
-0.000141,0.000389,0.000688,0.000832,0.000892,
0.000920
*/

/*
  //1000Hz
0.000763,0.000968,0.001176,0.001359,
0.001444,0.001324,0.000879,0.000000,-0.001373,
-0.003222,-0.005420,-0.007721,-0.009764,-0.011098,
-0.011227,-0.009665,-0.006008,-0.000000,0.008416,
0.019053,0.031479,0.045025,0.058844,0.071980,
0.083458,0.092389,0.098057,0.100000,0.098057,
0.092389,0.083458,0.071980,0.058844,0.045025,
0.031479,0.019053,0.008416,-0.000000,-0.006008,
-0.009665,-0.011227,-0.011098,-0.009764,-0.007721,
-0.005420,-0.003222,-0.001373,0.000000,0.000879,
0.001324,0.001444,0.001359,0.001176,0.000968,
0.000763
*/

__fastcall lDieselHRBP::lDieselHRBP(void)
{
    iIteration =16;
    strTempData = NULL;
    iTDPosi = 0;                  //上止点的位置
    fAllAngle = 35.0;
    fQL       = NULL;
    Fuel_burn = NULL;             //燃油消耗率
    fAQ       = NULL;                   //散热率
    fTT       = NULL;                   //缸内气体温度
    fOldP     = NULL;                 //最原始的压力值 ,测量值的叠加值
    fNewP     = NULL;                    //测量得到的气缸压力
    fPBuffer  = NULL;
    fpOilP    = NULL;
    fCDHDF    = NULL;                //累积放热率
    fDHDF     = NULL;                 //计算所得的放热率
    fFFFai    = NULL;                //压力值所对应的曲轴转角
    farDVDF   = NULL;               //绝热过程的容积变化过程
    farDPDF   = NULL;                 //压力升高率
    farV      = NULL;                    //气缸容积
    farLogP   = NULL;                 //气缸压力对数值
    farLogV   = NULL;                 //气缸容积对数值
    farFFTPr  = NULL;                //压力FFT的实部
    farFFTPi  = NULL;                //压力FFT的虚部
    farW      = NULL;                    //所作的功
    farDW     = NULL;                   //瞬时功
    farQW     = NULL;                   //散热量
    farDQW    = NULL;                  //瞬时散热量
    farQA     = NULL;                   //总放热率
    farDQA    = NULL;                  //瞬时放热率
    farQE     = NULL;                   //内能+功
    farDQE    = NULL;                  //瞬时 内能+功

//预处理时需要的数据
//--------------------------------------------------------------------
    for(int i=0; i<PASSAGENUM; i++)
    {
        ipACData[i]        = NULL;     //作为累加数据的缓冲     ,最大长度8K
        ipAData[i]         = NULL;      //用于保存提取出来的数据，  最大长度8K, 共有空间56K,占去了24K
        ipOData[i]         = NULL;       //用于保存三个通道的采样值，最大长度为64K
        siConvertBuffer[i] = NULL;
    }
    f3DData             = NULL;
    fpFData   = NULL;        //用于保存滤波以后的数据
    fpSMData  = NULL;
    fpSMDPDF  = NULL;
    fpDPDF    = NULL;         //用于保存压力升高率的缓存区
//====================================================================

//    iAbstractLength = 4096;
    fBarToPa = 1000000.0;   //是10的5次方，当使用Mpa时，fBar应为1000000.0;

    bPP0 = false;                   //true:设置了数据 false:没有设置数据
    bPP1 = false;                   //意义同上
    bPP2 = false;                   //意义同上
//    初始化各气体常数
/*
    for(int i=0;i<5;i++)
    {
        for(int j=0;j<7;j++)
        {
            fscanf(fp,"%f\n",&fU[i][j]);
        }
    }
*/
// 二氧化碳的气体常数
    fU[0][0] = 3.0959;
    fU[0][1] = 2.73114e-03;
    fU[0][2] = -7.88542e-07;
    fU[0][3] = 8.66002e-11;
    fU[0][4] = 0.0;
    fU[0][5] = 6.58393;
    fU[0][6] = -3.9364e8;
//水汽的气体常数
    fU[1][0] = 3.74292;
    fU[1][1] = 5.65590e-04;
    fU[1][2] = 4.9524e-08;
    fU[1][3] = -1.81802e-11;
    fU[1][4] = 0.0;
    fU[1][5] = 9.6514;
    fU[1][6] = -2.39225e8;

//氮气的气体常数
    fU[2][0] = 3.34435;
    fU[2][1] = 2.9426e-04;
    fU[2][2] = 1.953e-09;
    fU[2][3] = -6.5747e-12;
    fU[2][4] = 0.0;
    fU[2][5] = 3.75863;
    fU[2][6] = 0.0;

//氧气的气体常数
    fU[3][0] = 3.25304;
    fU[3][1] = 6.52350e-04;
    fU[3][2] = -1.49524e-07;
    fU[3][3] = 1.53897e-11;
    fU[3][4] = 0.0;
    fU[3][5] = 5.71243;
    fU[3][6] = 0.0;

// 以下这种好像有问题

    fU[4][0] = -0.71993;
    fU[4][1] = 4.6426e-02;
    fU[4][2] = -1.68385e-05;
    fU[4][3] = 2.67009e-09;
    fU[4][4] = 0.0;
    fU[4][5] = 0.0;
    fU[4][6] = -4.9298e08;
    fDeltaAngle = 16.0;

    fNegtive     = 1.0;
    fDeltaP      = 0.10;    //单位是　MPa
    fBarP0       = 0.1013;    //单位是　MPa
    iNumPerAngle = 5;        //每一度5个数据点
    fLevelStart = 0.3;
    fLevelEnd   = 0.4;
    fOilGain    = 1.0;
}

__fastcall lDieselHRBP::~lDieselHRBP(void)
{
    DeleteMemory();
    DeleteOriginalMemory();
    DeleteAbstractMemory();
    Delete3DMemory();
}

bool __fastcall lDieselHRBP::GetfU(char* strfilename)
{
    //读入计算所需的气体多项式参数
//    String strExeFileName=::ParamStr(0);
//    String strNowPath=::ExtractFilePath(strExeFileName);
//    strNowPath +="ParamU.dap";
    FILE * fp;
    if((fp=fopen(strfilename,"r")) == NULL)
    {
//        Application->MessageBox("文件打开错误!","提示",MB_OK|MB_ICONINFORMATION);
        return false;
    }
    for(int i=0;i<5;i++)
    {
        for(int j=0;j<7;j++)
        {
            fscanf(fp,"%f\n",&fU[i][j]);
        }
    }
    fclose(fp);
    return true;
}
bool __fastcall  lDieselHRBP::SetRealPressure(float* fp,float*ffai,int ilen)
{
    //在模型外要求对气缸压力进行了处理，
    //然后再将气缸压力及所对应的曲轴转角输入到计算模型中
    iPLength = ilen;
    if(!AllocateMemory(ilen))
    {
        return false;
    }
    for(int i=0; i<iPLength; i++)
    {
        fNewP[i] = fp[i];
        fFFFai[i] = ffai[i];
        fDHDF[i] = 0.0;
    }
    float ftemp;
    int iposi;
    ftemp = fNewP[0];
    iposi = 0;
    for(int i=1; i<iPLength; i++)
    {
        if(ftemp > fNewP[i])
        {
            ftemp = fNewP[i];
            iposi = i;
        }
    }
    if(iposi> 4)
    {
        ftemp = 0.0;
        for(int i = iposi-3; i<=iposi+3; i++)
        {
            ftemp += fNewP[i];
        }
    }
    else
    {
        ftemp = 0.0;
        for(int i = 0; i<7; i++)
        {
            ftemp += fNewP[i];
        }
    }
    ftemp /= 7.0;
    ftemp = fPAir - ftemp;
    for(int i=0; i<iPLength; i++)
    {
        fNewP[i] += ftemp;
    }
    return true;
}


float  __fastcall lDieselHRBP::GetVolumn(float fai, float& fv)
{
    //此方法用于计算在某一曲轴转角下气缸内的容积
    //输入：　
    //　　fai: 柴油机曲轴转角
    //    fv :  气缸容积
   float fsin,fcos;
   float fnfai;
   float ftemp;
   fnfai = fai*PI/180.0;
   fsin  = fLMDa*fLMDa*sin(fnfai)*sin(fnfai);
   fcos  = cos(fnfai);

   fv    = PI*fDiameter*fDiameter/4.0;
   ftemp =   fStroke*(1.0/(fCRatio - 1.0) + 0.5)
           + fPodLength*(1.0 - sqrt(1.0 - fsin/4.0) - fLMDa/2.0*fcos);
   fv    *= ftemp;

//   fv = PI*fDiameter*fDiameter/4.0*(fStroke/(fCRatio-1.0)+fStroke/2.0*((1.0+1.0/fLMDa)-cos(fnfai)-1.0/fLMDa*sqrt(1.0-fLMDa*fLMDa*fsin*fsin)));
//   fsin = fLMDa*fLMDa*sin(fnfai)*sin(fnfai);
//   fv = PI*fDiameter*fDiameter/4.0*(fStroke/(fCRatio-1.0)+fStroke/2.0*((1.0+1.0/fLMDa)-cos(fnfai)-1.0/fLMDa*sqrt(1.0-fLMDa*fLMDa*fsin*fsin)));
//   fV = PI*fDI*fDI/4.0*(fS/(fYP-1.0)+fS/2.0*((1.0+1.0/fLT)-cos(ftemp)-1.0/fLT*sqrt(1.0-fLT*fLT*fST*fST) ));
    return fv;
}


float __fastcall lDieselHRBP::GetfX(float ffai)
{
    //此方法用于计算某一曲轴转角下气缸壁面露在燃烧室内的长度
    //输入：
    //　fai:　柴油机曲轴转角
    // 输出：
    //        fret 为露在外面的高度

   float fret;
   float fsin;
   float fnfai;
   fnfai = (180.0+ffai)*PI/180.0;
   fsin  = fLMDa*fLMDa*sin(fnfai)*sin(fnfai);
   fret  = fX0+0.5*fStroke*(1.0+cos(fnfai)+2.0*fPodLength/fStroke*(1.0-sqrt(1.0-fsin)));
   return fret;
}

float __fastcall lDieselHRBP::CalculateFDQ(float fp, float ft, float fx)
{
    //TODO: Add your source code here
    //输入：此方法用于计算散热量
    //  fp:     气缸内的压力    气缸内的压力为什么会出现负值?????
    //  ft:     气缸内的温度
    //  fx:     活塞的位置

    float fTALFA;
    float fTR[3];
    float ftemp;
    float ftt,ftw;
    float fcm;
    float fcmp;
    fcm = fEn/30.0*fStroke;
    fcmp = fcm*fp/fBarToPa;
//  首先对数据是否有效进行判断  是否要加上一个判断呢？
    if(   (fp < 0.0)
        ||(ft < 0.0)
//        ||(fx )
    )
    {
        ftemp = 0.0;
    }
    else
    {
//Sitkei在小型四冲程高速柴油机上进行试验后得到的公式
//    fTALFA = 29.75*pow(fp/100000.0,0.7)*pow(ft,-0.2)*pow(fcm,0.7)*pow((2.0*fDiameter*fx)/(fDiameter+2.0*fx),-0.3);
//下面的是G.Woschni的公式，主要用于直喷式四冲程增压机
        fTALFA = 265.0*pow(fDiameter,-0.214)*pow(ft,-0.525)*pow(fcmp,0.786);
//    对于fTALFA的计算，　ft 为温度
        for(int i=0;i<3;i++)
        {
            ftw = fTW[i]/100.0;
            ftt = ft/100.0;
            if(ft > fTW[i])
            {
                fTR[i] = 0.421*(ftt*ftt*ftt*ftt-ftw*ftw*ftw*ftw)/(ft - fTW[i]);
            }
            else
            {
                fTR[i] = 0.0;
            }
        }
        ftemp = 0.0;
        ftt = 0.0;
//  在下面计算公式中的 57.29578是什么意思呢？
        for(int i=0;i<3;i++)
        {
//            ftemp += fTALFA*fAREA[i]*(ft - fTW[i])/6.0/fEn*57.29578;
//        ftt   += fTR[i]*fAREA[i]*(ft - fTW[i])/6.0/fEn*57.29578;
            ftemp += fTALFA*fAREA[i]*(ft - fTW[i])/6.0/fEn;
            ftt += fTR[i]*fAREA[i]*(ft - fTW[i])/6.0/fEn;
        }
        ftemp += ftt;
    }
    return ftemp;
}

void __fastcall lDieselHRBP::GetArea(float ffai,float& farea )
{
    //TODO: 用于计算散热面积
    float fnfai,fsin;
    float fa;
    fnfai = ffai*PI/180.0;
    fsin = fLMDa*fLMDa*sin(fnfai)*sin(fnfai);
    fa = 1.0 - cos(fnfai)+ (1.0/fLMDa)*(1.0 - sqrt(1.0 - fsin));
//    fb = sin(fnfai)+fLMDa/2.0*sin(2.0*fnfai)/sqrt(1.0-fsin);
    farea = PI*fDiameter*(fStroke*(2.0*fC+fa)+fDiameter)/2.0;
}
float __fastcall lDieselHRBP::CalculateTENB(float fT, float * fA)
{
    //TODO: Add your source code here
    //此函数用于不同组份在某一特定温度下的值 可能是内能也可能是焓
    float fTEN;   //用于保存计算结果
    fTEN = 0.0;
    float ftemp;
    for(int i=0;i<5;i++)
    {
        for(int j=0;j<4;j++)
        {
            ftemp = fU[i][j];
            ftemp *= pow(fT,(double)(j+1));
            ftemp *= fA[i];
            fTEN += ftemp;   //fA[i]*fU[i][j]*pow(fT,j);
        }
    }
    for(int i=0;i<5;i++)
    {
        fTEN -= fA[i]*fT;
    }
    fTEN *=fRMOL;
    return fTEN;
}

bool __fastcall lDieselHRBP::SetRealPressure(char *strfilename)
{
    //TODO: Add your source code here
    float ftemp1,ftemp2;
    int inum=0;
    FILE * fp;
    char str[100];
    if((fp=fopen(strfilename,"r")) == NULL)
    {
//        Application->MessageBox("文件打开错误!","提示",MB_OK|MB_ICONINFORMATION);
        return false;
    }
    while(fgets(str,100,fp)!=NULL)
    {
        inum ++;
    }
    fseek(fp,0l,SEEK_SET);
    if(!AllocateMemory(3600))  // inum
    {
        return false;
    }

    for(int i=0;i<inum;i++)
    {
        fscanf(fp,"%f\t\%f\n",&ftemp1,&ftemp2);
        fOldP[i] = ftemp2 ;
        fFFFai[i] = ftemp1;
    }
    fclose(fp);
    iPLength = inum;
    float ftemp;
    int iposi;
    ftemp = fOldP[0];
    iposi = 0;
    for(int i=1; i<iPLength; i++)
    {
        if(ftemp > fOldP[i])
        {
            ftemp = fOldP[i];
            iposi = i;
        }
    }
    if(iposi> 4)
    {
        ftemp = 0.0;
        for(int i = iposi-3; i<=iposi+3; i++)
        {
            ftemp += fOldP[i];
        }
    }
    else
    {
        ftemp = 0.0;
        for(int i = 0; i<7; i++)
        {
            ftemp += fOldP[i];
        }
    }
    ftemp /= 7.0;
    ftemp = fP0/100000.0 - ftemp;
    for(int i=0; i<iPLength; i++)
    {
        fOldP[i] += ftemp;
    }
/*
    for(int i=0; i<iPLength;i++)
    {
        f
    }
*/
    GetMinMax(fOldP,iPLength,fMinOldP,fMaxOldP,ftemp,true);
    return true;
}


void __fastcall lDieselHRBP::SmoothCurve(float &fp,int iposi)
{
    //TODO: Add your source code here
    //此函数用于计算压力曲线的光顺值  是七点光顺方法
    //输入为待求数据的位置 iposi
    // fp 为计算后的压力值
    float ftemp;
    if(iposi == 0)  //如果是第一个采样点
    {
         ftemp =(39.0*fOldP[0] + 8.0*fOldP[1] - 4.0*fOldP[2] - 4.0*fOldP[3]
                 +fOldP[4] + 4.0*fOldP[5] - 2.0*fOldP[6])/42.0;
    }
    else if(iposi == 1)
    {
         ftemp =(8.0*fOldP[0] + 19.0*fOldP[1] + 16.0*fOldP[2] + 6.0*fOldP[3]
                 +4.0*fOldP[4] - 7.0*fOldP[5] + 4.0*fOldP[6])/42.0;
    }
    else if(iposi == 2)
    {
         ftemp =(-4.0*fOldP[0] + 16.0*fOldP[1] + 19.0*fOldP[2] + 12.0*fOldP[3]
                 +2.0*fOldP[4] - 4.0*fOldP[5] + fOldP[6])/42.0;
    }
    else if(iposi == iPLength -3)
    {
        ftemp = ( fOldP[iPLength-7] -4.0*fOldP[iPLength-6] +2.0*fOldP[iPLength-5]
                 +12.0*fOldP[iPLength-4] +19.0*fOldP[iPLength -3] +16.0*fOldP[iPLength-2]
                 -4.0*fOldP[iPLength-1])/42.0;
    }
    else if(iposi == iPLength -2)
    {
        ftemp = ( 4.0*fOldP[iPLength-7] -7.0*fOldP[iPLength-6] -4.0*fOldP[iPLength-5]
                 +6.0*fOldP[iPLength-4] +16.0*fOldP[iPLength -3] +19.0*fOldP[iPLength-2]
                 +8.0*fOldP[iPLength-1])/42.0;
    }
    else if(iposi == iPLength -1)
    {
        ftemp = ( -2.0*fOldP[iPLength-7] +4.0*fOldP[iPLength-6] +fOldP[iPLength-5]
                 -4.0*fOldP[iPLength-4] -4.0*fOldP[iPLength -3] +8.0*fOldP[iPLength-2]
                 +39.0*fOldP[iPLength-1])/42.0;
    }
    else
    {
        ftemp = (-2.0*(fOldP[iposi-3]+fOldP[iposi+3])+3.0*(fOldP[iposi-2]+fOldP[iposi+2])
                 +6.0*(fOldP[iposi-1]+fOldP[iposi+1])+7.0*fOldP[iposi])/21.0;
    }
    fp = ftemp;
}
void __fastcall lDieselHRBP::TJHeatRelease(void)
{
    //TODO: Add your source code here
    //当各参数及压力曲线都已初始后调用此函数进行放热率计算
    AnsiString strTemp;
    float fW,fW1,fW2;
    float fH;
    float fFMUF;                  //
    float fDW;                    //这一步长内所做的功
    float fVH;                    //气缸的排量
    float fAN;                    //柴油机转速
    float fPIS,fPIM;
    float fNIS,fNIM;
    float fNES,fNEM;
    float fGH;
    float fATI;
    float fGIS;   //,fGIM;
    float fGES;   //,fGEM;
    float fQW1;
    float fDPMAX,fDQMAX;
    float fQF1,fDQRCA;
    float fCY;
    float fDGF;
    float fM1;
    float fE1,fE2;
    float fDPRCA;
    float fB[5];
    float fB2[5];

    int iI = 0,iJK;
    float fP1,fX,fX1,fX2,fV1,fV2;
    float fT1,fT2;
    float fPCM;

    float fPK = 19.0; //此参数尚不知道是什么意思？
    float fCM;

    float fFMOO2,fFMON2;  //新鲜空气的氧气和氮气的摩尔数
    float fFMRCO2,fFMRH2O,fFMRN2,fFMRO2,fMRH2O;
    float fMRN2,fMRO2;    //反应后所剩下的氧气和氮气摩尔数
    float fDMN2,fDMO2,fDMH2O,fDMCO2;
    float fMA,fFMR,fFMRA,fM2;

    float fPEM,fPES;
    float fDPMMAX,fCADPMAX,fDMF1,fDMF2;
    float fXLM;
    float fT,fXH,fDB,fPQ,fPM,fDQ,fQW2,fQF2;
    float fDQMMAX,fCADQMAX;
    float ftemp;
    float Fuel_mass = 0.0;
    float FJL[] = {0.5,0.5,1.0,1.0,0.5};
    float fgl = 0.0;
    ftemp = GetVolumn(0,ftemp);  //当活塞在上止点时缸内的体积
    fXH   = 4.0*ftemp/(PI*fDiameter*fDiameter);   //暂时认为当量高度为0;　fXH为当量高度
    fDB   = fDiameter;   //暂时认为当量直径为气缸直径;
//    fH = fDFai;                //计算步长
    fH    = fFFFai[1] - fFFFai[0];
    fAN   = fEn;                 //柴油机转速
    fW    = 0.0;                  //柴油机作功

    fFMUF = 12.0*fNC + fMH;  //燃料的摩尔质量。
    fCA   = fFFFai[iI];
    fP1   = fNewP[iI];

    DetectCPosi();

//    fX1 = fXX(fCA);
    fV1 = GetVolumn(fCA,fV1);

    while( iI < iPLength-1)
    {
        fCA += fH;
        fV2 = GetVolumn(fCA,fV2);
        fDW = (fNewP[iI]+fNewP[iI+1])*fBarToPa*(fV2-fV1)/2.0;  //乘以100000是因为单位是bar
        fW += fDW;
        farDW[iI+1] = fDW/fH;
        farW[iI+1] = fW;
        iI = iI + 1;
        fV1 =fV2;
    }

    farDW[iPLength - 1] = farDW[iPLength - 2];
    farW[iPLength - 1]  = farW[iPLength -2];
    fVH = PI*fDiameter*fDiameter*fStroke/4.0;  //计算气缸的排量
    fPIS = fW / fVH;
//    fPIM = fPIS * 1.02e-5;
//    fNIS = fPIS*fVH*fAN*fFI/fTAU/300.0/100.0;    //fFI 为缸数
//    fNIM = fNIS*1.36;
//    fNEM = 0.001*fPK*fAN;
//    fNES = 0.736*fNEM;
//    fATM = fNES/fNIS;
//    fPEM = fPIM*fATM;
//    fPES = fPIS*fATM;
//    fGH = fGF*3.6/fTF;          //
//    fATI = 3.6E6*fNIS/fGH/fHU;  //fHU　燃料的低热值
///    fGIS = fGH/fNIS*1.0e3;
//    fGIM = 0.736*fGIS;
 //   fGES = fGIS/fATM;
//    fGEM = 0.736*fGES;
//    fATE = fATM*fATI;
//开始计算喷油参数

    fCA = fCAING;                           //从开始喷油处进行计算 ,fCAING为喷油提前角
    float fI00;

    fI00 = fFFFai[0];
//    iI = (int)fabs((fI00 - fCA)/fH);                      //用于定位所测量的气缸压力
    for(int i = 0;i<iPLength;i++)
    {
        fTT[i] = fT0;
        fDHDF[i] = 0.0;                     //对于没有计算的角度置放热率值为0
    }
    fQW1 = 0.0;                             //气缸散热量
    iJK = 1;
    fDPMAX = 0.0;                           //最大压力变化率
    fDQMAX = 0.0;                           //最大放热率
    fW1 = 0.0;                              //做功
    fQF1 = 0.0;                             //燃油放热量
    fDQRCA = 0.0;                           //燃油放热率
    fCY = 1.0;                              //????
//    fDGF = 0.12*fGF/(fTF*fAN*fFI);
//    fDGF = 0.12*fGF/(fTF*fAN);
    fDGF = fGF/fTF;                         //fTF为喷油持续期，fGF为单循环喷油量，fDGF为每曲轴转角喷油量用于做为喷油预估量
    fCM = fStroke*fEn/30.0;                 //fCM为活塞平均速度，fAN为柴油机转速
//    fMA = fALPHA*fLO*fDGF;
    fV0 = GetVolumn(-138.0,fV0);              //计算此时气缸工作容积
//    fV0 = GetVolumn(-180,fV0);

//    fMA = fP0*fV0/(fRMOL*fT0);              //计算此时气内的新鲜充量的摩尔数　　　？？？？好像容积不对

//    fMA = fBarToPa*fBarP0*fV0/(fRMOL*fT0);              //计算此时气内的新鲜充量的摩尔数　　　？？？？好像容积不对
      fMA = fBarToPa*fNewP[icStartPosi]*fV0/(fRMOL*fT0);
//fMA 的单位是kmol

//此时是否要考虑残余废气系数呢
    fFMRA = fMA*fGAMA;                      //残余废气的摩尔数
    fFMOO2 = 0.21*fMA*(1.0-fGAMA);          //燃烧前空气中氧气的摩尔数
    fFMON2 = 0.79*fMA*(1.0-fGAMA);          //燃烧前空气中氮气的摩尔数
//  MO 为燃烧前
//  MR 为燃烧后
//  fNC: 燃油分子中所含碳原子数
//  fMH: 燃油分子中所含氢原子数
                                            //以下用于计算完全燃烧一摩尔燃料其产物中各种成份的摩尔数
    fFMRCO2 = fNC;                          //二氧化碳的摩尔数与燃料中碳原子的个数相同
    fFMRH2O = fMH/2.0;                      //水的摩尔数是燃料中氢原子的个数除以2
    fFMRN2 = 3.76*fALPHA*(fNC+fMH/4.0);     //fALPHA为过量空气系数　
    fFMRO2 = (fALPHA - 1.0)*(fNC + fMH/4.0); //燃烧后氧气的摩尔数

    fFMR = fFMRCO2+fFMRH2O+fFMRN2+fFMRO2;   //完全燃烧后的各组分的总和
//fGAMA为残余废气系数，对于非增压柴油机，其值可为0.03至0.06,
//对于增压柴油机而言可取为0
    fB[0] = fFMRA*fFMRCO2/fFMR;           //二氧化碳的气体摩尔数
    fB[1] = fFMRA*fFMRH2O/fFMR;           //水汽的气体摩尔数
    fB[2] = fFMRA*fFMRN2/fFMR + fFMON2;   //氮气的气体摩尔数
    fB[3] = fFMRA*fFMRO2/fFMR+fFMOO2;     //氧气的气体摩尔数
    fB[4] = 0.0;                   //燃油的摩尔数　　fDGF 为瞬时喷油量，fFMUF燃料的摩尔质量

    fCA = fFFFai[icStartPosi];
    fM1 = fB[0]+fB[1]+fB[2]+fB[3]+fB[4];
    fV1 = GetVolumn(fCA,fV1);               //这时此时的气缸容积
    fX1 = GetfX(fCA);
    fT1 = fBarToPa*fNewP[icStartPosi]*fV1/fRMOL/fM1;    //此时气缸内的温度
//气门刚刚关闭时，认为的是增压器压力、而刚刚关闭后却认为是测量的压力，两个值差得太大
    fTT[icStartPosi] = fT1;
    fE1 = CalculateTENB(fT1,fB);            //此时气体的内能
    iI = icStartPosi;
    iStartFai = icStartPosi;
    float fE0;
//    float fHeatRate;
    fE0 = fE1;
/*
//---------------------------------------------------
    #ifdef SELF_DEBUG
        FILE * fpp;
        fpp  = fopen("e:\\heat.dat","w");
    #endif
//===================================================
*/
//    FormMain->MemoITInfo->Lines->Clear();
    try
    {
      do
      {
        fH = fFFFai[iI+1] - fFFFai[iI];
        fCA = fCA +fH;                           //曲轴转角加上步长
        fX2 = GetfX(fCA);                        //获取侧向高度
        fV2 = GetVolumn(fCA,fV2);                //得到此时气缸容积
        fT2 = fBarToPa*fNewP[iI+1]*fV2/fRMOL/fM1;
        fE2 = CalculateTENB(fT2,fB);
        fPCM = fBarToPa*(fNewP[iI]+fNewP[iI+1])/2.0;    //此时气缸内的平均压力
        fDW = fPCM*(fV2-fV1);                    //在这一步长内气体所做的功
        fW2 = fW1 +fDW;                          //fW2为做功的总和
//计算压力随曲轴转角的变化率
        fDPRCA = fBarToPa*(fNewP[iI+1]-fNewP[iI])/fH;   //气缸压力变化率
        if(fDPMAX < fDPRCA )                     //计算最大气缸压力变化率
        {
            fDPMAX = fDPRCA;
            fDPMMAX = fDPMAX*1.02e-5;
            fCADPMAX = fCA;
        }
        fDMF1 = fDGF*fCY/60.0;                   //除以60是什么意思??????
        int iIterNum =0;
        do
        {

//          fDMF1 = fDGF*fCY/60.0;
            fDMCO2 = fNC*fDMF1/fFMUF;
            fDMH2O = fMH*fDMF1/fFMUF/2.0;
            fDMN2 = 0.0;
            fDMO2 = -(fNC+fMH/4.0)/fFMUF*fDMF1;
            fB2[0] = fB[0] + fDMCO2;
            fB2[1] = fB[1] + fDMH2O;
            fB2[2] = fB[2] + fDMN2;
            fB2[3] = fB[3] + fDMO2;
            fB2[4] = fB[4] - fDMF1/fFMUF;
//            fM2 = fB2[0]+fB2[1]+fB2[2]+fB2[3]+fB2[4];
            fM2 = fB2[0]+fB2[1]+fB2[2]+fB2[3];

            fT2 = fBarToPa*fNewP[iI+1]*fV2/fRMOL/fM2;
            ftemp = fFFFai[iI + 1];
            if(ftemp > -0.5)
            {
                ftemp = ftemp;
            }

//计算热损失
            fXLM = (fX1 + fX2)/2.0;
            fT   = (fT1 + fT2)/2.0;

            fAREA[0] = PI*fDiameter*fXLM;                      //气缸套面积
            fAREA[1] = PI*fDiameter*fDiameter / 4.0;             //活塞顶部面积
            fAREA[2] = PI*fDiameter*fDiameter / 4.0 + PI*fXH*fDiameter;  //气缸顶部的当量面积

            fPQ = fNewP[iI+1]*fBarToPa;
            fDQ = CalculateFDQ(fPQ,fT,fXLM);  //57.296;
//            fDQ = CalculateFDQ(fPQ,fT,fXLM);
            fQW2 = fQW1 + fDQ*fH;             //fH为计算步长
//计算　Q，DQ/DCA　和X
            fE2 = CalculateTENB(fT2,fB2);
//20040602调试
            fQF2 = fE2 - fE1 + fQW2 + fW2;    //fQF2是此步长内的放热量

//            fHeatRate = fE2 - fE0 + fDQ*fH + fDW;
            fDMF2 = fQF2/fHU;                //计算出来的这一步长内的喷油量
            fDQRCA = (fQF2 - fQF1)/fH;       //fDQRCA 为放热率
            ftemp = fabs(fDMF1 - fDMF2)/fDGF;
            fDMF1 = fDMF2;
            iIterNum ++;
        }while( (ftemp > 0.00001)&&(iIterNum<20));
        strTemp.printf("%d %.4f",iI,fFFFai[iI]);
//        FormMain->MemoITInfo->Lines->Add(strTemp);

        if(fabs(fFFFai[iI]+0.0) <1.0)
        {
            fFFFai[iI] = fFFFai[iI];
        }

        if(fDQMAX - fDQRCA<0.0)
        {
            fDQMAX = fDQRCA;
            fDQMMAX = fDQMAX*2.39e-4;
            fCADQMAX = fCA;
        }
        if(fabs(fDQRCA)>1000000.0)
        {
            fDQRCA = 0.0;
        }

//        Fuel_burn[iI] = fDQRCA / fHU;  //燃油消耗率

        fCDHDF[iI]    = fQF2 ;
        fDHDF[iI]     = fDQRCA;

        farDW[iI]     = fDW/fH;
        farW[iI]      = fW2;

        farQW[iI]     = fQW2;
        farDQW[iI]    = fDQ;

        farQE[iI]     = fE2;
        farDQE[iI]    = (fE2 - fE0)/fH;
/*
//------------------------------------------------------------------------- 20050326
        #ifdef SELF_DEBUG
            fprintf(fpp, "%.2f %.4f %.1f %.1f %.1f %.1f %.1f %.6f\n",
                                                       fFFFai[iI],
                                                       fNewP[iI],
                                                       fT,
                                                       fDHDF[iI],
                                                       farDW[iI],
                                                       farDQW[iI],
                                                       farDQE[iI],
                                                       Fuel_burn[iI]);
        #endif
//=============================================================================
*/
//        fP2 = fBarToPa*fNewP[iI+1];
        fX = fDMF2/fDGF;
        fQF1 = fQF2;
        fTT[iI+1] = fT2;
        iI = iI +1;
        fX1 =fX2;
        fW1 = fW2;
        fQW1 = fQW2;
        fT1 = fT2;
        fV1 = fV2;
//        fE0 = fE2;
//        fE1 = fE2;
        fCY = fCY + 1.0;
        fDPRCA = fDPRCA*1.02e-5;
        iJK = iJK +1;
        if(fT > 3000.0)
        {
            break;
        }
      }while( fCA <fFFFai[icEndPosi]);
    }
    __finally
    {
/*
        #ifdef SELF_DEBUG
        fclose(fpp);
        #endif
*/
    }
    iEndFai = iI;
}

void __fastcall lDieselHRBP::OnlyPressCalc(void)
{
    //TODO: Add your source code here
	double fFP;           //气缸压力
    double fDP = 0.0;     //气缸压力变化率,压缩前认为是零
    double fT;            //气缸温度
    double fDT = 0.0;     //气缸温度变化率,压缩前认为是零
    double fFai ;         //上止点后50度进气门关闭,开始压缩时的上止点时fFai为360度曲轴转角
                          //计算步长为0.5度曲轴转角
    double fEndFai;
    double y[6];
    double fPmax,fTmax;
/*
    fEn = StrToFloat(EditSpeed->Text);
    fP = StrToFloat(EditPAir->Text)*100000.0; //将缸内压力初始为进气压力
    fT = 273.15+StrToFloat(EditTAir->Text); //将缸内温度初始为进气温度
    fFai = 180.0+StrToFloat(EditInCloseAngle->Text);
    fEndFai = 540.0 - StrToFloat(EditOutOpenAngle->Text);
    fDFai = StrToFloat(EditDFai->Text);
    fKConst = StrToFloat(EditMIndex->Text);
    fKCoef  = StrToFloat(EditKCoef->Text);
    fCRation = StrToFloat(EditCRatio->Text);
    fC = 1.0/(fCRatio - 1.0);
    fLMDa = StrToFloat(EditSLength->Text)/StrToFloat(EditPodLength->Text);
    fStroke = StrToFloat(EditSLength->Text)/1000.0;
    fDiameter = StrToFloat(EditDiameter->Text)/1000.0;
    fHRConst = StrToFloat(EditHRConst->Text);
    fAverSpeed = fEn/30.0*fStroke;
    fLCoef = StrToFloat(EditLCoef->Text);
    fTw = 273.15 + StrToFloat(EditTTop->Text);
*/
    fA = 1.0;  //暂定为1.0，主要是热功当量？？？？？？？？
    fR = 287.1; // kJ/(kg.K)  空气的R
//气缸内空气质量
    GetVolumn(fFai,fV);
    fG =fFP*fV/(fR*fT);
	y[0]=fFP;		//气缸压力
	y[1]=fT;		//气缸温度
    y[2] = 0.0;     //气缸压力变化率
    y[3] = 0.0;     //气缸温度变化率
    fPmax = fFP;
    fTmax = fT;
/*
    Chart3->Series[0]->Clear();
    Chart4->Series[0]->Clear();
    Chart5->Series[0]->Clear();
    Chart3->BottomAxis->Title->Caption = "曲轴转角 /CA";
    Chart4->BottomAxis->Title->Caption = "曲轴转角 /CA";
    Chart5->BottomAxis->Title->Caption = "曲轴转角 /CA";

    Chart3->LeftAxis->Title->Caption = "气缸容积 /L";
    Chart4->LeftAxis->Title->Caption = "气缸压力 /bar";
    Chart5->LeftAxis->Title->Caption = "气缸温度 /C";

    Chart3->LeftAxis->AutomaticMinimum = false;
    Chart3->LeftAxis->Minimum = 0.0;

    Chart4->LeftAxis->AutomaticMinimum = false;
    Chart4->LeftAxis->Minimum = 0.0;

    Chart5->LeftAxis->AutomaticMinimum = false;
    Chart5->LeftAxis->Minimum = 0.0;
*/
	do
	{
        OnlyPress(2,y,fFai,fDFai);
//        Chart3->Series[0]->AddXY(fFai,fV*1000.0,"",clBlack);
//        Chart4->Series[0]->AddXY(fFai,y[0]/100000.0,"",clBlack);
//        Chart5->Series[0]->AddXY(fFai,y[1]-273.15,"",clBlack);
        if(y[0]>fPmax) fPmax = y[0];
        if(y[1]>fTmax) fTmax = y[1];
        fFai = fFai + fDFai;
	}while(fFai<fEndFai);
//    strtt.printf("压力最大值是%.2f bar",fPmax/100000.0);
//    Chart4->Title->Text->Strings[0]= strtt;
//    strtt.printf("温度最大值是%.2f 度",fTmax-273.15);
//    Chart5->Title->Text->Strings[0]= strtt;
//    Application->MessageBox("纯压缩仿真计算过程结束!","提示",MB_OK|MB_ICONINFORMATION);
}

void __fastcall lDieselHRBP::OnlyPress(int n, double * yy, double fai, double dfai)
{	//出油阀在运动中，但出油阀腔尚未被打开
	int i,j;
	double u[5],ymm[6],yf[6],yw[6],tempt,dtempt,x,dx,q1,q2,dt,dtt;
	u[0]=0.5*dfai;
	u[1]=u[0];
	u[4]=u[0];
	u[2]=dfai;
	u[3]=u[2];
	tempt=fai;
	dtempt=u[0];
	q1=yy[5];
	dtt=fDFai/6.0/fEn;
    yf[0] = yy[2];
    yf[1] = yy[3];
	for(i=0;i<n;i++)
	{
		ymm[i]=yy[i];
		yw[i]=yy[i];
	}
	for(j=0;j<4;j++)
	{
        OnlyPressFun(n,ymm,yf,tempt,dtempt);
		for(i=0;i<n;i++)
		{
			ymm[i]=yw[i]+u[j]*yf[i];
			yy[i]=yy[i]+u[j+1]*yf[i]/3.0;
		}
    }
}

void __fastcall lDieselHRBP::OnlyPressFun(int l, double * yy, double * f,
					double fai,double dfai)
{
    // yy 参数说明     yy[0]: fp,   yy[1]: ft,
    // f               f[0]: dpdf,  f[1]: dtdf
//    double fp,ft;
    double fa,fb;
    double fnfai,fsin;
    double fRArea;             //燃烧室散热面积
    double fHRCoef;            //传热系数
    double fFFai;              //比热中间变量
    double fFv;                //泄漏面积
    double fDGDF;              //漏气变化率
    double fDQDF;              //向冷却介质的传热率
//    double fDPDF;              //压力变化率
//    double fDTDF;              //温度变化率
    double fv;
    double ftemp;
    double fST;
    double fDV;
    fK = fKConst + yy[1]*fKCoef;
    fnfai = PI*fai/180.0;
    fsin = fLMDa*fLMDa*sin(fnfai)*sin(fnfai);
    fa = 1.0 - cos(fnfai)+ (1.0/fLMDa)*(1.0 - sqrt(1.0 - fsin));
    fb = sin(fnfai)+fLMDa/2.0*sin(2.0*fnfai)/sqrt(1.0-fsin);
    fRArea = PI*fDiameter*(fStroke*(2.0*fC+fa)+fDiameter)/2.0;
    ftemp = PI/180.0*fai;
    fST = sin(ftemp);
    fV = PI*fDiameter*fDiameter/4.0*(fStroke/(fCRatio-1.0)+fStroke/2.0*((1.0+1.0/fLMDa)-cos(ftemp)-1.0/fLMDa*sqrt(1.0-fLMDa*fLMDa*fST*fST) ));
    fDV = PI*PI*fDiameter*fDiameter*fStroke/(8.0*180.0)*(fST+fLMDa/2.0*sin(2.0*ftemp)/sqrt(1.0-fLMDa*fLMDa*fST*fST));
//    fV = PI*fDiameter*fDiameter*(fStroke/(fEE-1.0)+fStroke/2.0*((1.0+1.0/fLMDa)-cos(fnfai)-1.0/fLMDa*sqrt(1.0-fLMDa*fLMDa*fsin*fsin)));
//    fDV = PI*PI*fDiameter*fDiameter*fStroke/(8.0*180.0)*(fST+fLMDa/2.0*sin(2.0*ftemp)/sqrt(1.0-fLT*fLT*fST*fST));
    fv = fV;
    fFFai = pow(2.0/(fK+1.0),1.0/(fK-1.0))*sqrt(fK/(fK+1.0));

    fFv = fLCoef*fDiameter;
    if(f[1]<0)
    {
        fai = fai;
    }

    if(bAbsolute)  //绝热过程
    {
        fDGDF = 0.0;
        fDQDF = 0.0;
    }
    else    //考虑散热及漏气损失
    {

        fHRCoef = fHRConst*pow(fDiameter,-0.214)*pow(yy[1],-0.525)*pow(fAverSpeed*yy[0],0.7865);
        fDGDF = fFv*fFFai*yy[0]*sqrt(2.0*fGG/(fR*yy[1]))/(6.0*fEn);
        fDQDF = fHRCoef*fRArea*(fTw-yy[1])/(6.0*fEn);
    }
//压力变化率 f[0]
//      f[0] = -fK*PI/180.0*fb/(2.0*fC+fa)*yy[0] + (fK-1.0)/(6.0*fA*fEn*fv)*(fDGDF*6.0*fEn-fDQDF*6.0*fEn);
      f[0] = -fK*PI/180.0*fb/(2.0*fC+fa)*yy[0] + (fK-1.0)/(6.0*fA*fEn*fv)*(fDQDF*6.0*fEn);
//    f[0] = -fK*yy[0]*fDV/fV + (fK-1.0)/(6.0*fA*fEn*fv)*(fDGDF*6.0*fEn-fDQDF*6.0*fEn);
// 温度变化率 f[1]
//    f[1] = yy[1]/yy[0]*f[0]+yy[1]*PI/180.0*fb/(2.0*fC+fa)+yy[1]/fG*fDGDF;
      f[1] = yy[1]/yy[0]*f[0] + yy[1]/fV*fDV; //- yy[1]/fG*fDGDF;
}
__fastcall lCPressure::lCPressure(void)
{
    fNewP = NULL;
    fFFFai = NULL;
    fLowPressure = 1.0;
}

__fastcall lCPressure::~lCPressure(void)
{
    if(fNewP != NULL)
    {
        delete []fNewP;
    }
    if(fFFFai != NULL)
    {
        delete [] fFFFai;
    }
}

bool __fastcall lCPressure::GetRealPressure(char *strfilename)
{
    //TODO: Add your source code here
/*
    String strExeFileName=::ParamStr(0);
    String strNowPath=::ExtractFilePath(strExeFileName);
    strNowPath +="rp01.dat";
*/
    float ftemp1,ftemp2;
    int inum=0;
    FILE * fp;
    char str[100];
    if((fp=fopen(strfilename,"r")) == NULL)
    {
//        Application->MessageBox("文件打开错误!","提示",MB_OK|MB_ICONINFORMATION);
        return false;
    }
    while(fgets(str,100,fp)!=NULL)
    {
        inum ++;
    }
    fseek(fp,0l,SEEK_SET);
    if(fNewP != NULL)
    {
        delete [] fNewP;
        fNewP = NULL;
    }
    fNewP = NULL;
    fNewP = new float[inum];
    if(fNewP == NULL)
    {
        fclose(fp);
        return false;
    }
    if(fFFFai != NULL)
    {
        delete [] fFFFai;
        fFFFai = NULL;
    }
    fFFFai = new float[inum];
    if(fFFFai == NULL)
    {
        fclose(fp);
        return false;
    }
    for(int i=0;i<inum;i++)
    {
        fscanf(fp,"%f\t\%f\n",&ftemp1,&ftemp2);
//        fNewP[i] =  ftemp2 + fLowPressure;
        fNewP[i] = ftemp2;
        fFFFai[i] = ftemp1;
    }
    iPLength = inum;
    fclose(fp);
    float ftemp;
    int iposi;
    ftemp = fNewP[0];
    iposi = 0;
    for(int i=1; i<iPLength; i++)
    {
        if(ftemp > fNewP[i])
        {
            ftemp = fNewP[i];
            iposi = i;
        }
    }
    if(iposi> 4)
    {
        ftemp = 0.0;
        for(int i = iposi-3; i<=iposi+3; i++)
        {
            ftemp += fNewP[i];
        }
    }
    else
    {
        ftemp = 0.0;
        for(int i = 0; i<7; i++)
        {
            ftemp += fNewP[i];
        }
    }
    ftemp /= 7.0;
//    ftemp = fPAir - ftemp;
    for(int i=0; i<iPLength; i++)
    {
        fNewP[i] += ftemp;
    }
    return true;
}


void __fastcall lCPressure::SmoothCurve(float &fp,int iposi)
{
    //TODO: Add your source code here
    //此函数用于计算压力曲线的光顺值  是七点光顺方法
    //输入为待求数据的位置 iposi
    // fp 为计算后的压力值
    float ftemp;
    if(iposi == 0)  //如果是第一个采样点
    {
         ftemp =(39.0*fNewP[0] + 8.0*fNewP[1] - 4.0*fNewP[2] - 4.0*fNewP[3]
                 +fNewP[4] + 4.0*fNewP[5] - 2.0*fNewP[6])/42.0;
    }
    else if(iposi == 1)
    {
         ftemp =(8.0*fNewP[0] + 19.0*fNewP[1] + 16.0*fNewP[2] + 6.0*fNewP[3]
                 +4.0*fNewP[4] - 7.0*fNewP[5] + 4.0*fNewP[6])/42.0;
    }
    else if(iposi == 2)
    {
         ftemp =(-4.0*fNewP[0] + 16.0*fNewP[1] + 19.0*fNewP[2] + 12.0*fNewP[3]
                 +2.0*fNewP[4] - 4.0*fNewP[5] + fNewP[6])/42.0;
    }
    else if(iposi == iPLength -3)
    {
        ftemp = ( fNewP[iPLength-7] -4.0*fNewP[iPLength-6] +2.0*fNewP[iPLength-5]
                 +12.0*fNewP[iPLength-4] +19.0*fNewP[iPLength -3] +16.0*fNewP[iPLength-2]
                 -4.0*fNewP[iPLength-1])/42.0;
    }
    else if(iposi == iPLength -2)
    {
        ftemp = (  4.0*fNewP[iPLength-7] - 7.0*fNewP[iPLength-6]   - 4.0*fNewP[iPLength-5]
                 + 6.0*fNewP[iPLength-4] + 16.0*fNewP[iPLength -3] + 19.0*fNewP[iPLength-2]
                 + 8.0*fNewP[iPLength-1])/42.0;
    }
    else if(iposi == iPLength -1)
    {
        ftemp = ( -2.0*fNewP[iPLength-7] +4.0*fNewP[iPLength-6] +fNewP[iPLength-5]
                  -4.0*fNewP[iPLength-4] -4.0*fNewP[iPLength -3] +8.0*fNewP[iPLength-2]
                 +39.0*fNewP[iPLength-1])/42.0;
    }
    else
    {
        ftemp = (-2.0*(fNewP[iposi-3]+fNewP[iposi+3])+3.0*(fNewP[iposi-2]+fNewP[iposi+2])
                 +6.0*(fNewP[iposi-1]+fNewP[iposi+1])+7.0*fNewP[iposi])/21.0;
    }
    fp = ftemp;
}

void __fastcall lDieselHRBP::ProcessPressure(int iMethod)
{
    //TODO: Add your source code here
    float ftemp;
    if(iMethod == 0) //不处理
    {
        for(int i=0;i<iPLength;i++)
        {
            fNewP[i] = fOldP[i];
        }
    }
    else if(iMethod == 1)
    {
        for(int i=0;i<iPLength;i++)
        {
            SmoothCurve(ftemp,i);
            fNewP[i] = ftemp;
        }
    }
    else if(iMethod == 2)  //三点叠加平均
    {
        float *fTArray =NULL;
        fTArray = new float[iPLength];
        if(fTArray == NULL)
        {
            return;
        }
        float fsum;
        for(int i=0;i<iPLength;i++)
        {
            fNewP[i] = fOldP[i];
        }
        for(int j=0;j<iIteration;j++)
        {
            for(int i=0;i<iPLength;i++)
            {
                fTArray[i] = fNewP[i];
            }
            for(int i=1;i<iPLength-1;i++)
            {
                fNewP[i] = (fTArray[i-1]+4.0*fTArray[i]+fTArray[i+1])/6.0;
            }
        }
        delete []fTArray;
    }
    GetMinMax(fNewP,iPLength,fCPMin,fCPMax,fPMaxFai,true);
}

void __fastcall lDieselHRBP::ZYFHeatRelease(void)
{
    //TODO: Add your source code here
    //使用张延峰提供的放热率计算程序
    float qb=0,gg,pc,x1,bb,Rg,xxxx,df,v1,fx,fx2,FJL[]={0.5,0.5,1.0,1.0,0.5};
	float p2,p1,dW,gl,t1,t2,c1,dg,caid,v2,gm,g,c2,tm,dqw,ai,gfe;//,p2p;
    float Area,fv;
    float resir;
    float af0;
    float gf;
    float qw;
    float W;
//----------------------没有定义的变量，请注意它的初始值.
    float rc;
//    float eps;
    float g0;
    float af;
    float fni;
    float rpm;
    float fXLM;
    float pm;
    float Hu;
    float bc;
    float pe;
    float fne = 150.0;   //柴油机的输出功率 ?????
    float cc = 1.0;
    float pj;

    float eta_m;  //机械效率

    float f3;
    float fXH = 0.0; //先假设活塞在上止点时，活塞顶部距气缸盖平面的距离
    float fwt[3];
    float fAA[3];
//-------------------
    DetectCPosi();
    rc = fStroke;  //柴油机行程
    rpm = fEn;
    Hu = fHU;
    bc = 1000.0;
    fwt[0] = 550.0;
    fwt[1] = 560.0;
    fwt[2] = 400.0;   //tw1=550.;tw2=560.;tw3=400.;

//                fAREA[0] = PI*fDiameter*fXLM;                      //气缸套面积
//            fAREA[1] = PI*fDiameter*fDiameter/4.0;             //活塞顶部面积
//            fAREA[2] = PI*fDiameter*fDiameter/4.0+PI*fXH*fDiameter;  //气缸顶部的当量面积

//    fAA[0] = PI*fDiameter*fXLM;
    fAA[1] = PI*fDiameter*fDiameter/4.0;
    fAA[2] = PI*fDiameter*fDiameter/4.0+PI*fXH*fDiameter;

//-----------------------
	int i,k,ica,kk;
    resir = fGAMA;
    float pp = 1000000.0;   //输入数据的单位是MPa  1bar = 0.1MPa
	gf=0.0;
	qw=0.0;
	W=0.0;
	gg=0.0;
	ica=0;
    Area = PI*fDiameter/4.0;
	for(i=0;i < iPLength; i++)
    {
        fDHDF[i] = 0.0;
        fTT[i] = fT0;
    }
	for(i=0;i < iPLength; i++)     //此处用查找上止点，上止点处的曲轴转角为 0
    {
        if(fFFFai[i] >= fInCloseAngle)  //找到进气门关闭时的曲轴转角
        {
             ica=i;
             break;
        }
    }
	pc = pp*fNewP[ica];                  //将输入的气缸压力转换为pa
//	x1 = 2.0*rc/(eps-1.0);               //计算进气门刚刚关闭此时的活塞位置
    x1 = GetfX( ica );
	bb = fFFFai[ica];                    //此时的曲轴转角,单位是弧度

	Rg = fRa*(1.0 - fGAMA) + fRb*fGAMA;  //新鲜空气与废气的混合气体常数
    fv = GetVolumn(fFFFai[ica],fv);      //计算进气门刚关闭时的气缸容积
	g0 = fv*pc/fTAir/Rg;                 //计算开始时的气体质量

	af0 = g0/fFLTH/fgf0*1000.0;          //理论燃油量
	df = fFFFai[1]-fFFFai[0];

	bb = fFFFai[0];

	v1 = GetVolumn(bb,v1);

//	fx = PI*D*(xn(bb)+x1-delx);
    fx = PI*fDiameter*GetfX(bb);       //气缸侧壁的面积

	fx2 = fx;
/*
	p1 = pp*fNewP[0];
	t1 = p1*v1/g0/Rg;
    fTT[ica] = t1;
	t2 = t1;
*/
    t1 = fTAir;
    t2 = fTAir;
    fTT[ica] = t1;

	c1 = Cva(t1)*(1.0-resir-gg)+Cvb(t1)*(resir+gg);

	dg=0.0;

	for(i=icStartPosi;i<icEndPosi;i++)
	{
		df = fFFFai[i+1] - fFFFai[i];
		caid = fFFFai[i+1];
		v2 = GetVolumn(caid,v2);
        // Area*(xn(bb)+x1);
		fx = PI*fDiameter*GetfX(caid);

		p2=pp*fNewP[i+1];

		pm=0.5*(p1+p2);

		dW=pm*(v2-v1);

		W=W+dW;

		gl=gf;

		kk=4;

		if((caid<-20.0)||(caid>130.0)) kk=1;

		for(k=0;k<kk;k++)
		{
        	if(caid>=130.0) dg = 0.0;

			if(caid<=-20.0) dg = 0.0;

			gm = gl + FJL[k]*dg;

			gf += FJL[k+1]*dg/3.0;

			if(gf<0.0)
            {
                gf=0.0;
            }

			g=g0+gm;

			gg=gm*(fFLTH+1.0)/g;

			Rg = fRa*(1.0-resir-gg) + fRb*(resir+gg);

			t2=p2*v2/g/Rg;

			c2=Cva(t2)*(1.0-resir-gg)+Cvb(t2)*(resir+gg);

			f3=0.5*(fx+fx2);
      //      fXLM =(fX1+fX2)/2.0;
            fAA[0] = PI*fDiameter*fXLM;  //活塞侧壁面面积
			tm=0.5*(t1+t2);

            fPpm = p2;

			dqw=dqwc(tm,fAA,fwt);

			ai=dqw+g*(c2*t2-c1*t1)+dW;

			if(caid>-20.0) dg=ai/Hu/bc;
		}
		dg = gf-gl;

		qb=gf*Hu*bc;

		g=g0+gf;

		gg=gf*(fFLTH+1.0)/g;

		Rg = fRa*(1.0-resir-gg) + fRb*(resir+gg);

		t1=p2*v2/g/Rg;
        fTT[i] = t1;
		qw=qw+dqw;
//      fDHDF[iI] = fDQRCA;
		fDHDF[i] = ai/df;   //放热率
		fAQ[i] = dqw/df;   //散热率
        farDW[i] = dW;
        farW[i] = W;
        farQW[i] = qw;
        farDQW[i] = fAQ[i];
//        farQE[i] = fE2;
//        farDQE[i] = (fE2 - fE0)/fH;

		fTT[i] = t1;       //气缸温率

		fQL[i] = qb;         //

		Fuel_burn[i] = gf;  //燃油消耗率

		p1=p2;

		v1=v2;

		c1=c2;

		fx2=fx;

	}
	if(gf!=.0)
    {
        af=g0/gf/fFLTH;
    }
	fni = rpm/fStroke/3.0e4*W;
	pe = fStroke/rpm*3.0e4*fne/Area/rc/2.0/pp/cc;
	pj = fStroke/rpm*3.0e4*fni/Area/rc/2.0/pp;
	eta_m = fne/fni/cc;
}


bool __fastcall lDieselHRBP::AllocateMemory(int inum)
{
    //TODO: Add your source code here
    inum +=10;
    if(fpOilP == NULL)
    {
        fpOilP = new float[inum];
        if(fpOilP == NULL)
        {
            return false;
        }
    }
 //-----------------------------
    if(fDHDF == NULL)
    {
        fDHDF = new float[inum];
        if(fDHDF == NULL)
        {
            return false;
        }
    }
//------------------------------------
    if(fCDHDF == NULL)
    {
        fCDHDF = new float[inum];
        if(fCDHDF == NULL)
        {
            return false;
        }
    }
//------------------------------------
    if(fNewP == NULL)
    {
        fNewP = new float[inum];
        if(fNewP == NULL)
        {
            return false;
        }
    }
//------------------------------------

    if(fOldP == NULL)
    {
        fOldP = new float[inum];
        if(fOldP == NULL)
        {
            return false;
        }
    }
//-------------------------------------
    if(fFFFai == NULL)
    {
        fFFFai = new float[inum];
        if(fFFFai == NULL)
        {
            return false;
        }
    }
//    float *fQL;
//    float *Fuel_burn;             //燃油消耗率
//    float *fAQ;                   //散热率
//    float *fTT;                   //缸内气体温度

    if(fQL == NULL)
    {
        fQL = new float[inum];
        if(fQL == NULL)
        {
            return false;
        }
    }

    if(Fuel_burn == NULL)
    {
        Fuel_burn = new float[inum];
        if(Fuel_burn == NULL)
        {
            return false;
        }
    }

    if(fAQ == NULL)
    {
        fAQ = new float[inum];
        if(fAQ == NULL)
        {
            return false;
        }
    }

    if(fTT == NULL)
    {
        fTT = new float[inum];
        if(fTT == NULL)
        {
            return false;
        }
    }
//--------------------------------------
//    float *farDVDF;                 //容积变化规律
    if(farDVDF == NULL)
    {
        farDVDF = new float[inum];
        if(farDVDF == NULL)
        {
            return false;
        }
    }

//    float *farDPDF;                 //压力升高率
   if(farDPDF == NULL)
    {
        farDPDF = new float[inum];
        if(farDPDF == NULL)
        {
            return false;
        }
    }
//    float *farV;                    //气缸容积
   if(farV == NULL)
    {
        farV = new float[inum];
        if(farV == NULL)
        {
            return false;
        }
    }
//    float *farLogP;                 //气缸压力对数值
   if(farLogP == NULL)
    {
        farLogP = new float[inum];
        if(farLogP == NULL)
        {
            return false;
        }
    }
//   float *farLogV;                 //气缸容积对数值
   if(farLogV == NULL)
    {
        farLogV = new float[inum];
        if(farLogV == NULL)
        {
            return false;
        }
    }
//    float *farFFTPr;                //压力FFT的实部
   if(farFFTPr == NULL)
    {
        farFFTPr = new float[2048];
        if(farFFTPr == NULL)
        {
            return false;
        }
    }
//    float *farFFTPi;                //压力FFT的虚部
    if(farFFTPi == NULL)
    {
        farFFTPi = new float[2048];
        if(farFFTPi == NULL)
        {
            return false;
        }
    }
//    float *farW;                    //所作的功
//    float *farDW;                   //瞬时功
    if(farW == NULL)
    {
        farW = new float[inum];
        if( farW == NULL)
        {
            return false;
        }
    }

    if(farDW == NULL)
    {
        farDW = new float[inum];
        if( farDW == NULL)
        {
            return false;
        }
    }
//    float *farQW;                   //散热量
    if(farQW == NULL)
    {
        farQW = new float[inum];
        if( farQW == NULL)
        {
            return false;
        }
    }

//    float *farDQW;                  //瞬时散热量
    if(farDQW == NULL)
    {
        farDQW = new float[inum];
        if( farDQW == NULL)
        {
            return false;
        }
    }

//    float *farQA;                   //总放热率
    if(farQA == NULL)
    {
        farQA = new float[inum];
        if( farQA == NULL)
        {
            return false;
        }
    }

//    float *farDQA;                  //瞬时放热率
    if(farDQA == NULL)
    {
        farDQA = new float[inum];
        if( farDQA == NULL)
        {
            return false;
        }
    }

//    float *farQE;                   //内能+功
    if(farQE == NULL)
    {
        farQE = new float[inum];
        if( farQE == NULL)
        {
            return false;
        }
    }

//    float *farDQE;                  //瞬时 内能+功
    if(farDQE == NULL)
    {
        farDQE = new float[inum];
        if( farDQE == NULL)
        {
            return false;
        }
    }
//分配累加数据空间
//----------------------------------------
    for(int i=0; i<PASSAGENUM; i++)
    {
        if(siConvertBuffer[i] == NULL)
        {
            siConvertBuffer[i] = new short int[inum];
            if(siConvertBuffer[i] == NULL)
            {
                return false;
            }
        }
    }


    for(int i=0;i<inum;i++)
    {
        fDHDF[i] = 0.0;
        fCDHDF[i] = 0.0;
        fQL[i] = 0.0;
        fAQ[i] = 0.0;
        Fuel_burn[i] = 0.0;
        farW[i] = 0.0;
        farDW[i] = 0.0;
    }
/*
    if(fpOilP != NULL)
    {
        delete[] fpOilP;
        fpOilP = NULL;
    }
    fpOilP = new float[inum];
    if(fpOilP == NULL)
    {
        return false;
    }
 //-----------------------------
    if(fDHDF != NULL)
    {
        delete []fDHDF;
        fDHDF = NULL;
    }
    fDHDF = new float[inum];
    if(fDHDF == NULL)
    {
        return false;
    }
//------------------------------------
    if(fCDHDF != NULL)
    {
        delete []fCDHDF;
        fCDHDF = NULL;
    }
    fCDHDF = new float[inum];
    if(fCDHDF == NULL)
    {
        return false;
    }
//------------------------------------
    if(fNewP != NULL)
    {
        delete []fNewP;
        fNewP = NULL;
    }

    fNewP = new float[inum];
    if(fNewP == NULL)
    {
        return false;
    }
//------------------------------------

    if(fOldP != NULL)
    {
        delete []fOldP;
        fOldP = NULL;
    }

    fOldP = new float[inum];
    if(fOldP == NULL)
    {
        return false;
    }
//-------------------------------------
    if(fFFFai !=NULL)
    {
        delete [] fFFFai;
        fFFFai = NULL;
    }
    fFFFai = new float[inum];
    if(fFFFai == NULL)
    {
        return false;
    }
//    float *fQL;
//    float *Fuel_burn;             //燃油消耗率
//    float *fAQ;                   //散热率
//    float *fTT;                   //缸内气体温度

    if(fQL !=NULL)
    {
        delete [] fQL;
        fQL = NULL;
    }
    fQL = new float[inum];
    if(fQL == NULL)
    {
        return false;
    }

    if(Fuel_burn !=NULL)
    {
        delete [] Fuel_burn;
        Fuel_burn = NULL;
    }
    Fuel_burn = new float[inum];
    if(Fuel_burn == NULL)
    {
        return false;
    }

    if(fAQ !=NULL)
    {
        delete [] fAQ;
        fAQ = NULL;
    }
    fAQ = new float[inum];
    if(fAQ == NULL)
    {
        return false;
    }

    if(fTT !=NULL)
    {
        delete [] fTT;
        fTT = NULL;
    }
    fTT = new float[inum];
    if(fTT == NULL)
    {
        return false;
    }
//--------------------------------------
//    float *farDVDF;                 //容积变化规律
    if(farDVDF !=NULL)
    {
        delete [] farDVDF;
        farDVDF = NULL;
    }
    farDVDF = new float[inum];
    if(farDVDF == NULL)
    {
        return false;
    }

//    float *farDPDF;                 //压力升高率
   if(farDPDF !=NULL)
    {
        delete [] farDPDF;
        farDPDF = NULL;
    }
    farDPDF = new float[inum];
    if(farDPDF == NULL)
    {
        return false;
    }
//    float *farV;                    //气缸容积
   if(farV !=NULL)
    {
        delete [] farV;
        farV = NULL;
    }
    farV = new float[inum];
    if(farV == NULL)
    {
        return false;
    }
//    float *farLogP;                 //气缸压力对数值
   if(farLogP !=NULL)
    {
        delete [] farLogP;
        farLogP = NULL;
    }
    farLogP = new float[inum];
    if(farLogP == NULL)
    {
        return false;
    }
//   float *farLogV;                 //气缸容积对数值
   if(farLogV !=NULL)
    {
        delete [] farLogV;
        farLogV = NULL;
    }
    farLogV = new float[inum];
    if(farLogV == NULL)
    {
        return false;
    }
//    float *farFFTPr;                //压力FFT的实部
   if(farFFTPr !=NULL)
    {
        delete [] farFFTPr;
        farFFTPr = NULL;
    }
    farFFTPr = new float[2048];
    if(farFFTPr == NULL)
    {
        return false;
    }
//    float *farFFTPi;                //压力FFT的虚部
    if(farFFTPi !=NULL)
    {
        delete [] farFFTPi;
        farFFTPi = NULL;
    }
    farFFTPi = new float[2048];
    if(farFFTPi == NULL)
    {
        return false;
    }
//    float *farW;                    //所作的功
//    float *farDW;                   //瞬时功
    if(farW != NULL)
    {
        delete []farW;
        farW = NULL;
    }
    farW = new float[inum];
    if( farW == NULL)
    {
        return false;
    }

    if(farDW != NULL)
    {
        delete []farDW;
        farDW = NULL;
    }
    farDW = new float[inum];
    if( farDW == NULL)
    {
        return false;
    }
//    float *farQW;                   //散热量
    if(farQW != NULL)
    {
        delete []farQW;
        farQW = NULL;
    }
    farQW = new float[inum];
    if( farQW == NULL)
    {
        return false;
    }

//    float *farDQW;                  //瞬时散热量
    if(farDQW != NULL)
    {
        delete []farDQW;
        farDQW = NULL;
    }
    farDQW = new float[inum];
    if( farDQW == NULL)
    {
        return false;
    }

//    float *farQA;                   //总放热率
    if(farQA != NULL)
    {
        delete []farQA;
        farQA = NULL;
    }
    farQA = new float[inum];
    if( farQA == NULL)
    {
        return false;
    }

//    float *farDQA;                  //瞬时放热率
    if(farDQA != NULL)
    {
        delete []farDQA;
        farDQA = NULL;
    }
    farDQA = new float[inum];
    if( farDQA == NULL)
    {
        return false;
    }

//    float *farQE;                   //内能+功
    if(farQE != NULL)
    {
        delete []farQE;
        farQE = NULL;
    }
    farQE = new float[inum];
    if( farQE == NULL)
    {
        return false;
    }

//    float *farDQE;                  //瞬时 内能+功
    if(farDQE != NULL)
    {
        delete []farDQE;
        farDQE = NULL;
    }
    farDQE = new float[inum];
    if( farDQE == NULL)
    {
        return false;
    }
//分配累加数据空间
//----------------------------------------
    for(int i=0; i<PASSAGENUM; i++)
    {
        if(siConvertBuffer[i] != NULL)
        {
            delete [] siConvertBuffer[i];
            siConvertBuffer[i] = NULL;
        }
        siConvertBuffer[i] = new short int[3600];
        if(siConvertBuffer[i] == NULL)
        {
            return false;
        }
    }


    for(int i=0;i<inum;i++)
    {
        fDHDF[i] = 0.0;
        fCDHDF[i] = 0.0;
        fQL[i] = 0.0;
        fAQ[i] = 0.0;
        Fuel_burn[i] = 0.0;
        farW[i] = 0.0;
        farDW[i] = 0.0;
    }
*/

    return true;
}
bool __fastcall lDieselHRBP::Allocate3DMemory(void)
{
    //TODO: Add your source code here
    if(f3DData != NULL)
    {
        for(int i=0;i<16;i++)
        {
            if(f3DData[i] != NULL)
            {
                delete []f3DData[i];
            }
        }
        if(f3DData != NULL)
        {
            delete []f3DData;
        }
    }
    f3DData = new float * [16];
    for(int i = 0; i < 16; i++)
    {
        f3DData[i] = new float[iCurveDataLength];
        if(f3DData[i] == NULL)
        {
            return false;
        }
    }
    return true;
}

void __fastcall lDieselHRBP::DeleteMemory(void)
{
    //TODO: Add your source code here
    if(fpOilP != NULL)
    {
        delete[] fpOilP;
        fpOilP = NULL;
    }
    if(fNewP != NULL)
    {
        delete []fNewP;
        fNewP = NULL;
    }
    if(fFFFai != NULL)
    {
        delete []fFFFai;
        fFFFai = NULL;
    }
    if(fDHDF != NULL)
    {
        delete []fDHDF;
        fDHDF = NULL;
    }
    if(fCDHDF != NULL)
    {
        delete []fCDHDF;
        fCDHDF = NULL;
    }
    if(fOldP != NULL)
    {
        delete [] fOldP;
        fOldP = NULL;
    }

    if(fQL !=NULL)
    {
        delete [] fQL;
        fQL = NULL;
    }

    if(Fuel_burn !=NULL)
    {
        delete [] Fuel_burn;
        Fuel_burn = NULL;
    }

    if(fAQ !=NULL)
    {
        delete [] fAQ;
        fAQ = NULL;
    }

    if(fTT !=NULL)
    {
        delete [] fTT;
        fTT = NULL;
    }
//    float *farDVDF;                 //压力升高率
    if(farDVDF !=NULL)
    {
        delete [] farDVDF;
        farDVDF = NULL;
    }

//    float *farDPDF;                 //压力升高率
    if(farDPDF !=NULL)
    {
        delete [] farDPDF;
        farDPDF = NULL;
    }
//    float *farV;                    //气缸容积
    if(farV !=NULL)
    {
        delete [] farV;
        fTT = NULL;
    }
//    float *farLogP;                 //气缸压力对数值
    if(farLogP !=NULL)
    {
        delete [] farLogP;
        farLogP = NULL;
    }
//    float *farLogV;                 //气缸容积对数值
    if(farLogV !=NULL)
    {
        delete [] farLogV;
        farLogV = NULL;
    }
//    float *farFFTPr;                //压力FFT的实部
    if(farFFTPr !=NULL)
    {
        delete [] farFFTPr;
        farFFTPr = NULL;
    }
//    float *farFFTPi;                //压力FFT的虚部
    if(farFFTPi !=NULL)
    {
        delete [] farFFTPi;
        farFFTPi = NULL;
    }

//    float *farW;                //累积功
    if(farW !=NULL)
    {
        delete [] farW;
        farW = NULL;
    }
//    float *farDW;                //瞬时功
    if(farDW !=NULL)
    {
        delete [] farDW;
        farDW = NULL;
    }
//    float *farQW;                   //散热量
    if(farQW != NULL)
    {
        delete []farQW;
        farQW = NULL;
    }

//    float *farDQW;                  //瞬时散热量
    if(farDQW != NULL)
    {
        delete []farDQW;
        farDQW = NULL;
    }

//    float *farQA;                   //总放热率
    if(farQA != NULL)
    {
        delete []farQA;
        farQA = NULL;
    }

//    float *farDQA;                  //瞬时放热率
    if(farDQA != NULL)
    {
        delete []farDQA;
        farDQA = NULL;
    }

//    float *farQE;                   //内能+功
    if(farQE != NULL)
    {
        delete []farQE;
        farQE = NULL;
    }

//    float *farDQE;                  //瞬时 内能+功
    if(farDQE != NULL)
    {
        delete []farDQE;
        farDQE = NULL;
    }
//删除累加数据空间
//-----------------------------
    for(int i=0; i<PASSAGENUM; i++)
    {
        if(siConvertBuffer[i] != NULL)
        {
            delete [] siConvertBuffer[i];
            siConvertBuffer[i] = NULL;
        }
    }

}
void __fastcall lDieselHRBP::Delete3DMemory(void)
{
    if(f3DData != NULL)
    {
        for(int i=0; i<16; i++)
        {
            if(f3DData[i] != NULL)
            {
                delete [] f3DData[i];
                f3DData[i] = NULL;
            }
        }
        delete [] f3DData;
        f3DData = NULL;
    }
}
void __fastcall lDieselHRBP::CalculateCHRR(void)
{
    //TODO: Add your source code here
    int i = 0;
    float fsum = 0.0;
    for( i = 0 ;i< iStartFai; i++)
    {
        fDHDF[i]  = 0.0;
        fCDHDF[i] = 0.0;
    }
    for(i = iStartFai; i < iEndFai; i++)
    {
        fsum += fDHDF[i]/1000.0;        //将放热率转换为kJ
        fCDHDF[i] = fsum;
        fCDHDF[i] *= (1.0/(float)iNumPerAngle);
    }
    for(i = iEndFai; i< iPLength; i++)
    {
        fDHDF[i]  = 0.0;
        fCDHDF[i] = 0.0;
    }
    GetMinMax(fDHDF,iEndFai,   fHRRMin,fHRRMax,fDHDFMaxFai,true);
    GetMinMax(fCDHDF,iEndFai,fCHRRMin,fCHRRMax,fCDHDFMaxFai,true);
    GetMinMax(fTT,iPLength,fTMin,fTMax,fTMaxFai,true);
    GetFirstPeak(fDHDF,iPLength,fFirstDHDFMax,fFaiFirstDHDFMax);
    GetHeatPeak(fDHDF,iPLength, LFHS.fDHDFMax, LFHS.fFaiDHDFMax);
    fTMax -= 273.15;
}


bool __fastcall lDieselHRBP::AllocateOriginalMemory(int inum)
{
// 分配三个通道的原始数据空间
//------------------------------------------
    for(int i=0; i<PASSAGENUM; i++)
    {
        if(ipOData[i] != NULL)
        {
            delete [] ipOData[i];
            ipOData[i] = NULL;
        }
        ipOData[i] = new int[inum];
        if(ipOData[i] == NULL)
        {
            return false;
        }
    }
    if(fOBuffer != NULL)
    {
        delete [] fOBuffer;
        fOBuffer = NULL;
    }
    fOBuffer = new int[inum];
    if(fOBuffer == NULL)
    {
        return false;
    }
    return true;
//===========================================
}
bool __fastcall lDieselHRBP::AllocateAbstractMemory(int inum)
{
//分配累加数据空间
//----------------------------------------
    for(int i=0; i<PASSAGENUM; i++)
    {
        if(ipACData[i] != NULL)
        {
            delete [] ipACData[i];
            ipACData[i] = NULL;
        }
        ipACData[i] = new int[inum];
        if(ipACData[i] == NULL)
        {
            return false;
        }
    }
//分配提取数据空间
//----------------------------------------
    for(int i=0; i<PASSAGENUM; i++)
    {
        if(ipAData[i] != NULL)
        {
            delete [] ipAData[i];
            ipAData[i] = NULL;
        }
        ipAData[i] = new int[inum];
        if(ipAData[i] == NULL)
        {
            return false;
        }
    }
//分配滤波数据空间
//----------------------------------------
    if(fpFData != NULL)
    {
        delete [] fpFData;
        fpFData = NULL;
    }
    fpFData = new float[inum];        //用于保存滤波以后的数据
    if(fpFData == NULL)
    {
        return false;
    }


//分配滤波数据空间
//----------------------------------------
    if(fpSMData != NULL)
    {
        delete [] fpSMData;
        fpSMData  = NULL;
    }
    fpSMData = new float[inum];        //用于保存滤波以后的数据
    if(fpSMData == NULL)
    {
        return false;
    }

//分配压力升高率数据空间
//----------------------------------------
    if(fpSMDPDF != NULL)
    {
        delete [] fpSMDPDF;
        fpSMDPDF = NULL;

    }
    fpSMDPDF = new float[inum];        //用于保存滤波以后的数据
    if(fpSMDPDF == NULL)
    {
        return false;
    }
//----------------------------------------

//分配压力升高率数据空间
//----------------------------------------
    if(fpDPDF != NULL)
    {
        delete [] fpDPDF;
        fpDPDF = NULL;

    }
    fpDPDF = new float[inum];        //用于保存滤波以后的数据
    if(fpDPDF == NULL)
    {
        return false;
    }
//----------------------------------------

    return true;
//--------------------------------------
}

void __fastcall lDieselHRBP::DeleteOriginalMemory(void)
{
//删除原始数据空间
//------------------------------------
    for(int i=0; i<PASSAGENUM; i++)
    {
        if(ipOData[i] != NULL)
        {
            delete [] ipOData[i];
            ipOData[i] = NULL;
        }
    }
    if(fOBuffer != NULL)
    {
        delete [] fOBuffer;
        fOBuffer = NULL;
    }
//------------------------------------
}

void __fastcall lDieselHRBP::DeleteAbstractMemory(void)
{
//删除累加数据空间
//-----------------------------
    for(int i=0; i<PASSAGENUM; i++)
    {
        if(ipACData[i] != NULL)
        {
            delete [] ipACData[i];
            ipACData[i] = NULL;
        }
    }
//删除提取出来的数据空间
//------------------------------------
    for(int i=0; i<PASSAGENUM; i++)
    {
        if(ipAData[i] != NULL)
        {
            delete [] ipAData[i];
            ipAData[i] = NULL;
        }
    }
//删除滤波数据空间
//-------------------------------------
    if( fpFData != NULL)
    {
        delete []fpFData;
        fpFData = NULL;
    }

    //删除滤波数据空间
//-------------------------------------
    if( fpSMData != NULL)
    {
        delete []fpSMData;
        fpSMData = NULL;
    }

//删除压力升高率数据空间
//-------------------------------------
    if(fpSMDPDF != NULL)
    {
        delete []fpSMDPDF;
        fpSMDPDF = NULL;
    }
//-------------------------------------

//删除压力升高率数据空间
//-------------------------------------
    if(fpDPDF != NULL)
    {
        delete []fpDPDF;
        fpDPDF = NULL;
    }
//-------------------------------------
}


bool __fastcall lDieselHRBP::SaveAbstractedData(char * sfilename)
{
    //TODO: Add your source code here
    FILE *fp;
    if((fp = fopen(sfilename,"w")) == NULL)
    {
        return false;
    }
    for(int i=0;i<iAbstractLength;i++)
    {
        fprintf(fp,"%.4f\n",fOldP[i]);
    }
    fclose(fp);
    return true;
}

bool __fastcall lDieselHRBP::AbstractFromFile(char* filename)
{
    //TODO: Add your source code here
    //设置文件名后，调用该函数可自动生成处理后的文件，
    //新生成的文件名字与原来的文件仅差在后缀上，
    //返回值，true: 如果成功;
    //       false: 如果失败；
    AnsiString strFile,strTemp;
//    float fmaxvalue = 0.0;
    bool bsuccess = false;
    if(ReadOriginal(filename,true)) //如果读取数据成功，则绘图
    {
        iAbStartPosi = 0;
        iSampleNum = 0;
        while(true)
        {
            if(AbstractData())
            {
            }
            else
            {
                break;
            }
        }
        if(iSampleNum>0) //如果确有数据被提出来
        {
            strFile = AnsiString(filename);
//            strTemp = ExtractFileName(strFile);
//            strTemp += ".PCP";
            strTemp = ChangeFileExt(strFile,".PCP");
            if(SaveAbstractedData(strTemp.c_str()))
            {
                bsuccess = true;
            }
        }
    }
    return bsuccess;
}


float __fastcall lDieselHRBP::dqwc(float Te,float *faa,float *tw)
{
    //TODO: Add your source code here
   float ftemp,fk7;
   fk7 = 1.1*1000.0*265.0*pow(fDiameter,-0.214)*pow((fEn*fStroke/30.0),0.786)/21600.0/fEn;
//   fk7 = 1.1*bc*265.0*pow(fDiameter,-0.214)*pow((rpm*rc/15.0/aa/pp),0.786)/21600.0/rpm;
   ftemp = (fk7*pow(Te,-0.525)*pow(fPpm/100000.0,0.786)*(faa[0]*(Te-tw[0])+faa[1]*(Te-tw[1])+faa[2]*(Te-tw[2])));
   return ftemp;

}
     
float __fastcall lDieselHRBP::Cva(float Te)
{
    float ftemp;
    ftemp = ((20805.721-1.3270110*Te+4.0681743e-3*Te*Te-1.7085206e-6*Te*Te*Te+0.22947513e-9*Te*Te*Te*Te)/28.964);
    return ftemp;
}

float __fastcall lDieselHRBP::Cvb(float Te)
{
    float ftemp;
    ftemp = ((20720.007+2.1485250*Te+2.4822841e-3*Te*Te-1.2675601e-6*Te*Te*Te+0.17784060e-9*Te*Te*Te*Te)/29.0301);
    return ftemp;
}



bool __fastcall lDieselHRBP::AnEveryMemory(float * fPointer,int ilen)
{
    //TODO: Add your source code here
    if(fPointer !=NULL)
    {
        delete [] fTT;
        fPointer = NULL;
    }
    fPointer = new float[ilen];
    if(fPointer == NULL)
    {
        return false;
    }
    return true;
}

void __fastcall lDieselHRBP::DeEveryMemory(float* fPointer)
{
    //TODO: Add your source code here
    if(fPointer != NULL)
    {
        delete []fPointer;
        fPointer = NULL;
    }
}

void __fastcall lDieselHRBP::CalculateDPDF(void)
{
    //TODO: Add your source code here
    //此函数用计算压力升高率，保存在farDPDF中

    farDPDF[0] = 0.0;
    farDPDF[1] = 0.0;
    farDPDF[iPLength-2] = 0.0;
    farDPDF[iPLength-1] = 0.0;
/*
    for(int i=0;i<iPLength-1;i++)
    {
        farDPDF[i+1] = (fP[i+1] - fNewP[i])/(fFFFai[i+1]-fFFFai[i]);
    }
*/
    for( int i=2;i<iPLength-2;i++)
    {
        farDPDF[i] = (fNewP[i-2] -8.0*fNewP[i-1] + 8.0*fNewP[i+1] - fNewP[i+2])/(12.0*(fFFFai[i+1] - fFFFai[i]));
    }
    GetMinMax(farDPDF,iPLength,fDPDFMin,fDPDFMax,fDPDFMaxFai,true);
    farDVDF[0] = 0.0;
    farDVDF[iPLength - 1] = 0.0;

    float ftemp0,ftemp1;
    GetVolumn( fFFFai[0],ftemp0);
    for(int j = 1; j < iPLength ; j++)
    {
        GetVolumn(fFFFai[j],ftemp1);
        farDVDF[j] = pow(ftemp1,-1.30) - pow(ftemp0,-1.3);
        ftemp0 = ftemp1;
    }
}

bool __fastcall lDieselHRBP::CalculateFFTP(void)
{
    //TODO: Add your source code here
        //TODO: Add your source code here
    lDataProcess* ldp;
    ldp = new lDataProcess;
    if(ldp == NULL)
    {
//        Application->MessageBox("数据处理内存分配错误!","提示",MB_OK|MB_ICONINFORMATION);
        return false;
    }
//注意：此处的计算过程是需要修改的
    float *ftemp;
    ftemp = new float[iPLength];
    if(ftemp == NULL)
    {
//        Application->MessageBox("临时数据内存分配错误!","提示",MB_OK|MB_ICONINFORMATION);
        return false;
    }
    for(int i=0;i<iPLength;i++)
    {
        ftemp[i] = fNewP[i];
    }
    int in = 1;
    while(in < iPLength)
    {
        in *= 2;
    }
    iFFTLength = in/2;
    ldp->LBeginFFT(ftemp,farFFTPr,farFFTPi,iFFTLength,false);  //FFT变换

    delete ldp;
    delete []ftemp;
    bPLog = true;
//???????????????????????????????
//    iFFTLength = 128;
// ??????????????????????????????
    float ftempp;
    float fDeltaNT;
    fDeltaNT  = (float)iFFTLength*(1.0/(float)iNumPerAngle/(LFHS.fAngleStep))*LFHS.fTimeInterval/1000.0;

    if(bPLog)
    {
        for(int j=0;j<iFFTLength/2;j++)
        {
            farFFTPr[j] = (float)j/fDeltaNT;
            if(farFFTPi[j] < 1.0e-10)
            {
                farFFTPi[j] = 1.0e-5;
            }
            farFFTPi[j] = 20.0*log10(farFFTPi[j]);
        }
    }
    GetMinMax(farFFTPi,iFFTLength,fMinFFTP,fMaxFFTP,ftempp,false);
    return true;
}

void __fastcall lDieselHRBP::GetCPMinMax(float * fdata, int ilen, float& fmin, float& fmax)
{
    //TODO: Add your source code here
    //
    int iHLen = 55;

    fmin = fdata[2*iHLen];
    fmax = fdata[2*iHLen];

    for(int i = 2*iHLen; i<ilen - 2*iHLen;i++)
    {
        if(fdata[i] > fmax)
        {
            fmax    = fdata[i];
        }
    }
    fmin = fdata[2*iHLen];
    for(int i = 2*iHLen; i < iMaxPosi - 2*iHLen; i++)
    {
        if(fdata[i] < fmin)
        {
            fmin = fdata[i];
        }
    }
}

void __fastcall lDieselHRBP::GetMinMax(float * fdata, int ilen, float& fmin, float & fmax,float &fmaxfai,bool bAngle)
{
    //TODO: Add your source code here
    //用于在给定长度的数据中找到最大值及最小值　
/*
    int iHLen = 55;
    fmin = fdata[2*iHLen];
    fmax = fdata[2*iHLen];
    fmaxfai = 0;
    for(int i = 2*iHLen; i<ilen - 2*iHLen;i++)
    {
        if(fdata[i] < fmin)
        {
            fmin    = fdata[i];
        }
        else if(fdata[i] > fmax)
        {
            fmax    = fdata[i];
            fmaxfai = i;
        }
    }
    iMaxPosi = (int)fmaxfai;

    fmin = fdata[2*iHLen];

    for(int i = 2*iHLen; i < iMaxPosi - 2*iHLen; i++)
    {
        if(fdata[i] < fmin)
        {
            fmin = fdata[i];
        }
    }

//    fmax -= fBarP0;
    fmax -= fmin;
    if(bAngle)
    {
        fmaxfai = fFFFai[(int)fmaxfai];
    }
*/

    int iHLen = 55;
    fmin = fdata[2*iHLen];
    fmax = fdata[2*iHLen];
    fmaxfai = 2*iHLen;
    for(int i = 2*iHLen; i<ilen - 2*iHLen;i++)
    {
        if(fdata[i] < fmin)
        {
            fmin = fdata[i];
        }
        else if(fdata[i] > fmax)
        {
            fmax    = fdata[i];
            fmaxfai = i;
        }
    }
    iMaxPosi = (int)fmaxfai;
    if(bAngle)
    {
        fmaxfai = fFFFai[iMaxPosi];
    }
}
void __fastcall lDieselHRBP::CalculateLogVLogP()
{
    //TODO: Add your source code here
    //此函数用于计算V　LogP和LogV
    //TODO: Add your source code here
    float ftemp;
    for(int i=0;i<iPLength;i++)
    {
        GetVolumn(fFFFai[i],ftemp);
        farV[i] = ftemp;
        if(farV[i] < 1.0e-10)
        {
           farV[i] = 1.0e-5;
        }
        if(fNewP[i] < 1.0e-10)
        {
           fNewP[i] = 1.0e-5;
        }

        farLogP[i] = 20.0*log10(fNewP[i]);
        farLogV[i] = 20.0*log10(farV[i]);
    }
    float ftempp;
    GetMinMax(fNewP,iPLength,fCPMin,fCPMax,fPMaxFai,true);
    GetMinMax(farV,iPLength,fCVMin,fCVMax,ftempp,false);
}

void __fastcall lDieselHRBP::CarsSMOOTH(void)
{
    //TODO: Add your source code here
    //TODO: Add your source code here
    // 此函数的源代码来自于严志强
    //此函数用于计算压力曲线的光顺值  好像是五点光顺方法
    //输入为待求数据的位置 iposi
    // fp 为计算后的压力值
/*
    $NOFLOATCALL
	SUBROUTINE SMOOTH(N,Y)
	DIMENSION Y(366),YP(366)
	DO 85 I=1,N
   85	YP(I)=Y(I)
	Y(1)=(69.*YP(1)+4.*(YP(2)+YP(4))-6.*YP(3)-YP(5))/70.
	Y(2)=(2.*(YP(1)+YP(5))+27.*YP(2)+12.*YP(3)-8.*YP(4))/35.
	N22=N-2
	DO 86 I=3,N22
      Y(I)=(-3.*(YP(I-2)+YP(I+2))+12.*(YP(I-1)+YP(I+1))+17.*YP(I))/35.
   86	CONTINUE
      Y(N-1)=(2.*(YP(N-4)+YP(N))-8.*YP(N-3)+12.*YP(N-2)+27.*YP(N-1))/35.
	Y(N)=(-YP(N-4)+4.*(YP(N-3)+YP(N-1))-6.*YP(N-2)+69.*YP(N))/70.
	RETURN
	END
*/
    float ftemp;
//   Y(1)=(69.*YP(1)+4.*(YP(2)+YP(4))-6.*YP(3)-YP(5))/70.
    fNewP[0] = (69.0*fOldP[0] + 4.0*(fOldP[1] + fOldP[3]) - 6.0*fOldP[2] - fOldP[4])/70.0;

//      Y(2)=(2.*(YP(1)+YP(5))+27.*YP(2)+12.*YP(3)-8.*YP(4))/35.
    fNewP[1] = (2.0*(fOldP[0] + fOldP[4]) + 27.0*fOldP[1] + 12.0*fOldP[2] - 8.0*fOldP[3])/35.0;

//      Y(N-1)=(2.*(YP(N-4)+YP(N))-8.*YP(N-3)+12.*YP(N-2)+27.*YP(N-1))/35.
    fNewP[iPLength-2] = ( 2.0*(fOldP[iPLength-5] + fOldP[iPLength-1]) -8.0*fOldP[iPLength-4]
                 +12.0*fOldP[iPLength-3] + 27.0*fOldP[iPLength -2])/35.0;

//	Y(N)=(-YP(N-4)+4.*(YP(N-3)+YP(N-1))-6.*YP(N-2)+69.*YP(N))/70.
    fNewP[iPLength-1] = ( -fOldP[iPLength-5] + 4.0*(fOldP[iPLength-4] + fOldP[iPLength-2])
                 -6.0*fOldP[iPLength-3] - 69.0*fOldP[iPLength -1])/70.0;

    for(int i = 2; i< iPLength - 2; i++)
    {
//      Y(I)=(-3.*(YP(I-2)+YP(I+2))+12.*(YP(I-1)+YP(I+1))+17.*YP(I))/35.
        fNewP[i] = (-3.0*(fOldP[i-2]+fOldP[i+2])+12.0*(fOldP[i-1]+fOldP[i+1])
                 +17.0*fOldP[i])/35.0;
    }
}

float __fastcall lDieselHRBP::CarsLAQ(float fai)
{
    //TODO: Add your source code here
    // 在此处将改为对fFFFai和fNewP进行求解
    // 输入是一个角度
    // 返回此角度下的修正值

    //这段程序用于对上止点进行修正
   //	SUBROUTINE LAQ(N,T,X,Y,A)
   //   N: X,Y数据的长度
   //   T: 当前的X值
   //   X,Y: 分别为曲轴转角及相应的气缸压力
   //   A：为待求值
/*
$NOFLOATCALL
$DEBUG
	SUBROUTINE LAQ(N,T,X,Y,A)
	DIMENSION X(366),Y(366)
	IL=1
	M=N-IL
	DO 10 J=3,M
	I=J
	IF(T.GT.X(J)) GOTO 10
	IF(ABS(T-X(J-IL)).LE.ABS(T-X(J))) I=J-IL
	GOTO 20
 10	CONTINUE
	I=N-IL
20	U=(T-X(I))*(T-X(I+IL))/(X(I-IL)-X(I))/(X(I-IL)-X(I+IL))
	V=(T-X(I-IL))*(T-X(I+IL))/(X(I)-X(I-IL))/(X(I)-X(I+IL))
	W=(T-X(I-IL))*(T-X(I))/(X(I+IL)-X(I-IL))/(X(I+IL)-X(I))
	A=U*Y(I-IL)+V*Y(I)+W*Y(I+IL)
	RETURN
	END
*/
   int i;
   int iIL = 1;
   int iM;
   iM = iPLength - iIL - 1;
   for( int j = 2; j<iM;j++)
   {
       i = j;
       if( fai > fFFFai[j])
       {
            continue;
       }
       if(fabs(fai-fFFFai[j-iIL])<=fabs(fai-fFFFai[j]))
       {
            i = j - iIL;
       }
       break;
   }
   float fU,fV,fW,fret;
   fU = (fai - fFFFai[i])*(fai - fFFFai[i+iIL])/
        (fFFFai[i-iIL] - fFFFai[i])/(fFFFai[i-iIL]-fFFFai[i+iIL]);
   fV = (fai - fFFFai[i-iIL])*(fai - fFFFai[i+iIL])/
        (fFFFai[i]-fFFFai[i-iIL])/(fFFFai[i]-fFFFai[i+iIL]);
   fW = (fai - fFFFai[i-iIL])*(fai - fFFFai[i])/
        (fFFFai[i+iIL]-fFFFai[i-iIL])/(fFFFai[i+iIL] - fFFFai[i]);
   fret = fU*fNewP[i-iIL]+fV*fNewP[i]+fW*fNewP[i+iIL];
   return fret;
}

void __fastcall lDieselHRBP::CarsRTDC(void)
{
    //TODO: Add your source code here
    // 此函数好像是对上止点的位置进行修正

/*
   ICV1 的值 决定了修正的方法
$NOFLOATCALL
C$DEBUG
	SUBROUTINE RTDC(ICV1,D9,AN3,PCP,V,IZO,IZO1,CA,X0,QA)
	DIMENSION PCP(366),CA(366),X0(366),QA(366),SK(366)
        GOTO (8522,8518),ICV1
 8518	DO 8112 J=1,IZO1
 8112	SK(J)=X0(J)+D9
	DO 8114	J=1,IZO
	CAI=CA(J)
	CALL LAQ(IZO1,CAI,SK,QA,P1J)
 8114	PCP(J)=P1J
	GOTO 8514
 8522	CA(1)=-180.+D9
	DO 8510 I=2,IZO
 8510	CA(I)=CA(I-1)+AN3
 8514	CALL FW(PCP,V,IZO,CA)
	RETURN
	END
*/
}

void __fastcall lDieselHRBP::CarsFW(void)
{
    //TODO: Add your source code here
/*
  	SUBROUTINE FW(PCP,V,IZO,CA)
	DIMENSION PCP(366),V(366),CA(366)
	COMMON/GY14/ANR,AN6,ANE,AN5,PJ,AL1,AN32,ANI,AM5
	COMMON/GY5/D1,R,F1,YI,D9,C0
	AL1=0.
	IF(AN5.EQ.1.) THEN
	CALL FV(V,CA,IZO)
	ENDIF
	DO 480 I=2,IZO
  480	AL1=AL1+(PCP(I)+PCP(I-1))/2.*(V(I)-V(I-1))
	ANI=AL1*ANR*AN6/AN32/30./1000.*0.133
	PJ=(ANI*AM5-ANE)/ANE
	RETURN
	END
*/

}

void __fastcall lDieselHRBP::CarsFV(void)
{
    //TODO: Add your source code here
/*
    $NOFLOATCALL
C$DEBUG
	SUBROUTINE FV(V,CA,IZO)
	DIMENSION V(366),CA(366)
	COMMON /GY5/D1,R,F1,YI,D9,C0
	W1=3.141593*D1*D1/4.
	C0=2.*W1*R/(YI-1.)
	DO 130 I=1,IZO
	S0=CA(I)*3.141593/180.
C	WRITE(*,*) 'S0CAD9=',S0,CA(I),D9
	H=R*(1.-COS(S0))+F1-SQRT(F1*F1-R*R*SIN(S0)*SIN(S0))
  130	V(I)=W1*H+C0
C	WRITE(6,960) V(1),I,H,CA(1),C0
C 960	FORMAT(1X,'V I H CA CO=',F15.8,6X,I5,5X,F15.8,5X,F15.8,F15.8)
	RETURN
	END
*/
}

void __fastcall lDieselHRBP::CarsFT(void)
{
    //TODO: Add your source code here
/*
  	SUBROUTINE FT(I,X0I,PCPI,VI,TI,IZO)
	COMMON/GY6/AM1,ALF,RR
	AMI=AM1*(1.+X0I/ALF*.065/(1.+RR))
	TI=PCPI*VI/AMI/84800.
	RETURN
	END
*/
}

void __fastcall lDieselHRBP::CarsCHH(void)
{
    //TODO: Add your source code here
/*
	SUBROUTINE CCH(K,BX)
	DIMENSION X1(90),FI(90),BX(11)
	COMMON/GY2/X1,FI
	COMMON/GY7/M1,M/GY8/B9,E2,XF
	E2=0.
	AS1=(BX(4)+BX(5))*1.5
	AS2=(BX(1)+B9)*1.5
	IF((FI(K).LE.B9).OR.(FI(K).GE.AS1)) GOTO 125
	IF(FI(K).GT.AS2) GOTO 130
	FO=(-BX(7))*((FI(K)-B9)/BX(1))**BX(2)
	FE=-BX(1)/(FI(K)-B9)*FO
	RO=0.
	IF(FO.GT.-70.) RO=EXP(FO)
	E2=-BX(2)/BX(1)*FE*RO*(1.-BX(3))+X1(K)
	IF((FI(K).LE.BX(4)).OR.(M.EQ.2)) GOTO 500
	FS=-BX(8)*((FI(K)-BX(4))/BX(5))**BX(6)
	FW=-FS*BX(5)/(FI(K)-BX(4))
	RS=0.
	IF(FS.GT.-70) RS=EXP(FS)
	E2=E2-BX(6)/BX(5)*FW*RS*BX(3)
	GOTO 500
  130	IF(FI(K).LE.BX(4)) GOTO 500
     	FS=-BX(8)*((FI(K)-BX(4))/BX(5))**BX(6)
	FW=-BX(5)/(FI(K)-BX(4))*FS
	RS=0.
	IF(FS.GT.-70.) RS=EXP(FS)
	E2=X1(K)-BX(6)/BX(5)*FW*RS*BX(3)
	GOTO 500
  125	E2=X1(K)
  500	CONTINUE
	RETURN
	END
  */
}

void __fastcall lDieselHRBP::CarsPDS(void)
{
    //TODO: Add your source code here
/*
$NOFLOATCALL
$DEBUG
	SUBROUTINE PDS(K,G,BX)
	DIMENSION G(11),BX(11),FI(90),X1(90)
	COMMON/GY2/X1,FI
	COMMON/GY7/M1,M,/GY8/B9,E,XF
	AS1=(BX(4)+BX(5))*1.5
	AS2=(BX(1)+B9)*1.5
	IF ((FI(K).LE.B9).OR.(FI(K).GE.AS1)) GOTO 125
	IF (FI(K).GT.AS2) GOTO 130
	Q0=((FI(K)-B9)/BX(1))**(BX(2)-1.)
	F0=-BX(7)*((FI(K)-B9)/BX(1))**BX(2)
	R0=0.
	IF(F0.GT.-70.) R0=EXP(F0)
	G(1)=-BX(7)*(BX(2)/BX(1))**2*(XF-BX(3))*Q0*(1.+F0)*R0
	G(2)=BX(7)/BX(1)*(XF-BX(3))*Q0*(1.+(1.+F0)*BX(2)*ALOG((FI(K)-B9)
     -	/BX(1)))*R0
	IF(M.EQ.2) GOTO 150
	G(3)=-BX(7)*BX(2)/BX(1)*Q0*R0
	DO 128 I=4,M
  128	G(I)=0.
	IF(M.NE.8) GOTO 8000
	G(7)=BX(2)/BX(1)*(1.-BX(3))*Q0*R0*(1.+F0)
 8000	IF(FI(K).LE.BX(4)) GOTO 145
	QS=((FI(K)-BX(4))/BX(5))**(BX(6)-1.)
	FS=-BX(8)*((FI(K)-BX(4))/BX(5))**BX(6)
	RS=0.
	IF(FS.GT.-70.) RS=EXP(FS)
	G(3)=G(3)+BX(8)*BX(6)/BX(5)*QS*RS
	G(4)=BX(8)*BX(3)*BX(6)/BX(5)*QS/(FI(K)-BX(4))*(1.-(1.+FS)*BX(6))
     -	*RS
	G(5)=-BX(8)*BX(3)*(BX(6)/BX(5))**2*QS*(1.+FS)*RS
	G(6)=BX(8)*BX(3)/BX(5)*QS*(1.+(1.+FS)*BX(6)*ALOG((FI(K)-BX(4))
     -	/BX(5)))*RS
	IF(M.NE.8) GOTO 8002
	G(8)=BX(6)/BX(5)*BX(3)*QS*RS*(1.+FS)
 8002	GOTO 145
  130	IF(FI(K).LE.BX(4)) GOTO 125
     	QS=((FI(K)-BX(4))/BX(5))**(BX(6)-1.)
	FS=-BX(8)*((FI(K)-BX(4))/BX(5))**BX(6)
	RS=0.
	IF(FS.GT.-70.) RS=EXP(FS)
	DO 135 I=1,M
  135	G(I)=0.
	G(3)=BX(8)*BX(6)/BX(5)*QS*RS
	G(4)=BX(8)*BX(3)*BX(6)/BX(5)*QS/(FI(K)-BX(4))*(1.-(1.+FS)*BX(6))
     -	*RS
	G(5)=-BX(8)*BX(3)*(BX(6)/BX(5))**2*QS*(1.+FS)*RS
	G(6)=BX(8)*BX(3)/BX(5)*QS*(1.+(1.+FS)*BX(6)*ALOG((FI(K)-BX(4))
     -	/BX(5)))*RS
	IF(M.NE.8) GOTO 8004
	G(8)=BX(6)/BX(5)*BX(3)*QS*RS*(1.+FS)
 8004	GOTO 145
  125	DO 126 I=1,M
  126	G(I)=0.
  145	CONTINUE
	IF(M.NE.6) GOTO 150
	G(7)=0.
	G(8)=0.
  150	CONTINUE
	RETURN
	END
*/    
}

void __fastcall lDieselHRBP::CarsSUB(void)
{
    //TODO: Add your source code here
/*
$NOFLOATCALL
$DEBUG
	SUBROUTINE SUB(EE1,B)
	DIMENSION EE1(90),B(11)
	COMMON/GY1/Q/GY7/M1,M/GY8/B9,E1,XF/GY9/N11
	Q=0.
	DO 500 K=1,N11
	CALL CCH(K,B)
	EE1(K)=E1
	Q=E1*E1+Q
  500	CONTINUE
	RETURN
	END
*/
}

void __fastcall lDieselHRBP::CarsGS(void)
{
    //TODO: Add your source code here
/*
	SUBROUTINE GS(A,N)
	DIMENSION A(11,11)
	COMMON/GY7/M1,M/GY11/EPS
	DO 50 K=1,N
	BMAX=0.
	DO 20 I=K,N
	IF(BMAX-ABS(A(I,K))) 10,20,20
   10	BMAX=ABS(A(I,K))
	L=I
   20	CONTINUE
	IF(BMAX.GE.EPS) GOTO 44
	WRITE(*,*) A,BMAX
	STOP 4444
   44	IF(L.EQ.K) GOTO 30
	DO 25 J=K,M1
	T=A(L,J)
	A(L,J)=A(K,J)
   25	A(K,J)=T
   30	T=1./A(K,K)
	K1=K+1
	DO 40 J=K1,M1
	A(K,J)=A(K,J)*T
	DO 40 I=K1,N
   40	A(I,J)=A(I,J)-A(I,K)*A(K,J)
   50	CONTINUE
	DO 60 IK1=2,N
	I=M1-IK1
	I1=I+1
	DO 60 J=I1,N
   60	A(I,M1)=A(I,M1)-A(I,J)*A(J,M1)
	RETURN
	END
*/
}

void __fastcall lDieselHRBP::CarsLSN(void)
{
    //TODO: Add your source code here
/*
$NOFLOATCALL
	SUBROUTINE LSN(B,G,EE,B0,H,A,A0,MAXP)
	DIMENSION B(11),G(11),EE(90),B0(11),H(11),A(11,11),A0(11,11)
	COMMON/GY1/Q/GY8/B9,E,XF
	COMMON/GY7/M1,M/GY9/N11/GY10/ERR,GN/GY11/EPS
	DO 5 I=1,8
    5	B0(I)=B(I)
   10	LP=0
	IF(GN-1.) 12,11,12
   11	D=0.
	GOTO 13
   12	D=.01
   13	CALL SUB(EE,B)
   20	LP=LP+1
	Q0=Q
	DO 21 I=1,M
   21	B0(I)=B(I)
	DO 22 I=1,9
	DO 22 J=1,11
   22	A0(I,J)=0.
   30	DO 31 K=1,N11
	CALL PDS(K,G,B)
	G(M+1)=EE(K)
	DO 31 I=1,M
	P=G(I)
	DO 31 J=1,M1
   31	A0(I,J)=A0(I,J)+P*G(J)
	DO 35 I=1,M
	P=A0(I,I)
	IF(P) 106,106,35
   35	H(I)=1./SQRT(P)
	H(M+1)=1./SQRT(Q0)
	DO 38 I=1,M
	P=H(I)
	I1=I+1
	DO 37 J=I1,M1
   37	A0(I,J)=A0(I,J)*P*H(J)
   38	H(I)=P/H(M+1)
   40	IF(D.GE.2.E-7) D=D/10.
	W=1.
	D0=D
	M2=M-1
	DO 45 I=1,M2
	I1=I+1
	DO 45 J=I1,M
   45	A0(J,I)=A0(I,J)
   50	DO 51 I=1,M
	DO 51 J=1,M1
   51	A(I,J)=A0(I,J)
	DO 52 I=1,M
   52	A(I,I)=1.+D
	CALL GS(A,M)
   60	DO 61 I=1,M
	G(I)=A(I,M1)*H(I)
	IF(I.EQ.4) GOTO 61
	IF(ABS(G(I)/B0(I)).GT.0.9) G(I)=0.9*B0(I)
   61	B(I)=B0(I)+G(I)
	DO 62 I=1,2
   62	B(I)=ABS(B(I))
	IF(B(3).GE.1.) B(3)=1.
	IF(B(4).LT.B9) B(4)=B9
	DO 63 I=5,M
   63	B(I)=ABS(B(I))
	IF(B(7).LE.0.) B(7)=B0(7)
	IF(B(8).LE.0.) B(8)=B0(8)
	IF(B(1).GT.180.) B(1)=B0(1)
   64	WRITE(*,47) (B0(I),I=1,8),(G(I),I=1,8),D,Q,W1,LP
   47	FORMAT(1X,'B0=',8E11.5/2X,'G=',8E11.5,'D,Q,W1=',E8.2,E11.5,E11.5,
     -	I4)
   70	CALL SUB(EE,B)
	IF(D0-D) 80,71,71
   71	DO 72 I=1,M
	IF(ABS(G(I)/(ABS(B(I))+.00001))-ERR) 72,72,80
   72	CONTINUE
	GOTO 100
   80	IF(Q-Q0) 81,84,84
   81	IF(LP-MAXP) 20,102,102
   84	IF(GN-1.) 85,81,85
   85	IF(D-20.) 86,90,90
   86	D=10.*D
	GOTO 50
   90	W=W/1.2
	IF(W-1.E-8) 104,104,92
   92	DO 93 I=1,M
   93	B(I)=B0(I)+W*G(I)
	W1=W
	CALL SUB(EE,B)
	IF(Q-Q0) 20,90,90
  100	E=Q
	WRITE(*,101) LP,E
	WRITE(6,101) LP,E
  101	FORMAT(1X,'LP=',I9,5X,'E=',E11.4////)
	GOTO 110
  102	WRITE(*,103) (B(I),I=1,8),Q
     	WRITE(6,103) (B(I),I=1,8),Q
  103	FORMAT(4X,4HFALL,6X,8HMAXP*OV*,9F11.5////)
	GOTO 109
  104	WRITE(*,105) (B(I),I=1,8),Q
     	WRITE(6,105) (B(I),I=1,8),Q
  105	FORMAT(4X,4HFALL,6X,5HD=100,4X,3HW=0,9E9.3////)
	GOTO 109
  106	WRITE(*,107) (B(I),I=1,8),Q
  107	FORMAT(4X,4HFALL,6X,5HALL=0,9E9.3)
  109	M1=1024
  110	Q=E
	RETURN
	END
*/
}

void __fastcall lDieselHRBP::CarsFJM(void)
{
    //TODO: Add your source code here
/*
  	SUBROUTINE FJM(A,QE,DQE,MM)
	DIMENSION DQE(366),A(366),QE(366)
	COMMON/GY12/D10,B10/GY121/K11,N10,IB10,KN,N9
	D10=DQE(K11)
	K11=K11+1
	DO 280 I=K11,KN
	IF(MM-1) 275,277,275
  275	IF(D10-DQE(I)) 290,279,279
  277	IF(D10-DQE(I)) 279,279,290
  279	D10=DQE(I)
	B10=A(I)
	IB10=I
  280	CONTINUE
  290	D10=QE(IB10)
	RETURN
	END
  */
}

void __fastcall lDieselHRBP::CarsFXM(void)
{
    //TODO: Add your source code here
/*
$NOFLOATCALL
	SUBROUTINE FXM(A,QE,DQE,MM)
	DIMENSION DQE(366),A(366),QE(366)
	COMMON/GY12/D10,B10/GY121/K11,N10,IB10,KN,N9
	D10=DQE(K11)
	DO 290 I=K11,KN
	IF(MM-1) 275,277,275
  275	IF(D10-DQE(I)) 290,279,279
  277	IF(D10-DQE(I)) 279,279,290
  279	D10=DQE(I)
	B10=A(I)
	IB10=I
  290	CONTINUE
	D10=QE(IB10)
	RETURN
	END
*/
}

void __fastcall lDieselHRBP::CarsCHP(void)
{
    //TODO: Add your source code here
/*
$NOFLOATCALL
	SUBROUTINE CHP(IB,N)
	DIMENSION D(90),B(90),IB(90)
	COMMON/GY2/D,B
	NM1=N-1
	DO 40 I=1,NM1
	IP1=I+1
	DO 30 J=IP1,N
	IF(B(I).LE.B(J)) GOTO 30
	TEP=B(I)
	B(I)=B(J)
	B(J)=TEP
	TEP=D(I)
	D(I)=D(J)
	D(J)=TEP
	IEP=IB(I)
	IB(I)=IB(J)
	IB(J)=IEP
   30	CONTINUE
   40	CONTINUE
	RETURN
	END
   */
}

void __fastcall lDieselHRBP::CarsMUC(void)
{
    //TODO: Add your source code here
/*
    $NOFLOATCALL
	SUBROUTINE MUC(C1,C2,C3,C4,T)
	C1=4.678+(6.8723E-4-6.0683E-8*T)*T
	C2=4.715+(1.1990E-3-1.4232E-7*T)*T
	C3=4.678+(2.*6.8723E-4-3.*6.0683E-8*T)*T
	C4=4.715+(2.*1.1990E-3-3.*1.4232E-7*T)*T
	RETURN
	END
*/
}

void __fastcall lDieselHRBP::CarsHeatRelease(void)
{
//从文件中读入各个参数，各个参数的含义如下：
//  DTAP1 示功图压力修正值
//  AN3   计算步长
//  AN4   当压力输入等间隔时(ICV1=3)此间隔长度(CA)
//  PS3   进气阀关闭时缸内压力  kg/cm2
//  AM5   机械效率(含换气功)
//  ANE   发动机有效功率    PS
//  DI    缸径       mm
//  R     曲柄长     mm
//  F1    连杆长     mm
//  YI    压缩比
//  RR    废气系数
//  ANR   发动机转速   rpm
//  Hu    燃油低热值
//  AN32  冲程数
//  GO    总空气流量     kg/s
//  AN6   缸数
//  G1    有效油耗       g/PS.HR
//  GN    GN=1时采用Guass-Newton进行非线性拟合
//  ERR   拟合误差
//  EPS   高斯法解线代方程时，主元最小允值
//  PT    涡轮前压力       kg/cm2
//  TS    压缩始点温度     K
//  FIV   气阀重迭角       CA
//  AK    求燃烧始点时的最小放热率允值
//  D9    上止点修正值(D9>0时压力轴左移) CA
//  CW    散热量修正
//  FS    扫气系数
//  XM    喷油开始前累积放热率允值
//  SM    迭代X时的误差限
//  XCW   X=1时的误差限
//  XC    输入示功图曲线时的角度比例尺
//  YC    输入示功图曲线时的压力比例尺

//  IZO   360CA内步长总数
//  IZO1  输入压力个数
//  N     示功图个数
//  N1    未用
//  N2    未用
//  N6    未用
//  N9    计算开始下标
//  N10   计算结束下标［
//  IA    进气阀关闭角度
//  IST   示功图显示的次要结果打印步长
//  IST1  主要结果打印步长
//  ICV1  1：磁盘输入的360个压力    2：磁盘输入压力及对应角度IZO1个 3：磁盘输入的IZO1个压力
//  ICV2  1: 打印输入变量   0:不打印输入变量
//  ICV3  1:显示输入压力图  0：不显示输入压力图
//  ICV4  1:输出次要结果    0：不输出次要结果
//  ICV5  1:非线性拟合未收敛时重迭初值   0：未收敛时也不再重算
//  ICV6  0:将实际放热率结果以C：DQOUT名输出并不进行非线性拟合  1：与0时相反
//  ID2   0:不修正上止点    1:修正上止点
//  MAXP  非线性拟合中的最大迭代次数
//  ID0   压力光顺次数
//  ID    放热率光顺次数
//  ID1   未用
//  JN    未用
//  I8    排气阀开角
//  M     双韦伯参数个数
//  CN   ?
//  MCS  ?

//查找进行气门关闭时的曲轴转角
/*
//------------------------------------------------------
	DO 68 I=1,IZO
	IF((CA(I)-FLOAT(IA)).LE.0.5) THEN
	PS3=PCP(I)
C	WRITE(*,*) 'I,IA,CA(I),FLOAT(IA),PS3',I,IA,CA(I),FLOAT(IA),PS3
	ENDIF
   68	PEP(I)=PCP(I)
//------------------------------------------------------
*/
    float TA,TS,AM1,ALF,FIV,PT,PS3;
    int N9,N10;
    float *X0,*T,*AL,*QA,*DQA,*SK,*ANK,*QW,*DQW,*P,*QE,*DQE,*PCP,*V,*CA;
    float YI,R,D1,RR;
    float AD,TW,G1,ANR,AN6,CM;
    float IXZ,K9,D9,F0,V111,U1,HB,B9,ZPZ,MP,BB9;
    float TI,AMI,CVA,CVE,S,U,HU,CW;
    float SM,XM,ZP;
//    float fstep;

//------------------------------------------------------
// GO: 为空气总流量
// PT: 涡轮前压力
// PS3:进气阀关闭时缸内压力
// TS: 压缩始点温度
// FIV: 气阀重迭角
// AM1: 缸内空气质量
// 以下代码用于确定缸内空气质量
//------------------------------------------------------
/*
	IF(GO.NE.0.) GOTO 72
	IF(PT.EQ.0.) PT=1.15*PS3
	TA=85.5+5./6.*TS-(2.*(PS3-1.)+2.1*SQRT(FIV-8.)*(PT/PS3-1.)**.25)
	AM1=PS3*YI/(YI-1)*R*D1*D1/2.*3.141592/84800./TA
	ALF=AM1/.495/G1/ANE/AN32*12.*ANR*AN6*10000.
	AM1=AM1*(1.+RR)
	GOTO 74
   72	AM1=30.*(1.+RR)*AN32*GO/AN6/28.96/FS/ANR
	ALF=3.6E6*GO/G1/ANE/14.335/FS
	WRITE(*,*) 'Mo=',AM1,'   ALF=',ALF
   74	WRITE(6,*) 'Mo=',AM1,'   ALF=',ALF
//------------------------------------------------------
*/

//------------------------------------------------------
//  N9 : 计算开始下标       IA进气阀关闭角度 ATDC
//  N10: 计算结束下标       I8排气阀开启角度 ATDC
//------------------------------------------------------

    DetectCPosi();  //用于寻找进行门关与排气开的位置
    N9 = icStartPosi;
    N10 = icEndPosi;
    PS3 = fcStartP;
//-------------------------------------------------------

//-------------------------------------------------------
//	对放热率计算过程中所用的变量进行初始化处理,
//  IZO很可能是一次计算过程上所需要的点数
//-------------------------------------------------------

//-------------------------------------------------------
//   对变量数组进行初始化
//   置零处理
//--------------------------------------------------------
    X0 = Fuel_burn;
    T = fTT;
    AL = farW;
    QA = farQA;
    DQA = farDQA; //????
    SK =  fAQ;
    ANK = fQL;
    QW = farQW;
    DQW = farDQW;
    P = fOldP;
    QE = farQE;
    DQE = farDQE;
    PCP = fNewP;
    V = farV;
    CA = fFFFai;
    for(int I=0;I<iPLength;I++)
    {
	    X0[I] = 0.0;          // 每个步长内燃烧的燃油量
	    T[I] = 0.0;           // 气缸内温度
	    AL[I] = 0.0;				//
	    QA[I] = 0.0;
	    DQA[I] = 0.0;
	    SK[I] = -9.5;
	    ANK[I] = 0.0;
	    QW[I] = 0.0;                //散热量
	    DQW[I] = 0.0;               //散热变化量
	    P[I] = 0.0;
	    QE[I] = 0.0;
        DQE[I] = 0.0;
    }
//-----------------------------------------------------------

    RR = fGAMA;
    YI = fCRatio;
    R = fStroke/2.0;
    D1 = fDiameter;

    PT = 1.2;   //先假定涡轮前的压力为1.2倍的大气压力
    FIV = fOutCloseAngle - fInOpenAngle;    //进排气门重迭角
    TS = fTAir;                             //压缩始点的温度
    TA = 85.5 + 5.0/6.0*TS - (2.0*(PS3 - 1.0) + 2.1*sqrt(FIV - 8.0)*pow(PT/PS3,0.25))/100000.0;
    PS3 *= fBarToPa;  //将进气压力转换为Pa
//    AM1 = PS3*YI/(YI-1)*R*D1*D1/2.0*PI/8314.3/TA;
     AM1 = PS3*V[N9]/8314.3/TA;
//	ALF=AM1/.495/G1/ANE/AN32*12.*ANR*AN6*10000.;
    ALF = 1.4;   //暂时取过量空气系数为1.4 ，因为还不知道有效功率，有效燃油消耗量
    AM1 = AM1*(1.0 + RR);
//------------------------------------------------------------
//计算壁面的平均温度
//  AD是什么东西，难道是每循环耗油量不成
//  TW是壁面温度
//-------------------------------------------------------------

    ANR = fEn;   //柴油机转速
    AN6 = 1;      //缸数
	AD = fGF;
//    AD = G1*ANE*AN32/ANR/AN6/120000.

//	TW=7.*225.*ANE*AN32/ANR/AN6/(3.141593*D1*D1/2.*R)*1000.+400.
//  TW = 7*Pe + 400;
    TW = 420.0 + 273.15;   //暂时取燃烧室平均温度为420.0;

//  这里得到的温度是不是绝对温度 民民

//--------------------------------------------------------------

    // 不知道它的单位是什么
	CM=ANR*R*2.0/30.0;			//活塞平均速度

//	CALL FW(PCP,V,IZO,CA) //燃烧过程中气体所作的功

    CW = 1.0;  //散热量调整系数
    SM = 0.0005;
    XM = 20.0;
    HU = fHU;
    IXZ = 0;
	K9 = 100;
	D9 = 0.0;
	F0 = 1.0E-10;
    U1 = 0.0;
    B9 = -15.0;
	ZPZ = 0.344E-1;   // ZPZ又是干什么的呢
    MP = 0;
    BB9 = 0.99;
	V111 = V[0];
	HB=AD*HU;
//	CALL FV(V,CA,IZO)			//

//------------------------------------------------
//   从计算始点开始计算到计算终点
//   计算累积功
//-------------------------------------------------
    int IKK;
    IKK = N9 + 1;
    for( int I = N9; I<N10; I++)
    {
        AL[I]=AL[I-1]+fBarToPa*(PCP[I]+PCP[I-1])/2.0*(V[I]-V[I-1]);    //求所作的功
    }
//-------------------------------------------------------------
    MP=0;
//---------------------------------------------------------
//   从计算始点到计算终点
//---------------------------------------------------------
    float fdqw,fqw,fde,fe,fdw,fw;
    float Te;
    for(int I = IKK; I<N10;I++)
    {
    	X0[I] = X0[I-1];

//        180	CALL FT(I,X0(I),PCP(I),V(I),T(I),IZO)　　　　　//求气体温度
        do
        {
            AMI = AM1*(1.0+X0[I]/ALF*0.065/(1.0+RR));
	        T[I] = PCP[I]*fBarToPa*V[I]/AMI/8314.3;
            Te = T[I];
//            CVA = ((20805.721-1.3270110*Te+4.0681743e-3*Te*Te-1.7085206e-6*Te*Te*Te+0.22947513e-9*Te*Te*Te*Te)/28.964);
//            CVE = ((20720.007+2.1485250*Te+2.4822841e-3*Te*Te-1.2675601e-6*Te*Te*Te+0.17784060e-9*Te*Te*Te*Te)/29.0301);
//    	    CVA = 4.67803+6.87338E-4*T[I]-6.06834E-8*T[I]*T[I];   //计算空气的定容比热
//    	    CVE = 4.75128+1.19901E-3*T[I]-1.42322E-7*T[I]*T[I];   //废气的定容比热
            CVA = 4186.0*(4.6+0.0006*Te);
            CVE = 4186.0*(4.89+0.00086*Te);
        	S = 8314.3*(ALF*(1.+RR)+.065*X0[I]);                  //
    	    U = (1.065*X0[I]+ALF*RR)*CVE+(ALF-X0[I])*CVA;         //
        	U = PCP[I]*fBarToPa*V[I]*U/S;                                  //此处的U为气体内能
        	P[I] = U;
     	    QA[I] = U - P[IKK] + (AL[I]-AL[IKK]);        //累积放热率
         	DQA[I] = (QA[I]-QA[I-1])/(CA[I]-CA[I-1]);         //放热率
//请验证一下散热公式是否正确
	        DQW[I] = 300.*CW*pow(PCP[I]/10.0*CM,0.786)*pow(T[I],-0.525)*pow(D1, -0.214);
//        	DQW[I] = DQW[I]*(T[I]-TW)*(4.*V[I]/D1 + PI*D1*D1/2.)/6.0/fEn*57.29578;
        	DQW[I] = DQW[I]*(T[I]-TW)*(4.*V[I]/D1 + PI*D1*D1/2.)/6.0/fEn;
//            fdqw =
            QW[I] = QW[I-1] + DQW[I]*(CA[I]-CA[I-1]);        //总的传热率
        	DQE[I] = DQA[I] + DQW[I];                             // 总的放热率
        	QE[I] = QA[I] + QW[I];                                //总的放热量
    	    S = QE[I]/AD/HU;                                    //S为此步长内的喷油量
//---------------------------------------------------------
//  以是迭代条件的测试
//---------------------------------------------------------
            if(fabs(S-X0[I])-SM>0.0)
            {
                X0[I] = S;
                continue;
            }
            else
            {
                X0[I] = S;
                break;
            }
        }while(true);
        //      fDHDF[iI] = fDQRCA;
        fDHDF[I] = DQE[I];	//放热率

//        farW[i] = W;
//        farQW[i] = qw;
//        farDQW[i] = fAQ[i];
        farQE[I] = U;
        if( I > IKK)
        {
            farDW[I] = (AL[I] - AL[I-1])/(fFFFai[I] -fFFFai[I-1]);
            farDQE[I] = (P[I] - P[I-1])/(fFFFai[I] - fFFFai[I-1]);
        }
        if(fabs(fFFFai[I]+20.0) <1.0)
        {
            fFFFai[I] = fFFFai[I];
        }

        if((CA[I]>=(B9-5.0))||(CA[I]<= -100.0))
        {
             continue;
        }
      	if(MP >= 20)
        {
            continue;
        }
        if(fabs(S)<XM)
        {
            continue;
        }
       	MP = MP + 1;
      	ZP = S*80.0/(CA[I]-CA[N9]);
      	ZPZ = ZPZ + ZP;
      	for( int J=0;J < iPLength; J++)
        {
            PCP[J] = PCP[J] + ZP;
        }
      	PS3 = PCP[N9];
        I = IKK - 1;
    }
    IKK = IKK;
}

void __fastcall lDieselHRBP::DetectCPosi(void)
{
    //TODO: Add your source code here
    float fstep;
    fstep = fFFFai[1] - fFFFai[0];
    for(int i=0; i<iPLength; i++)
    {
        if( fabs(fFFFai[i] - fInCloseAngle)< fstep)
        {
            icStartPosi = i;
            fcStartP = fNewP[i];
        }
        else if( fabs(fFFFai[i] - fOutOpenAngle) < fstep)
        {
            icEndPosi = i;
            break;
        }
    }
}

void __fastcall lDieselHRBP::LrwHeatRelease(void)
{
    //TODO: Add your source code here
    //当各参数及压力曲线都已初始后调用此函数进行放热率计算
    //此函数实为天津大学王教授的程序，只是进一步确认一下，比如：物理单位等
    float fW,fW1,fW2;
    float fH;
    float fFMUF;                  //
    float fDW;                    //这一步长内所做的功
    float fVH;                    //气缸的排量
    float fAN;                    //柴油机转速
    float fPIS,fPIM;
    float fNIS,fNIM;
    float fNES,fNEM;
    float fGH;
    float fATI;
    float fGIS;   //fGIM;
    float fGES;   //fGEM;
    float fQW1;
    float fDPMAX,fDQMAX;
    float fQF1,fDQRCA;
    float fCY;
    float fDGF;
    float fM1;
    float fE1,fE2;
    float fDPRCA;
    float fB[5];
    float fB2[5];

    int iI = 0,iJK;
    float fP1,fX,fX1,fX2,fV1,fV2;
    float fT1,fT2;
    float fPCM;

    float fPK = 19.0; //此参数尚不知道是什么意思？
    float fCM;

    float fMAirO2,fMAirN2;  //新鲜空气的氧气和氮气的摩尔数
// 燃料完全燃烧时生成的CO2、H2O
    float fMCompleteBurnCO2,fMCompleteBurnH2O,fMCompleteBurnN2,fMCompleteBurnO2;
//  CO2、H2O是生成物，而N2和O2是消耗物
    float fMCompleteBurnAll;  //总的摩尔数
    float fMLeftAirN2,fMLeftAirO2;    //反应后所剩下的氧气和氮气摩尔数
    float fMDeltaN2,fMDeltaO2,fMDeltaH2O,fMDeltaCO2;
    float fMA,fFMR,fFMRA,fM2;

    float fPEM,fPES;
    float fDPMMAX,fCADPMAX,fDMF1,fDMF2;
    float fXLM;
    float fT,fXH,fDB,fPQ,fPM,fDQ,fQW2,fQF2;
    float fDQMMAX,fCADQMAX;
    float ftemp;
    float Fuel_mass = 0.0;
    float FJL[] = {0.5,0.5,1.0,1.0,0.5};
    float fgl = 0.0;
    ftemp = GetVolumn(0,ftemp);  //当活塞在上止点时缸内的体积
    fXH = 4.0*ftemp/(PI*fDiameter*fDiameter);   //暂时认为当量高度为0;　fXH为当量高度
    fDB = fDiameter;   //暂时认为当量直径为气缸直径;
//    fH = fDFai;                //计算步长
    fH = fFFFai[1] - fFFFai[0];
    fAN = fEn;                 //柴油机转速
    fW = 0.0;                  //柴油机作功

    fFMUF = 12.0*fNC + fMH;  //燃料的摩尔质量。
    fCA = fFFFai[iI];
    fP1 = fNewP[iI];

    DetectCPosi();

//    fX1 = fXX(fCA);
    fV1 = GetVolumn(fCA,fV1);
    while( iI < iPLength-1)
    {
        fCA += fH;
        fV2 = GetVolumn(fCA,fV2);
        fDW = (fNewP[iI]+fNewP[iI+1])*fBarToPa*(fV2-fV1)/2.0;  //乘以100000是因为单位是bar
        fW += fDW;
        farDW[iI+1] = fDW/fH;
        farW[iI+1] = fW;
        iI = iI + 1;
        fV1 =fV2;
    }
    farDW[iPLength - 1] = farDW[iPLength - 2];
    farW[iPLength - 1] = farW[iPLength -2];

    fVH = PI*fDiameter*fDiameter*fStroke/4.0;  //计算气缸的排量
/*
    fPIS = fW / fVH;
    fPIM = fPIS * 1.02e-5;
    fNIS = fPIS*fVH*fAN*fFI/fTAU/300.0/100.0;    //fFI 为缸数
    fNIM = fNIS*1.36;
    fNEM = 0.001*fPK*fAN;
    fNES = 0.736*fNEM;
    fATM = fNES/fNIS;
    fPEM = fPIM*fATM;
    fPES = fPIS*fATM;
    fGH = fGF*3.6/fTF;          //
    fATI = 3.6E6*fNIS/fGH/fHU;  //fHU　燃料的低热值
//  fGIS = fGH/fNIS*1.0e3;
//    fGIM = 0.736*fGIS;
//  fGES = fGIS/fATM;
//    fGEM = 0.736*fGES;
//  fATE = fATM*fATI;
*/
//开始计算喷油参数
    fCA = fCAING;                           //从开始喷油处进行计算 ,fCAING为喷油提前角
    float fI00;

    fI00 = fFFFai[0];
//    iI = (int)fabs((fI00 - fCA)/fH);                      //用于定位所测量的气缸压力
    for(int i = 0;i<iPLength;i++)
    {
        fTT[i] = fT0;
        fDHDF[i] = 0.0;                     //对于没有计算的角度置放热率值为0
    }
    fQW1 = 0.0;                             //气缸散热量
    iJK = 1;
    fDPMAX = 0.0;                           //最大压力变化率
    fDQMAX = 0.0;                           //最大放热率
    fW1 = 0.0;                              //做功
    fQF1 = 0.0;                             //燃油放热量
    fDQRCA = 0.0;                           //燃油放热率
    fCY = 1.0;                              //????
//    fDGF = 0.12*fGF/(fTF*fAN*fFI);
//    fDGF = 0.12*fGF/(fTF*fAN);

    fDGF = fGF/fTF;
    //这里只是做一个估计,
   //fTF为喷油持续期，
   //fGF为单循环喷油量，
   //fDGF为每曲轴转角喷油量用于做为喷油预估量

    fCM = fStroke*fEn/30.0;         //fCM为活塞平均速度，fAN为柴油机转速
//    fMA = fALPHA*fLO*fDGF;
//    fV0 = GetVolumn(-138.0,fV0);              //计算此时气缸工作容积
    fV0 = GetVolumn(-180,fV0);

    fMA = fP0*fV0/(fRMOL*fT0);    //计算此时气内的新鲜充量的摩尔数　　　？？？？好像容积不对
//fMA 的单位是kmol

//此时是否要考虑残余废气系数呢
    fFMRA = fMA*fGAMA;                      //残余废气的摩尔数
    fMAirO2 = 0.21*fMA*(1.0-fGAMA);          //燃烧前空气中氧气的摩尔数
    fMAirN2 = 0.79*fMA*(1.0-fGAMA);          //燃烧前空气中氮气的摩尔数
//  MO 为燃烧前
//  MR 为燃烧后
//  fNC: 燃油分子中所含碳原子数
//  fMH: 燃油分子中所含氢原子数
                                            //以下用于计算完全燃烧一摩尔燃料其产物中各种成份的摩尔数
    fMCompleteBurnCO2 = fNC;                //二氧化碳的摩尔数与燃料中碳原子的个数相同
    fMCompleteBurnH2O = fMH/2.0;                      //水的摩尔数是燃料中氢原子的个数除以2
    fMCompleteBurnN2 = 3.76*fALPHA*(fNC+fMH/4.0);     //fALPHA为过量空气系数　
    fMCompleteBurnO2 = (fALPHA - 1.0)*(fNC + fMH/4.0); //燃烧后氧气的摩尔数

    fMCompleteBurnAll = fMCompleteBurnCO2 + fMCompleteBurnH2O
                        + fMCompleteBurnN2 + fMCompleteBurnO2;
    //完全燃烧后的各组分的总和
    //1kg摩尔燃料完全燃烧后的总摩尔数
    //fGAMA为残余废气系数，对于非增压柴油机，其值可为0.03至0.06,
    //对于增压柴油机而言可取为0
    //fFMRA 是气缸内残余废气的总摩尔数
    fB[0] = fFMRA*fMCompleteBurnCO2/fMCompleteBurnAll;           //二氧化碳的气体摩尔数
    fB[1] = fFMRA*fMCompleteBurnH2O/fMCompleteBurnAll;           //水汽的气体摩尔数
    fB[2] = fFMRA*fMCompleteBurnN2/fMCompleteBurnAll + fMAirN2;   //氮气的气体摩尔数
    fB[3] = fFMRA*fMCompleteBurnO2/fMCompleteBurnAll + fMAirO2;     //氧气的气体摩尔数
    fB[4] = fDGF/fFMUF;                   //燃油的摩尔数　　fDGF 为瞬时喷油量，fFMUF燃料的摩尔质量
    //fB[4]为在这一步长内喷入气缸的燃料摩尔数

    fCA = fFFFai[icStartPosi];
    fM1 = fB[0]+fB[1]+fB[2]+fB[3]+fB[4];    //缸内气体的总摩尔数
    fV1 = GetVolumn(fCA,fV1);               //这时此时的气缸容积
    fX1 = GetfX(fCA);
    fT1 = fBarToPa*fNewP[icStartPosi]*fV1/fRMOL/fM1;    //此时气缸内的温度
    fTT[icStartPosi] = fT1;
    fE1 = CalculateTENB(fT1,fB);            //此时气体的内能
    farQE[icStartPosi] = fE1;               //farQE用于保存气体内能
    iI = icStartPosi;
    iStartFai = icStartPosi;
    do
    {
        fH = fFFFai[iI+1] - fFFFai[iI];
        fCA = fCA +fH;                           //曲轴转角加上步长
        fX2 = GetfX(fCA);                        //获取侧向高度
        fV2 = GetVolumn(fCA,fV2);                //得到此时气缸容积
        fT2 = fBarToPa*fNewP[iI+1]*fV2/fRMOL/fM1;
        fE2 = CalculateTENB(fT2,fB);
        fPCM = fBarToPa*(fNewP[iI]+fNewP[iI+1])/2.0;    //此时气缸内的平均压力
        fDW = fPCM*(fV2-fV1);                    //在这一步长内气体所做的功
        fW2 = fW1 +fDW;                          //fW2为做功的总和
    //计算压力随曲轴转角的变化率
        fDPRCA = fBarToPa*(fNewP[iI+1]-fNewP[iI])/fH;   //气缸压力变化率
        if(fDPMAX < fDPRCA )                     //计算最大气缸压力变化率
        {
            fDPMAX = fDPRCA;
            fDPMMAX = fDPMAX*1.02e-5;
            fCADPMAX = fCA;
        }
//        fDMF1 = fDGF*fCY/60.0;                   //除以60是什么意思??????
        fDMF1 = fDGF;
        int iIterNum =0;
        do
        {

//          fDMF1 = fDGF*fCY/60.0;
            fMDeltaCO2 = fNC*fDMF1/fFMUF;
            fMDeltaH2O = fMH*fDMF1/fFMUF/2.0;
            fMDeltaN2 = 0.0;
            fMDeltaO2 = -(fNC+fMH/4.0)/fFMUF*fDMF1;
            fB2[0] = fB[0] + fMDeltaCO2;
            fB2[1] = fB[1] + fMDeltaH2O;
            fB2[2] = fB[2] + fMDeltaN2;
            fB2[3] = fB[3] + fMDeltaO2;
            fB2[4] = fB[4] - fDMF1/fFMUF;
//            fM2 = fB2[0]+fB2[1]+fB2[2]+fB2[3]+fB2[4];
            fM2 = fB2[0] + fB2[1] + fB2[2] + fB2[3] +fB2[4];
            fT2 = fBarToPa*fNewP[iI+1]*fV2/fRMOL/fM2;
//计算热损失
            fXLM =(fX1+fX2)/2.0;
            fT = (fT1+fT2)/2.0;
            fAREA[0] = PI*fDiameter*fXLM;                      //气缸套面积
            fAREA[1] = PI*fDiameter*fDiameter/4.0;             //活塞顶部面积
            fAREA[2] = PI*fDiameter*fDiameter/4.0+PI*fXH*fDiameter;  //气缸顶部的当量面积

            fPQ = fNewP[iI+1]*fBarToPa;
            fDQ = CalculateFDQ(fPQ,fT,fXLM)/57.296;
//            fDQ = CalculateFDQ(fPQ,fT,fXLM);

//   在计算散热量时，是否应该在散热率上乘上计算间隔才能得到散热率呢
            fQW2 = fQW1 +fDQ*fH;      //散热量

//计算　Q，DQ/DCA　和X
            fE2 = CalculateTENB(fT2,fB2);
            fQF2 = fE2 - fE1 +fQW2 + fW2;    //fQF2是此步长内的放热量
            fDMF2 = fQF2/fHU;                //计算出来的这一步长内的喷油量
            fDQRCA = (fQF2 - fQF1)/fH;       //fDQRCA 为放热率
            ftemp = fabs(fDMF1 - fDMF2)/fDGF;
            fDMF1 = fDMF2;
            iIterNum ++;
        }while( (ftemp > 0.0001)&&(iIterNum<20));

        if(fDQMAX - fDQRCA<0.0)
        {
            fDQMAX = fDQRCA;
            fDQMMAX = fDQMAX*2.39e-4;
            fCADQMAX = fCA;
        }
        if(fabs(fDQRCA)>1000000.0)
        {
            fDQRCA = 0.0;
        }

        fDHDF[iI] = fDQRCA;
//        fP2 = fBarToPa*fNewP[iI+1];
//      fX = fDMF2/fDGF;
        fQF1 = fQF2;
        fTT[iI+1] = fT2;
        iI = iI +1;
        fX1 =fX2;
        fW1 = fW2;
        fQW1 = fQW2;
        fT1 = fT2;
        fV1 = fV2;
        fCY = fCY + 1.0;
        fDPRCA = fDPRCA*1.02e-5;
        iJK = iJK +1;
    }while( fCA <fFFFai[icEndPosi]);
    iEndFai = iI;
}

void __fastcall lDieselHRBP::GetHeatPeak(float* fdata, int ilen, float& fmax, float& ffai)
{
    //TODO: Add your source code here
    //寻找放热率最大值及其对应的曲轴转角　
    fmax = fdata[0];
    ffai = fFFFai[0];
    for(int i=1;i<ilen;i++)
    {
        if( fdata[i]>fmax )
        {
            fmax = fdata[i];
            ffai = fFFFai[i];
        }
    }
}

void __fastcall lDieselHRBP::GetFirstPeak(float * fdata, int ilen, float & fmax, float & ffai)
{
    //TODO: Add your source code here
        //TODO: Add your source code here
    //寻找放热率第一峰值及其对应的曲轴转角　
    fmax = fdata[0];
    ffai = fFFFai[0];
    for(int i=1;i<ilen;i++)
    {
        if(fFFFai[i]>0.0)
        {
            break;
        }
        if( (fdata[i]>fmax)&&
            (fdata[i]>fdata[i-1])&&
            (fdata[i]>fdata[i+1])
          )

        {
            fmax = fdata[i];
            ffai = fFFFai[i];
        }
    }
}

float __fastcall lDieselHRBP::GetfEn(bool bFrom,int iP,float fFre)
{
//    bool  bFrom: true:从通道1的测试数据中计算
//    int   iP :        通道标识     1：通道一   2：通道二   3:通道三
//    float fFre :      信号的采样频率
//    原始数据保存在f
//TODO: Add your source code here
    float fSpeed = 0.0;
    int  * ipData = NULL;
    switch( iP )
    {
        case 0:
        {
            ipData = ipOData[0];
            break;
        }
        case 1:
        {
            ipData = ipOData[1];
            break;
        }
        case 2:
        {
            ipData = ipOData[2];
            break;
        }
        default:
        {
            return 0.0;
        }
    }
    int   fmax = 0.0;
    int   iZeroMax = 0;
    int   istartposi,iendposi;
    int   iPosi,iPosi1, iPosi2,iPosi3;
    int   iMaxNum = 0;

    int   isWinLen = 1000;
    int   isStepLen = 200;
    int   ibacklimit;
    int   iAverage = 0;
    bool  bPosi1 = false,bPosi2 = false,bPosi3 = false;
    bool  bValue = false;
    int i,j;

    ibacklimit = isWinLen - 30;
    iendposi = 14000;
    if(iendposi > iOriginalLength)
    {
        iendposi = iOriginalLength;
    }
    for(int ii=0; ii<iendposi; ii += 10)
    {
        iAverage += ipData[ii];
        if( iZeroMax < ipData[ii] )
        {
            iZeroMax = ipData[ii];
        }
    }
    iAverage = iAverage * 10 /iendposi;
    if((iZeroMax - iAverage) < 500)    //用于判断是否含有有效数据,如果小于1500则认为不是有效数据
    {
    	fEn        = 0.0;
    	iSampleNum = 0;
    	iCycleNum  = 0;
		return  0.0;
    }
    iZeroMax = iAverage + ((iZeroMax - iAverage) *3)/5;
    for( i = 0; i < iOriginalLength - isWinLen; i += isStepLen) //(????????)
    {
        fmax = ipData[i];
        for( j = i; j< i + isWinLen; j += 4)        // (1) 由2改为4
        {
            if( ipData[j] > fmax ) //iZeroMax)
            {
                fmax = ipData[j];
                istartposi = j;
            }
        }
        if( ( istartposi < i + 30 )||( istartposi > i + ibacklimit ) )
        {
            continue;
        }
        if(fmax < iZeroMax)
        {
            continue;
        }
        if(istartposi < 2500)      //如果这个点位于2500以后，否则重新查找不太容易找到整个循环
        {
            continue;
        }
        if(!bValue)
        {
            iPosi = istartposi ;
            fmax = 0.0;
            bValue = true;
            iMaxNum = 1;
        }
        else
        {
            if(iPosi == istartposi)
            {
                iMaxNum ++;
                if(iMaxNum < 2)   //此处的判断是用于这个峰值至少应出现3次才行
                {
                    continue;
                }
                if(!bPosi1)
                {
                    iPosi1 = istartposi;
                    bPosi1 = true;
                    bValue = false;
                    fmax = 0;
                    iMaxNum = 0;
                    i += isWinLen*2;
                }
                else if(!bPosi2)
                {
                    iPosi2 = istartposi;
                    bPosi2 = true;
                    bValue = false;
                    fmax   = 0;
                    iMaxNum = 0;
                    i += isWinLen*2;
                }
                else if(!bPosi3)
                {
                    iPosi3 = istartposi;
                    bPosi3 = true;
                    bValue = false;
                    iMaxNum = 0;
                    break;
                }
            }
            else
            {
                iPosi = istartposi;
            }
        }
    }
    if(bPosi1&&bPosi2&&bPosi3)
    {
        fSpeed = 240.0/((float)(iPosi3 - iPosi1)/fFre);
        fTimeInterval = 1000.0/fFre;
        fAngleStep = 6.0*fSpeed*fTimeInterval/1000.0;    //近似计算曲轴转角间隔
        AccuratePosi(0,iPosi1, iPosi3);
        fSpeed = 240.0/((float)(iPosi3 - iPosi1)/fFre);
        iCycleNum = (iPosi3 - iPosi1)/2;
    }
    else if( bPosi1 && bPosi2)
    {
        fSpeed = 120.0/((float)(iPosi2 - iPosi1)/fFre);
        fTimeInterval = 1000.0/fFre;
        fAngleStep = 6.0*fSpeed*fTimeInterval/1000.0;    //近似计算曲轴转角间隔
        AccuratePosi(0,iPosi1, iPosi2);
        fSpeed = 120.0/((float)(iPosi2 - iPosi1)/fFre);
        iCycleNum = iPosi2 - iPosi1;
    }
    else
    {
        fSpeed = -10.0;
        iCycleNum = 0;
    }
    fEn = fSpeed;
    if(fEn > 100.0)
    {
        IHALFLENGTH = iCycleNum/2;
        iaStartPosi = iPosi1 - IHALFLENGTH;
        if(iaStartPosi <0)
        {
            iaStartPosi = iPosi2 - IHALFLENGTH;
        }
        iAbstractLength = iCycleNum;
        iAbStartPosi    = iaStartPosi;
//      计算转速、时间间隔、每个采样点对应的曲轴转角(近似值)
        fEngineSpeed = fSpeed;
        fTimeInterval = 1000.0/fFre;   //单位是：毫秒
        fAngleStep = 6.0*fEngineSpeed*fTimeInterval/1000.0;
    }
    return fSpeed;
}

void __fastcall lDieselHRBP::AccuratePosi(int ip, int& iposi1, int & iposi2)
{
    //TODO: Add your source code here

// 对波形相似的位置进行准确定位
// ip : 通道号
// iposi1:第一个最大值的位置
// iposi2:第二个最大值的位置

//    float fSpeed = 0.0;
    int * iOData = NULL;
    switch( ip )
    {
        case 0:
        {
            iOData = ipOData[0];
            break;
        }
        case 1:
        {
            iOData = ipOData[1];
            break;
        }
        case 2:
        {
            iOData = ipOData[2];
            break;
        }
        default:
        {
            return;
        }
    }
    int istart1, iend1,istart2,iend2;
//    float fdis[200];
    float fdis[60];
    float fsum,ftemp;
//  istart1 = iposi1 - 400;
//    iend1   = istart1 + 600;
//    istart2 = iposi2  - 300;
//    iend2   = istart2 + 600;

    istart1 = iposi1  - (int)(33.0/fAngleStep + 0.5);
    istart2 = iposi2  - (int)(30.0/fAngleStep + 0.5);
    for(int i=0;i<60;i++)
    {
        fsum = 0.0;
        for(int j=i;j<150+i;j++)
        {
            ftemp = iOData[istart1 + j] - iOData[istart2 + j-i];
            fsum += ftemp*ftemp;
        }
        fdis[i] = fsum;
    }
    ftemp = fdis[0];
    iend1 = 0;
    for(int i=0; i<60; i++)
    {
        if(ftemp > fdis[i])
        {
            ftemp = fdis[i];
            iend1 = i;
        }
    }
    iposi2 = iposi2 + (iend1 - 30);
}


bool __fastcall lDieselHRBP::AbstractData(void)
{
    //TODO: Add your source code here
//  从当前数据中提取有效的压力信号，每成功执行一性，它将提取的数据
//　保存在fAP0数组中，并把它累加到fOldP中
//  返回值：true 表示成功提取了一个有效数据
//  　　　　false :表示已无法从原始数据中提出数据，并对累积的数据求平均

    int i;
    float ftemp;
    bool bGetOne = false;
    int iStart,iEnd;
    do
    {
        if((iAbStartPosi+iAbstractLength)>iOriginalLength)
        {
            bGetOne = false;
            break;
        }
        ftemp = ipOData[0][iAbStartPosi];
        iStart = iAbStartPosi+1;
        iEnd = iAbStartPosi + 2*IHALFLENGTH;
        for(i = iStart; i<iEnd;i++)
        {
            if(ftemp<ipOData[0][i])
            {
                ftemp = ipOData[0][i];
                iposi = i;
            }
        }
        if(iposi+(iAbstractLength-IHALFLENGTH)>iOriginalLength)
        {
            bGetOne = false;
            break;
        }
        if(iposi>IHALFLENGTH)
        {
            bGetOne = true;
            for(i = 0; i<iAbstractLength;i++)
            {
                ipAData[0][i] = ipAData[0][iposi - IHALFLENGTH + i];
                ipAData[1][i] = ipAData[1][iposi - IHALFLENGTH + i];
                ipAData[2][i] = ipAData[2][iposi - IHALFLENGTH + i];
            }
            fAbMax = ftemp;
            if(iSampleNum == 0)
            {
                fAbMax = ftemp;
                for(i = 0; i<iAbstractLength;i++)
                {
                    ipACData[0][i] = ipAData[0][i];
                    ipACData[1][i] = ipAData[1][i];
                    ipACData[2][i] = ipAData[2][i];
                }
                iSampleNum ++;
                iTDPosi = iposi - iAbStartPosi;  //暂时将上止点位置定在最大压力位置
//                fAbMMax[0] = ftemp;
            }
            else
            {
                int ibyposi;
                float fratio;
                fratio = (fAbMax - ftemp)/fAbMax;
//                fAbMMax[iSampleNum] = ftemp;
                ibyposi = DetectPosi();
                if( fabs(fratio)<0.5)   //剔除突变的压力值
                {
                    int iposition;
                    for(i=0;i<iAbstractLength;i++)
                    {
                        iposition = iposi - IHALFLENGTH + ibyposi + i;
                     //   iposition = iAbStartPosi + ibyposi + i;
                        ipACData[0][i]  += ipOData[0][iposition];
                        ipACData[1][i]  += ipOData[1][iposition];
                        ipACData[2][i]  += ipOData[2][iposition];
                    }
                    iSampleNum++;
                    fAbMax = (fAbMax + ftemp)/2.0;
                }
                else
                {
                    bGetOne = false;
                }
            }
        }
        else
        {
            bGetOne = false;
        }
//        iAbStartPosi = iposi+IHALFLENGTH;
        iAbStartPosi += iAbstractLength;
    }while(!bGetOne);
    if(!bGetOne)
    {
        if(iSampleNum !=0)
        {
            for(i=0;i<iAbstractLength;i++)
            {
                ipACData[0][i] /= (float)iSampleNum;
                ipACData[1][i] /= (float)iSampleNum;
                ipACData[2][i] /= (float)iSampleNum;
            }
        }
    }
    return bGetOne;
}

int __fastcall lDieselHRBP::DetectPosi(void)
{
    //TODO: Add your source code here
//  通过计算相似性来判断不同样本之间的差异
//  此函数返回相似点距最大值点的偏移量
//  所用的参数
//  fAP0 　被提出来的当前样本数据
//  fOldP　累积的各个样本的总和
//  返回值　： 相似点距最大值点的偏移量
    float fTry[ICOLENGTH];
    float ftemp ,fsum;
    int iiiposi;
    int istart,iend;
    int istep;

    for(int i=0; i<ICOLENGTH; i++)
    {
        fsum = 0.0;
        for(int j=0;j<2*IHALFWINDOW;j++)
        {
            istep = IHALFLENGTH - IHALFWINDOW + j;
            ftemp =(ipAData[0][istep+i-ICOLENGTH/2] - ipACData[0][istep]/(float)iSampleNum);
            fsum += ftemp*ftemp;
        }
        fTry[i] = fsum;
    }
    ftemp = fTry[0];
    iiiposi = 0;
    for(int i=1;i<ICOLENGTH;i++)
    {
         if(ftemp > fTry[i])
         {
            ftemp = fTry[i];
            iiiposi = i;
         }
    }
    return iiiposi - ICOLENGTH/2;
}



void __fastcall lDieselHRBP::DetectTopDeadPosi(void)
{
//TODO: Add your source code here
//  此时 公有变量 iTDPosi 中保存着最大值所在的位置
//       公有变量 fEngineSpeed 中保存着柴油机的转速
//       公有变量 fTimeInterval 中保存着每一个采样点的时间间隔  毫秒
//       公有变量 fACP2数组中保存着压力升高率的100倍值
// 根据经验，纯压缩过程的最大值出现在上止点前约16度的样子

    if(iSampleNum == 0)   //由于没有提取有效数据，所以不再计算各个参数
    {
        bParameterAbstracted = false;
        return;
    }
//函数功能：根据压缩过程的特征计算上止点的位置；

//TODO: Add your source code here
//  此时 公有变量 iTDPosi 中保存着最大值所在的位置
//       公有变量 fEngineSpeed 中保存着柴油机的转速
//       公有变量 fTimeInterval 中保存着每一个采样点的时间间隔  毫秒
//       公有变量 fACP2数组中保存着压力升高率的100倍值
// 根据经验，纯压缩过程的最大值出现在上止点前约16度的样子

    int iDPMaxPosi;
    int inumber;
    int iNowPosi,iNowPosi1,iNowPosi2;
    int istartposi,iendposi;
    int iposi;
    int iognum;
    int iITNum;
    int istPosi,ienPosi;
    int i;
    int ii,jj;
    int inum;
    int ii1,ii2,ii3;

    float ftemp;
    float fdpmax;              //压力升高率的最大值
    float fstep;
    float fmax;
    float fDPMAngle;           //压力升高率局部极大值出现的位置
    float fbuffer1[300];
    float forarray[300];
    float forBackup[300];
    float fdpdfdf[400];
    float ffNowAngle;
    float ffPreAngle;
    float ffNextAngle;
    int   iMaxPosi1,iMaxPosiAll;
    float fntemp;
    float ftopangle;
    float fLevel09;
    float fLevel05;

    bool  bLocalMaxExist = false;
    bool  bLocalMinExist = false;
    int   iLocalMaxPosi  ;
    float fLocalMin = 0.0;
    int   iZeroPosi ;
    float fMeanSlope;
    

//    istartposi = iAbstractLength/3;
//    iendposi   = iAbstractLength*2/3;
//    ftemp      = fpDPDF[istartposi];
//    iTDPosi = fCPMaxPosi;  //压力最大值所在位置

//=====================================================================
//fAngleStep   每一个采样点间隔曲轴转过的角度
//inumber    大致到达容积最大点的位置iNowPosi

//    inumber   = (int)(16.0/fAngleStep);
    iNowPosi1  = fDPDFMaxPosi;

//iNowPosi中保存的是估计的纯压缩过程变化率最大的位置
//以下得到压升率最大值及其所在位置
    int iLevel09StartPosi;
    fLevel09 = fDPDFMax*0.8;
    ii1 = fDPDFMaxPosi;
    ii2 = fDPDFMaxPosi;
    do
    {
        ii1 --;
    }while(fpDPDF[ii1] > fLevel09);

    do
    {
        ii2 ++;
    }while(fpDPDF[ii2] > fLevel09);
    iLevel09StartPosi = ii1;

    fLevel09 = (ii2 - ii1)*fAngleStep;

    fLevel05 = fDPDFMax*0.5;
    do
    {
        ii1 --;
    }while(fpDPDF[ii1] > fLevel05);
    do
    {
        ii2 ++;
    }while(fpDPDF[ii2] > fLevel05);
    fLevel05 = (ii2 - ii1)*fAngleStep;

    if(  (fLevel05 < 20.0)           //在纯压缩状态时，50%时角为29度
       ||(fLevel09 < 5.0)            //在有燃烧时，　　90%时角度大约为2度
       )   //都是有燃烧的过程
    {
	    istartposi = iNowPosi1 - (int)(30.0/fAngleStep);
//    	iendposi   = iNowPosi1; // - (int)(0.5 /fAngleStep);
//        iendposi = iLevel09StartPosi;      //2005_01_27
        iendposi   = fDPDFMaxPosi;
    }
    else if(   (fLevel05>30.0)
             &&(fLevel09 > 11.0)
           )
    {
	    istartposi = iNowPosi1 - (int)(30.0/fAngleStep);
//    	iendposi   = iNowPosi1; // - (int)(0.5 /fAngleStep);
        iendposi = iLevel09StartPosi;
    }
    else                   //如果没有燃烧过程则往后取
    {
	    istartposi = iNowPosi1 - (int)(4.0/fAngleStep);
    	iendposi   = iNowPosi1 + (int)(4.0/fAngleStep);

    }

//寻找压力升高率的局部极大值
    int iZeroNumber = 0;    //压力升高率的过零次数
	iposi = istartposi;
	fdpmax = fpDPDF[istartposi];
    for(i=istartposi+1; i<iendposi-1; i++)
    {
        fdpdfdf[i - istartposi] = fpDPDF[i+1] - fpDPDF[i];
    	if(  (fpDPDF[i] > fpDPDF[i-1])
    	   &&(fpDPDF[i] > fpDPDF[i+1])
    	  )
    	{
    		if(fdpmax < fpDPDF[i])
    		{
                iZeroNumber ++;
    			fdpmax = fpDPDF[i];
    			iposi  = i;
    		}
    	}
        else if(  (fpDPDF[i] < fpDPDF[i-1])
    	        &&(fpDPDF[i] < fpDPDF[i+1])
           )
        {
            iZeroNumber ++;
        }
    }
    fDPDFLocalMax     = fdpmax;
    ftemp = fdpdfdf[1];
    istPosi = istartposi + 1;

    for( i = istartposi + 1; i<iendposi-1; i++)
    {
        if(ftemp > fdpdfdf[i - istartposi])
        {
            ftemp = fdpdfdf[i - istartposi];
            istPosi  = i;   // 压力升高率变化最小值点 ,其实也是局部极小值
        }
    }
    
    if( fabs(fDPDFLocalMax) < 0.000001)
    {
        fDPDFLocalMax = 1.0;
    }

    if(ftemp >0)  //如果没有出现局部极大值，
    {
        iposi = istPosi;
        bLocalMaxExist = false;
    }
    else  if(iZeroNumber >= 2)    //局部极小值不在边上
    {
        bLocalMaxExist = true;
        bLocalMinExist = true;
        iLocalMaxPosi  = iposi;
    }
    else
    {
        bLocalMaxExist = true;
        iLocalMaxPosi  = iposi;
    }

    iZeroPosi = iposi;

// 局部极大值找到以后，再重新判断是否有燃烧过程
    if(!bLocalMinExist)    //如果没有压力升高率局部极小值
    {
        do
        {
            iZeroPosi ++;
        }while(fpDPDF[iZeroPosi] > 0.0);

        int iiii;
        float fsintemp,fsumtemp = 0.0;
        if(   ((iZeroPosi - iLocalMaxPosi) > 300)
            ||((iZeroPosi - iLocalMaxPosi) < 0)
           )
        {
            iLocalMaxPosi = iZeroPosi - 300;
            if(iLocalMaxPosi < 0)
            {
                iLocalMaxPosi = 0;
            }
        }
        for(int im = iLocalMaxPosi; im < iZeroPosi; im ++)
        {
            iiii = im - iLocalMaxPosi;
            forarray[iiii] = 0.0;
            for(int in = im - 10; in < (im + 10); in ++)
            {
                forarray[iiii] += fpDPDF[in];
            }
            forarray[iiii] /= 20.0;
            fsintemp = forarray[iiii] - fpDPDF[im];
            fsumtemp += fsintemp*fsintemp;
        }
        fsumtemp *= 10000.0;
        fsumtemp /= (float)(iZeroPosi - iLocalMaxPosi);
        fMeanSlope = fpDPDF[iLocalMaxPosi]/(float)(iZeroPosi - iLocalMaxPosi);
        if(  fsumtemp > 0.07 )   //是有燃烧的过程
        {
        	bCombustion = true;//是燃烧过程
        }
        else                   //如果没有燃烧过程则往后取
        {
    	    bCombustion = false;//是压缩过程
        }
    }
    else
    {
        bCombustion = true;
    }

    if(!bCombustion)
    {
        iNowPosi1 = fDPDFMaxPosi + (int)(10.0/fAngleStep);    //iNowPosi1中保存的是最大压力所在位置
    }

//    iNowPosi1 = fDPDFMaxPosi;
//  从下面开始，iposi中保存着压力升率局部极大值
                               //从当前曲轴转角前35度开始查找，
//    fdpmax = fDPDFMax/2.0;  //用压力升高率最大值的一半来归一化数据

    for(i = 300; i >0; --i)   //上止点前60度至0度
    {
        ffNowAngle = (float)(i+1)/5.0;     //生成0.2度一个间隔
        istPosi    = iNowPosi1 - (int)(ffNowAngle/fAngleStep);
        ienPosi    = istPosi + 1;
        ffPreAngle  = (float)(iNowPosi1 - istPosi)*fAngleStep;
// ffNextAngle = (float)(iNowPosi1 - ienPosi)*fAngleStep;
// 采用的梯形差值计算相应角度上的压力变化率
		ftemp = (fpDPDF[ienPosi] - fpDPDF[istPosi])/fAngleStep;
        forBackup[300-i] = fpDPDF[istPosi] + (ffNowAngle - ffPreAngle)*ftemp;
    }
/*
    FILE *fileDPDF;
    fileDPDF = fopen("e:\\dpdf01.txt","w");
    if(fileDPDF != NULL)
    {
        for(i = 0; i< iAbstractLength; i++)
        {
            fprintf(fileDPDF,"%d %.4f\n",i,fpDPDF[i]);
        }
        fclose(fileDPDF);
    }
*/

//inum是模板数据的长度,fModal[]是模板数据，同时也是全局变量
//    inum = 146;    //修改前
    inum = 66;       //修改后

//根据相关分析判断压力升高率最大值的位置  r = 1.3
//    for(ii = 0; ii < 150; ii++)   //改前
    iITNum = 0;
    do
    {
        for( i = 0; i < 300; i++)
        {
            forarray[i] = forBackup[i]/fdpmax;       //将压力升高率归一化处理
        }
        for( ii = 0; ii<229; ii++)      //改后
        {
            fbuffer1[ii] = 0.0;
            for(jj = 0;jj<inum;jj++)
            {
                fntemp = fModal[jj] - forarray[jj + ii];
                fbuffer1[ii] += fntemp*fntemp;
            }
        }
//***********************************************************************
        FILE *fp;
        fp = fopen("e:\\fcorr.dat","w");
        for( int m = 0; m < 300; m ++)
        {
            fprintf(fp,"%d %.4f %.4f\n",m,forarray[m],fbuffer1[m]);
        }
        fclose(fp);
//**************************************************************************

        iMaxPosi1 = 0;
        fntemp = fbuffer1[0];
//    for( ii = 1; ii < 150; ii ++)   //改前
        for( ii = 1; ii < 229; ii++)
        {
            if((fbuffer1[ii - 1] > fbuffer1[ii])
              &&(fbuffer1[ii] < fbuffer1[ii+1]))
            {
                if(fntemp > fbuffer1[ii])
                {
                    iMaxPosi1 = ii;
                    fntemp = fbuffer1[ii];
                }
            }
        }
        iMaxPosiAll = iMaxPosi1;        //这个位置与上止点之间的距离是35度
//从压力升高率最大值处向前取60度         //去掉了60个数据，实际上是从上止点前44度开始的
//模板是从上止点前56度开始取的，iNowPosi1 - (44 - (60 - ftopanle))/fAngleStep;
//        ftopangle =  (float)iMaxPosiAll/5.0 - 25.0;   //考虑损失后将加上损失角6度，
        iTDPosi   = iNowPosi1 + (fAllAngle - (300 - iMaxPosiAll)*0.2)/fAngleStep;
//        iTDPosi = iNowPosi1 + ftopangle/fAngleStep;

        fDPMAngle = (float)(iTDPosi - iposi)*fAngleStep;   //应出现在上止点前16度左右

        if((fDPMAngle > (fDeltaAngle + 0.3))||(fDPMAngle < (fDeltaAngle - 0.3)))
        {
            if(iITNum > 10)                                    //如果迭代10还不收敛，则退出
            {
                break;
            }
            else
            {
                 if(!bLocalMaxExist)   //如果不存在压力升高率的局部极大值
                 {
                    iposi  = iTDPosi - (8.0 + fDPMAngle/2.0)/fAngleStep;  //修正后的压力升高率局部极大值位置
                    fdpmax = fpDPDF[iposi];
                    iITNum ++;
                 }
                 else
                 {
                    iTDPosi = iNowPosi1 + (fAllAngle - (300 - iMaxPosiAll)*0.2)/fAngleStep;
                    break;
                 }
            }
        }
        else
        {
            break;                                         //如果满足条件，则退出
        }
    }while(1);     //如果小于15度或大于17度则迭代计算


    if(bCombustion) //如果是燃烧过程,则计算燃烧始点、及供油始点
    {
    //计算燃烧提前角度，实际是压力升高率突然增大的角度至上止点的位置
        ii1 = iLocalMaxPosi;
        if(bLocalMaxExist)
        {
            iposi = iLocalMaxPosi;
        }
//        ii1 = iposi;
        fLocalMin = fpDPDF[iposi];
//        im        = iposi;
        for(int im = ii1; im < (int)fDPDFMaxPosi; im ++)
        {
            if(   (fpDPDF[im - 1] > fpDPDF[im])
                &&(fpDPDF[im + 1] > fpDPDF[im])
               )
            {
                if(fpDPDF[im] < fLocalMin)
                {
                    fLocalMin     = fpDPDF[im];
                    iposi = im;
                }
            }
        }
        if( (iposi - ii1) < 2)  //如果没有找到最小值
        {
            for(int im = ii1 ; im < iZeroPosi; im ++)
            {
                fdpdfdf[im - ii1] = fpDPDF[im + 1] - fpDPDF[im];
            }
            float ftemp10;
            ftemp10 = fdpdfdf[20];
            for(int im = ii1 + 20; im < iZeroPosi - 20; im ++)
            {
                if( fdpdfdf[im - ii1] > ftemp10)
                {
                    iposi = im;
                    ftemp10 = fdpdfdf[im - ii1];
                }
            }
            //这样就找到了最大值,然后再往回找，找到最小值
            iposi -= 10;
            do
            {
                iposi --;
            }while(fdpdfdf[iposi - ii1] > fdpdfdf[iposi - ii1 - 1]);
        }

        fCombustionAngle = (iposi - iTDPosi)*fAngleStep;

//以下用于寻找供油始点,原则是当其值增加到一半时，认为开始喷油
        if(   (LFHS.siPassageStatus[1] == 1)  //如果通道二是处于打开状态，
//            &&(iSignalSource[1] == 2)  //并且是油管压力
          )
        {
	        istartposi = iTDPosi - 35.0/fAngleStep;
    	    iendposi   = iTDPosi - 1.0/fAngleStep;
        	iDPMaxPosi = ipACData[1][istartposi];
	        iposi = istartposi;
    	    for( ii = istartposi + 1; ii < iendposi; ii += 2)
        	{
            	if(iDPMaxPosi < ipACData[1][ii])    //寻找最大值
	            {
    	            iDPMaxPosi = ipACData[1][ii];
        	    }
	        }
    	    iDPMaxPosi /= 2;     //以0.5时为基准
        	iposi = istartposi;
	        do
    	    {
        	    iposi ++;
	        }while(ipACData[1][iposi] < iDPMaxPosi);
    	    fOilAngle = (iposi - iTDPosi)*fAngleStep;
        }
    }
    iTDPosiBackup = iTDPosi;
    iTDCStep      = 0;
}

void __fastcall lDieselHRBP::DetectTopDeadPosi_New(void)
{
//函数功能：根据压缩过程的特征计算上止点的位置；
//  此时 公有变量 iTDPosi 中保存着最大值所在的位置
//       公有变量 fEngineSpeed 中保存着柴油机的转速
//       公有变量 fTimeInterval 中保存着每一个采样点的时间间隔  毫秒
//       公有变量 fACP2数组中保存着压力升高率的100倍值
// 根据经验，纯压缩过程的最大值出现在上止点前约16度的样子
// 利用变化量来判断是否有燃烧过程

//----------------------------------------------------------
// 2005_02_18的结论
// ***　对上止点位置影响较大的是　fAllAngle 的大小.
//==========================================================

    if(iSampleNum == 0)   //由于没有提取有效数据，所以不再计算各个参数
    {
        bParameterAbstracted = false;
        return;
    }
    iCombustionPosi  = 0;          //燃烧始点
    iOilPosi         = 0;                 //供油始点

    int iDPMaxPosi;
    int inumber;
    int iNowPosi,iNowPosi1,iNowPosi2;
    int istartposi,iendposi;
    int iposi;
    int icombustionposi;
    int iognum;
    int iITNum;
    int istPosi,ienPosi;
    bool bCombustionStart = false;
    int i;
    int ii,jj;
    int inum;
    int ii1,ii2,ii3;

    float ftemp;
    float fdpmax;              //压力升高率的最大值
    float fstep;
    float fmax;
    float fDPMAngle;           //压力升高率局部极大值出现的位置
    float fbuffer1[300];
    float forarray[300];
    float forBackup[300];
    float fdpdfdf[600];
    float ffNowAngle;
    float ffPreAngle;
    float ffNextAngle;
    int   iMaxPosi1,iMaxPosiAll;
    float fntemp;
    float ftopangle;
    float fLevel09;
    float fLevel05;

//    bool  bLocalMaxExist = false;
//    bool  bLocalMinExist = false;
    int   iLocalMaxPosi  ;
//    float fLocalMin = 0.0;
    int   iZeroPosi ;
    float fMeanSlope;
    bool  bOver = true;
    bool  bdpdfdfmin = false;
    bTDPosiCalculated = false;  //先设上止点没有计算出来
//=====================================================================
//fAngleStep   每一个采样点间隔曲轴转过的角度
//inumber    大致到达容积最大点的位置iNowPosi

    iNowPosi1  = fDPDFMaxPosi; //iNowPosi中保存的是估计的纯压缩过程变化率最大的位置

   
//---------------------------------------------------------------------------------
//以下程序用于判断是否是含有燃烧过程
// 2005年02月17日
// 具体方法是将一段范围内的压力升高率取平均值，然后计算波动情况，大于1时认为有燃烧
//---------------------------------------------------------------------------------

    float fLevel03 = 0.03;
    int   iWin = 15;
    float fsummm[1000];
    ii1 = fDPDFMaxPosi;
    ii2 = fDPDFMaxPosi;


    float ftempt ,faverage = 0.0;
//--------------------------------------------
// 压力升高率达到0.05时的位置，用于帮助定位
    int iLevel005;
    bool bLevel005Valid = true;
    iLevel005 = iAbstractLength/4;
    do
    {

        iLevel005 ++;
        if(iLevel005 == iAbstractLength)
        {
            bLevel005Valid = false;
            break;
        }
    }while(fpDPDF[iLevel005] < 0.04);
    if(!bLevel005Valid)
    {
        return;     //表明此时的数据无效
    }
//=============================================
//------------------------------------------------------------
// 以下用于判断是否有燃烧过程
// 取燃烧过程的0.03至下降为0的曲轴转角范围进行燃烧判断

    do
    {
        ii1 --;
        if(ii1 <= 0 )
        {
            return;
        }
    }while(fpDPDF[ii1] > fLevel03);
    do
    {
        ii2 ++;
        if( ii2 == iAbstractLength)
        {
            return;
        }
    }while(fpDPDF[ii2] > 0.0);  // fLevel03;
    ii3 = ii2 + (int)(20.0/fAngleStep);
    if(ii3 - ii1 > 1000)
    {
        ii1 = ii3 - 1000;
    }
    for( int i = ii1; i < ii3; i++)
    {
        fsummm[ i - ii1] = 0.0;
        for(int j = i - iWin; j <= i + iWin; j++)
        {
            fsummm[i - ii1] += fpDPDF[j];
        }
        fsummm[i - ii1] /= (float)(2*iWin + 1);
    }
    for(int i = ii1; i < ii2; i++)
    {
        ftempt = fpDPDF[i] - fsummm[i-ii1];
        faverage += ftempt*ftempt;
    }
    fDetect  = faverage*10000.0;
    faverage = 0.0;
    for(int i = ii2; i < ii3; i++)
    {
        ftempt = fpDPDF[i] - fsummm[i-ii1];
        faverage += ftempt*ftempt;
    }
    
//--------------------------------------------------------------
//2005年0916日 如果燃烧过于滞后，再加上附加判断
// 　加上了对后燃烧过程的判断
    faverage *= 10000.0;
    ftempt = COMBUSTION_LEVEL*2.0/3.0;
//=======================================================
    if(  (fDetect < COMBUSTION_LEVEL) //当计算结果小于1.5时，认为是纯压缩过程
       &&(faverage < ftempt)
    )
    {                            //否则认为是有燃烧过程
        bCombustion = false;
    }
    else
    {
        bCombustion = true;
    }
    if( faverage > fDetect )
    {
        LFHS.fCombustionLevel = faverage;
    }
    else
    {
        LFHS.fCombustionLevel = fDetect;
    }
    LFHS.COMBUSTION_LEVEL = COMBUSTION_LEVEL;

// 燃烧始点的判断
    if(bCombustion)
    {
        for( int i = ii1; i < ii3; i++)
        {
            fsummm[i - ii1] = (fpDPDF[i] - fsummm[i - ii1])*200.0;
        }
        ii2 = 0;
        ftempt = fsummm[0];
        for( int i = 1; i < ii3 - ii1; i++)
        {
            if(fsummm[i] > 1.0)
            {
                break;
            }
            if( fsummm[i] > ftempt)
            {
                ftempt = fsummm[i];
                ii2    = i;
            }
        }
        do
        {
            ii2 --;
            if( ii2 <= 0)
            {
                break;
            }
        }while( fsummm[ii2] > fsummm[ ii2 - 1]);
        ii2 = ii2 + ii1;     //ii3保存的是燃烧始点
    }
// 在调试的时候可以用于判断压力升高率的变化过程
/*
#ifdef  SELF_DEBUG
        FILE* fp;
        AnsiString strTemp;
        strTemp = FormMain->strExeFilePath + "Debug\\dpchange.dat";
        if((fp = fopen(strTemp.c_str(), "w")) != NULL)
        {
           for(int i = ii1; i < ii3; i ++)
           {
              fprintf( fp, "%d %.5f %.5f\n", i, fpDPDF[i], fsummm[i - ii1]);
           }
           fclose(fp);
        }
#endif
*/
    ii3 = ii2;     //在燃烧状态下，ii3中保存着燃烧始点
/*
    do
    {
        ii1 --;
        if(ii1 == 0)
        {
            return;
        }
    }while(fpDPDF[ii1] > fLevel03);
    do
    {
        ii2 ++;
        if( ii2 == iAbstractLength)
        {
            return;
        }
    }while(fpDPDF[ii2] > 0.0);  // fLevel03;

    if(ii2 - ii1 > 1000)
    {
        ii2 = 1000 + ii1;
    }
    for( int i = ii1; i < ii2; i++)
    {
        fsummm[ i - ii1] = 0.0;
        for(int j = i - iWin; j <= i + iWin; j++)
        {
            fsummm[i - ii1] += fpDPDF[j];
        }
        fsummm[i - ii1] /= (float)(2*iWin + 1);
    }
    for(int i = ii1; i < ii2; i++)
    {
        ftempt = fpDPDF[i] - fsummm[i-ii1];
        faverage += ftempt*ftempt;
    }

    fDetect  = faverage*10000.0;
//--------------------------------------------------------------
//2005年0916日 如果燃烧过于滞后，再加上附加判断
// 　加上了对后燃烧过程的判断
    ii1      = ii2 + 20.0/fAngleStep;
    for( int i = ii2; i < ii1; i++)
    {
        fsummm[i - ii2] = 0.0;
        for( int j = i - iWin; j <= i + iWin; j++)
        {
            fsummm[i - ii2] += fpDPDF[j];
        }
        fsummm[i - ii2] /= (float)(2*iWin + 1);
    }
    faverage = 0.0;
    for( int i = ii2; i< ii1; i++)
    {
        ftempt = fpDPDF[i] - fsummm[ i - ii2];
        faverage += ftempt*ftempt;
    }
    ftempt = COMBUSTION_LEVEL*2.0/3.0;
    faverage *= 10000.0;
//=======================================================
    if(  (fDetect < COMBUSTION_LEVEL) //当计算结果小于1.5时，认为是纯压缩过程
       &&(faverage < ftempt)
    )
    {                            //否则认为是有燃烧过程
        bCombustion = false;
    }
    else
    {
        bCombustion = true;
    }
    if( faverage > fDetect )
    {
        LFHS.fCombustionLevel = faverage;
    }
    else
    {
        LFHS.fCombustionLevel = fDetect;
    }
    LFHS.COMBUSTION_LEVEL = COMBUSTION_LEVEL;
// 燃烧始点的判断
    ii2 = ii1;
    ii1 = iLevel005;
    if(ii2 - ii1 > 1000)
    {
        ii1 = ii2 - 1000;
    }
    for( int i = ii1; i < ii2; i++)
    {
        fsummm[ i - ii1] = 0.0;
        for(int j = i - iWin; j <= i + iWin; j++)
        {
            fsummm[i - ii1] += fpDPDF[j];
        }
        fsummm[i - ii1] /= (float)(2*iWin + 1);
    }
    ii1 = i
*/
//===================================================

//----------------------------------------------------
// 2005年02月18日　
// 以下用于初步估计压力升高率局部极大值和上止点的位置
//----------------------------------------------------
    int iLevel09StartPosi;
    fLevel09 = fDPDFMax*0.9;
    ii1 = fDPDFMaxPosi;
    ii2 = fDPDFMaxPosi;
    do
    {
        ii1 --;
        if(ii1 < iLevel005)    //如果到了这一点还没有找到
        {
            return;
        }
    }while(fpDPDF[ii1] > fLevel09);

    do
    {
        ii2 ++;
        if(ii2 == iAbstractLength)
        {
            return;
        }
    }while(fpDPDF[ii2] > fLevel09);

    int iMiddle;
//    float fMinValue;
    float fPeakValue = 0.15;
    bool  bLowPositive = false;   //如果最小值处的值大于零，则此处可认为压力率局部极大值
    if((LFHS.siTrainType == 4)    //8B
     ||(LFHS.siTrainType == 5)  //11
     ||(LFHS.siTrainType == 9)
     )
    {
        fPeakValue  = 0.07 + (fEn - 400.0)/8000.0;
    }
    else
    {
        fPeakValue  = 0.06 + (fEn - 430.0)/7500.0;
    }
    iMiddle = (ii2 + ii1)/2;     //将此处做为纯压缩的局部最大值位置

//    fLevel09 = (ii2 - ii1)*fAngleStep;
    fLevel09 = fDPDFMax * 0.99;

    if(bCombustion)   //在有燃烧时，　　90%时角度大约为2度都是有燃烧的过程
    {
	    istartposi = fDPDFMaxPosi - (int)(40.0/fAngleStep);
        if(istartposi < 0)
        {
            return;
        }
        iendposi   = istartposi;
        if(fDPDFMax > fPeakValue)   //如果最大压力升高率大于0.3
        {
            bOver  = true;
            do
            {
                 iendposi ++;
                 if( iendposi >= iAbstractLength)
                 {
                    return;
                 }
            }while(fpDPDF[iendposi] < fLevel09);
        }
        else
        {
            bOver = false;

            iendposi = fDPDFMaxPosi + (int)((20.0 - (fEn - 430.0)/57.0)/fAngleStep);
        }

        if(iendposi - istartposi > 600)
        {
            istartposi = iendposi - 600;
        }

        for(int i = istartposi; i< iendposi; i++)
        {
            fdpdfdf[i - istartposi] = fpDPDF[i+1] - fpDPDF[i];
        }

        ftemp = fdpdfdf[0];
        icombustionposi = 0;
        ii1 = iendposi - istartposi - 10;
        ii2 = iendposi - istartposi - 1;
//----------------------------------------------------------------
// 在调试的时候可以用于判断压力升高率的变化过程
/*
#ifdef  SELF_DEBUG
        AnsiString strTemp;
        strTemp = FormMain->strExeFilePath + "Debug\\dpdfdfold.dat";
        if((fp = fopen(strTemp.c_str(), "w")) != NULL)
        {
           for(int i = istartposi; i < iendposi; i ++)
           {
              fprintf( fp, "%d %.5f %.5f\n", i, fpDPDF[i], fdpdfdf[i - istartposi]*300.0);
           }
           fclose(fp);
        }
#endif
*/
//===================================================================

        for(int i = 10; i < ii1; i ++)
        {
            if(   (fdpdfdf[i] < fdpdfdf[i-1])
                &&(fdpdfdf[i] < fdpdfdf[i+1])
                &&(ftemp  > fdpdfdf[i])
              )
            {
                bdpdfdfmin       = true;
                ftemp            = fdpdfdf[i];
//                fMinValue        = fpDPDF[istartposi + i];
                icombustionposi  = i;
                bCombustionStart = true;
            }
        }

//---------------------------------------------
// 看来还要加上燃烧始点的判断方法

//=============================================

//---------------------------------------------------------------------------------
// 在测量东风4D时发现：在高负荷时，会出现与低转速时基本一样的压力升高率图形
// 即纯压缩部分的局部极大值要大于由于燃烧造成的压力升高率最大值
// 那应如何判断这一部分呢？
// 原来的程序无法正确确定纯压缩的局部最大值和燃烧开始始点
//=================================================================================
        if(ftemp > 0.0) // 如果最小值大于零，那么就认为最小值处就开始燃烧
        {

          if((LFHS.siTrainType == 4)    //8B
            ||(LFHS.siTrainType == 5)  //11
            ||(LFHS.siTrainType == 9)
          )
          {
            bLowPositive     = true;
            icombustionposi  += istartposi;
            bCombustionStart = true;
            bdpdfdfmin       = true;
            fdpmax           = fpDPDF[icombustionposi];
            fDPDFLocalMax    = fdpmax;
          }
          else
          {
//-------------------------------------------------------------------------------------
//下面这一段程序用于东风4D机车上止点的判定
//4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d

          //如果最大值大于0.1，则说明此时一定存在燃烧过程，但是否存在造成的压力突升，不清楚
//            if(fDPDFMax > 0.1 )
            if(  (fDPDFMax > 0.1)
               &&(fDPDFMax < 0.24)    // 最大值小于0.24时很可能是由于压缩压力得到的最大值
               )
            {

                istartposi = iendposi;           //此处向后移动560是因为在1000加载工况下有时压升率最大值出现在压缩阶段
                iendposi = istartposi + 560;
                for(int i = istartposi; i< iendposi; i++)
                {
                    fdpdfdf[i - istartposi] = fpDPDF[i+1] - fpDPDF[i];
                }

//----------------------------------------------------------------
// 在调试的时候可以用于判断压力升高率的变化过程
/*
#ifdef  SELF_DEBUG
//                FILE *fp;
//                AnsiString strTemp;
                strTemp = FormMain->strExeFilePath + "Debug\\dpdfdfnew.dat";
                if((fp = fopen(strTemp.c_str(), "w")) != NULL)
                {
                    for(int i = istartposi; i < iendposi; i ++)
                    {
                        fprintf( fp, "%d %.5f %.5f\n", i, fpDPDF[i], fdpdfdf[i - istartposi]*300.0);
                    }
                    fclose(fp);
                }
#endif
*/
//===================================================================
                ii1 = iendposi - istartposi;
                bool bEntered = false;
                int izeroNum  = 0;
                ftemp = fdpdfdf[10];
                for(int i = 10; i < ii1 - 10; i ++)
                {
                    if(   ((fdpdfdf[i+1] > 0.0)&&(fdpdfdf[i] < 0.0))
                        ||((fdpdfdf[i+1] < 0.0)&&(fdpdfdf[i] > 0.0))
                      )
                    {
                        izeroNum ++;
                    }
                    if(izeroNum == 2)
                    {
                        bdpdfdfmin       = true;
                        icombustionposi  = i;
                        bCombustionStart = true;
                        bEntered = true;
                        break;
                    }
                }
                if(bEntered)
                {
                    bLowPositive     = true;
                    icombustionposi  += istartposi;
                    bCombustionStart = true;
                    bdpdfdfmin       = true;
                    iendposi         = icombustionposi - 600;
                    if(iendposi < 0)
                    {
                        iendposi = 1;
                    }
                    ftemp = fpDPDF[icombustionposi];
                    iZeroPosi = icombustionposi - 10;
                    for(int i = icombustionposi -10 ; i > iendposi; i --)
                    {
                        if(ftemp < fpDPDF[i])
                        {
                            ftemp     = fpDPDF[i];
                            iZeroPosi = i;
                        }
                    }
                    fdpmax           = fpDPDF[iZeroPosi];
                    fDPDFLocalMax    = fdpmax;
                    bLowPositive     = false;
                }
                else
                {
                    bLowPositive     = true;
                    icombustionposi  += istartposi;
                    bCombustionStart = true;
                    bdpdfdfmin       = true;
                    fdpmax           = fpDPDF[icombustionposi];
                    fDPDFLocalMax    = fdpmax;
                }

            }
            else
            {
                bLowPositive     = true;
                icombustionposi  += istartposi;
                bCombustionStart = true;
                bdpdfdfmin       = true;
                fdpmax           = fpDPDF[icombustionposi];
                fDPDFLocalMax        = fdpmax;
            }
          }
//4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d

        }
        else
        {
            if(bdpdfdfmin)
            {
                if(!bOver)
                {
                    icombustionposi = 1;
                }
                int iZeroNum = 0;
                int itemp;
                float fdpdpValue[2];
                int   iposibackup[2];
                fdpdpValue[0] = 0;
                fdpdpValue[1] = 1;
                iposibackup[0] = ii2 - 1;
                iposibackup[1] = ii2 - 1;
                itemp = 0;
//-------------------------------------------------------
                ftemp = fpDPDF[istartposi];
                for(int i =  1; i < ii2-1; i++)
                {
                    if(ftemp < fpDPDF[istartposi + i])
                    {
                        ftemp = fpDPDF[istartposi + i];
                        itemp =  i;
                    }
                }
//=======================================================
//??????????????????????????????????????????????????????????????
//                itemp = icombustionposi - 10;
//20050908修改
//                for(int i = ii2 - 1; i > itemp; i-- )
                for( int i = itemp; i > 10; i--)
                {
                    if(   (fdpdfdf[i - 1] < 0.0)
                        &&(fdpdfdf[i] > 0.0)
                      )
                    {
/*
                         if(fpDPDF[istartposi + i] > 0.0)
                         {
                            iendposi = istartposi + i;
                            icombustionposi = iendposi;
                            bCombustionStart = true;
                            break;
                         }
*/
                        iendposi = istartposi + i;
                        icombustionposi = iendposi;
                        bCombustionStart = true;
                        iZeroNum ++;
                        iposibackup[iZeroNum - 1] = istartposi + i;
                        while( fdpdfdf[i] > fdpdfdf[ i - 1])
                        {
                            i--;
                            if(itemp > 0)
                            {
                                if(i == itemp) break;
                            }

                            else
                            {
                                if( i == 0) break;
                            }
                        }
                        fdpdpValue[ iZeroNum - 1] = fdpdfdf[i];

                    }
                    if( i== 0) break;
                    if(iZeroNum == 2)     //第一个点有的时候是并不由于燃烧引起的,但有的时候又是，怎么办?
                    {
                        break;
                    }
                }
                if(iZeroNum == 2)
                {
//????????????????????????????????????????
                    if(fdpdpValue[0] > fdpdpValue[1])
                    {
                        icombustionposi = iposibackup[1];
                    }
                    else
                    {
                        if(fdpdpValue[0] < - 0.005)
                        {
                            icombustionposi = iposibackup[1];
                        }
                        else
                        {
                            icombustionposi = iposibackup[0];
                        }
                    }
                }
                else if( iZeroNum == 1)
                {
                    icombustionposi = iposibackup[0];
                }
                if(!bCombustionStart)
                {
                    icombustionposi = iMiddle;
                    iendposi = iMiddle + (int)(10.0/fAngleStep);
                }

            }
            else
            {
                istartposi = fDPDFMaxPosi - (int)(10.0/fAngleStep);
                iendposi   = fDPDFMaxPosi + (int)(20.0/fAngleStep);
                ii2        = iendposi - istartposi;
                for( int i = istartposi; i < iendposi; i++)
                {
                    fdpdfdf[i - istartposi] = fpDPDF[ i + 1] - fpDPDF[i];
                }
                for( int i = 1; i < ii2; i ++)
                {
                    if(   (fdpdfdf[i - 1] < 0.0)
                        &&(fdpdfdf[i] > 0.0)      //原来此外为 fdpdfdf[i - 1] > 0.0)
                        &&(fpDPDF[istartposi + i] > 0.0)
                      )
                    {
                        icombustionposi = i + istartposi;
                        break;
                    }
                }
            }
        }
    }
    else                   //如果没有燃烧过程则往后取
    {
	    istartposi = iMiddle - (int)(4.0/fAngleStep);
    	iendposi   = iMiddle + (int)(4.0/fAngleStep);
        for(int i = istartposi; i< iendposi - 1; i++)
        {
            fdpdfdf[i - istartposi] = fpDPDF[i+1] - fpDPDF[i];
        }
    }

    if(bLowPositive)
    {
        iLocalMaxPosi = icombustionposi;
    }
    else
    {
        if(bCombustion&&bCombustionStart)  //如果是燃烧过程 ,则寻找压缩过程局部最大值的位置，即中心线
        {                                  //并且已找到了燃烧始点
//            ii1 = icombustionposi + istartposi;               //20050326
//------------------------------------------------------------------------
// 20050625 发现151第14缸的燃烧判断失误，加了以下判断，基本上可以，但不准
            if(
                (icombustionposi < 1000)
              &&(fEn < 700.0)
              )
            {
                icombustionposi = iAbstractLength/2 - 40;
            }
//=======================================================================
            ii1  = icombustionposi;
            float fvalue;
            fvalue = fpDPDF[ii1];
            if(fvalue < 0.05)  //如果此时的压力升高率小于0.045，则从0.04处开始
            {
                do
                {
                    ii1 --;
                    if(ii1 < iLevel005)
                    {
                        break;
                    }
                }while(fpDPDF[ii1] < 0.05);
                fvalue = fpDPDF[ii1];
            }
            do
            {
                ii1 --;
                if( ii1 <= 0) break;
            }while(fpDPDF[ii1] > fvalue);   //从ii1点向前，基本上都开始小于燃烧始点处的变化量
//            bLocalMaxExist = true;
            iLocalMaxPosi  = (ii1 + icombustionposi)/2;
            fdpmax         = fpDPDF[iLocalMaxPosi];
            fDPDFLocalMax  = fdpmax;
        }
        else
        {
//            bLocalMaxExist = true;
            iLocalMaxPosi  = iMiddle;
            fdpmax         = fpDPDF[iLocalMaxPosi];
            fDPDFLocalMax  = fdpmax;
        }
    }

    iNowPosi1 = iLocalMaxPosi + (int)(fDeltaAngle/fAngleStep);
                               //iNowPosi1 :初步计算得到的上止点位置
    iposi   = iLocalMaxPosi;
                               //iposi　   :压力升高率局部极大值的位置
    icombustionposi = ii3;
// 最新加入的部分，现在为止，仪器内还没有添加这一算法
// 最后再仔细核实一下数据是否正确
//???????????????????????????????????????????????????????????????????????????????????
    if(  (fCPMaxPosi - iposi   > 30.0/fAngleStep)        //如果不能满足这个条件，那么上止点的位置肯定错了
        ||(fCPMaxPosi - iposi  < 14.0/fAngleStep)
      )
    {
        iposi         = fCPMaxPosi - 25.0/fAngleStep;
        iLocalMaxPosi = iposi;
        iNowPosi1     =  iLocalMaxPosi + (int)(fDeltaAngle/fAngleStep);
        fdpmax        = fpDPDF[iposi];
    }
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
/*
//-------------------------------------------------------------------------------
//试验部分
//根据气缸压力最大值的位置初步设定一个局部极大值位置，然后再通过迭代的方法来求角
//通过实际计算发现：在判断压缩过程还是误差比较大的
// 2005年09月08日
    iposi         = fCPMaxPosi - 20.0/fAngleStep;
    iLocalMaxPosi = iposi;
    iNowPosi1     =  iLocalMaxPosi + (int)(fDeltaAngle/fAngleStep);
    fdpmax        = fpDPDF[iposi];
// 试验部分
//===============================================================================
*/
//--------------------------------------------------------------
// 如果不进行相关分析，那么下面这句话就可以计算出上止点了
//    iTDPosi   = iLocalMaxPosi + fDeltaAngle/fAngleStep;
// 计算用于相关分析的模板，0.2度一个数据,共计算300个
//==============================================================
    float ffftemp;
    for(i = 300; i >0; --i)   //上止点前60度至0度
    {
        ffNowAngle = (float)(i+1)/5.0;     //生成0.2度一个间隔
        ffftemp    = (ffNowAngle/fAngleStep);
        istPosi    = iNowPosi1 - (int)ffftemp;
        ffftemp    = ffftemp - (int)ffftemp;
        ienPosi    = istPosi + 1;
		ftemp            = (fpDPDF[ienPosi] - fpDPDF[istPosi]);
        forBackup[300-i] = fpDPDF[istPosi] + ffftemp*ftemp;
    }

//------------------------------------------------------------------
//以下通过相关分析进一步确定上止点的位置
//inum是模板数据的长度,fModal[]是模板数据，同时也是全局变量
//    inum = 146;    //修改前
//根据相关分析判断压力升高率最大值的位置  r = 1.3
//------------------------------------------------------------------
    inum = 66;       //修改后
    iITNum = 0;
    do
    {
        for( i = 0; i < 300; i++)
        {
            forarray[i] = forBackup[i]/fdpmax;       //将压力升高率归一化处理
        }
        for( ii = 0; ii < 229; ii++)      //改后
        {
            fbuffer1[ii] = 0.0;
            for(jj = 0; jj < inum; jj++)
            {
                fntemp = fModal[jj] - forarray[jj + ii];
                fbuffer1[ii] += fntemp*fntemp;
            }
        }
        iMaxPosi1 = 0;
        fntemp = fbuffer1[0];
        for( ii = 1; ii < 220; ii++)
        {
            if((fbuffer1[ii - 1] > fbuffer1[ii])
              &&(fbuffer1[ii] < fbuffer1[ii+1]))
            {
                if(fntemp > fbuffer1[ii])
                {
                    iMaxPosi1 = ii;
                    fntemp = fbuffer1[ii];
                }
            }
        }
/*
//------------------------------------------------------------------
    fpp = fopen("e:\\fbuffer.dat","w");
    for(int i = 0; i < 300; i++)
    {
        fprintf(fpp,"%d %.7f %.7f %.7f\n",i, forBackup[i], forarray[i],fbuffer1[i]);
    }
    fclose(fpp);
//=====================================================================
*/
        iMaxPosiAll = iMaxPosi1;        //这个位置与上止点之间的距离是35度

         //从预估上止点处向前取60度
         //模板是从上止点前35度开始取的,fAllAngle,对上止点的位置影响较大
         //                             fDeltaAngle 影响不大，
         //(iNowPosi1 = iLocalMaxPosi + (int)(fDeltaAngle/fAngleStep);)

        iTDPosi   = iNowPosi1 + (fAllAngle - (300 - iMaxPosiAll)*0.2)/fAngleStep;
        fDPMAngle = (float)(iTDPosi - iposi)*fAngleStep;   //应出现在上止点前16度左右

        if((fDPMAngle > (fDeltaAngle + 0.3))||(fDPMAngle < (fDeltaAngle - 0.3)))
        {
            if(iITNum > 10)                                    //如果迭代10还不收敛，则退出
            {
                break;
            }
            else
            {
                iposi  = iTDPosi - (8.0 + fDPMAngle/2.0)/fAngleStep;  //修正后的压力升高率局部极大值位置
                fdpmax = fpDPDF[iposi];
                fDPDFLocalMax  = fdpmax;
                iITNum ++;
            }
        }
        else
        {
            break;
        }
    }while(true);

    iOilShiftNum = 0;

/*
    if(bCombustion)        //如果是有燃烧过程，则不再判断是否是
    {
        LFHS.chOil = 1;     //表示有供油过程
    }
    else
    {
    }
*/
/*
*/
    float fmaxoil,fsquare, foillevel;
    LFHS.chOil    = 0;     //先假设没有供油过程
    bOilSupply    = false;

    istartposi = iTDPosi - 40.0/fAngleStep;
    iendposi   = iTDPosi - 30.0/fAngleStep;
    foillevel = 0.0;
    for( ii = istartposi; ii < iendposi; ii ++)
    {
        foillevel += ipACData[1][ii];
    }
    foillevel /= (float)(iendposi - istartposi);
    istartposi = iTDPosi - 30.0/fAngleStep;
    iendposi   = iTDPosi;
    ftemp      = 0.0;
    fmaxoil    = ipACData[1][istartposi];
    for( ii = istartposi ; ii < iendposi; ii ++)
   	{
        fsquare = ipACData[1][ii] - foillevel;
       	ftemp +=  fsquare*fsquare;

        if(fmaxoil < ipACData[1][ii])
        {
            fmaxoil = ipACData[1][ii];
        }
    }
    ftemp /= 32768.0;
    ftemp *= fAngleStep;
    if( ftemp > OIL_LEVEL )
    {
         LFHS.chOil = 1;     //供油过程是存在的
         bOilSupply = true;
    }
    else
    {
//        bCombustion = false;
    }
//------------------------------------------------------------------
/*
    #ifdef SELF_DEBUG
    FILE* fpp;
    strTemp = FormMain->strExeFilePath + "Debug\\foil.dat";
    fpp = fopen(strTemp.c_str(),"w");
    for(int i = istartposi; i < iendposi; i++)
    {
        fprintf(fpp,"%d %d\n",i, ipACData[1][i]);
    }
    fclose(fpp);
    #endif
*/
//=====================================================================

    FormMain->LabelOil->Caption = ftemp;
    if(bCombustion) //如果是燃烧过程,则计算燃烧始点、及供油始点；
    {
         //计算燃烧提前角度，实际是压力升高率突然增大的角度至上止点的位置
        fCombustionAngle = (icombustionposi - iTDPosi)*fAngleStep;
        iCombustionPosi  = icombustionposi;
    }
    else   //如果不是燃烧过程，那么就置燃烧始点为0
    {
        fCombustionAngle = 0.0;
        iCombustionPosi  = iTDPosi;
    }
    if(bOilSupply)
    {
//------------------------------------------------------------------------
//  此段代码用于修正时间滞后 ,分别考虑了油管及测压通道的滞后现象　
        float fL,fA,fOilL,fOilA,ftemp1,ftemp2,ftemp3;
        fL = 0.4;                                     //气缸内距检爆阀端部的距离
        fA = 400.0 + (fEn - 400.0)*300.0/600.0;       //检爆阀内气体传播速度
        fOilL = 0.15;                                 //夹持式传感器距喷油泵端的距离
        fOilA = 700.0 + (fEn - 400.0)*600.0/600.0;    //燃烧传播的音速
        ftemp1 = 6.0*fEn*fOilL/fOilA;
        ftemp2 = 6.0*fEn*fL/fA;                       //滞后的度数
//  下面这个公式主要是考虑了进油孔节流的问题          //假设每100转内变化1.2度
        ftemp3 = 1.5 + (fEn - 400.0)*1.1/100.0;           
        iOilShiftNum = (ftemp3 + ftemp2 - ftemp1)/fAngleStep; //  fL = 320mm　燃烧室至传感器的距离
                                      //  fA = 600m/s 通道内音速

//------------------------------------------------
// 暂时先不考虑测量数据的滞后现象
// 2005年8月16日
        iOilShiftNum = 0;
//将油管数据移至相应位置
        CorrectOilPosi();
//========================================================================================
//========================================================================================
        if(   (LFHS.siPassageStatus[1] == 1)  //如果通道二是处于打开状态，
          )
        {

            float iDPMax;
            //-----------------------------------
            //先设波形标准为0.15和0.35
            fLevelStart = 0.10;
            fLevelEnd   = 0.25;
            //===================================
            iOilPosi = AnalysisOilAngle(0);
            if( (iCombustionPosi - iOilPosi)/fAngleStep > 30.0 )
            {
                fLevelStart = 0.20;
                fLevelEnd   = 0.35;
            //===================================
                iOilPosi = AnalysisOilAngle(iOilPosi);
            }
        }
    }
    else
    {
        iOilPosi             = iTDPosi;
        iCombustionPosi      = iTDPosi;
        LFHS.fWavePeriod     = 0.0;
        LFHS.fWaveCoef       = 0.0;
        LFHS.iOilPosi        = iTDPosi;
        LFHS.iCombustionPosi = iTDPosi;
    }
    iTDPosiBackup     = iTDPosi;
    iTDCStep          = 0;
    bTDPosiCalculated = true;    //表示上止点已计算出来
    FormMain->LabelDPDF->Caption = fDPDFLocalMax;
}
void __fastcall lDieselHRBP::CorrectOilPosi(void)
{
    //TODO: Add your source code here

// 为油管压力波信号向后移动的个数 ,主要用于修正相位误差
    if( iOilShiftNum > 0)
    {
        for(int i = iAbstractLength - 1; i >= iOilShiftNum; i --)
        {
            ipACData[1][i] = ipACData[1][i - iOilShiftNum];
        }
    }
}
float __fastcall lDieselHRBP::CalculateOilPosi(void)
{
    //TODO: Add your source code here
    //TODO: 判断供油开始角度的算法
    //取上止点前-35.0至-27.0的平均值作为基准，当油管压力波降至刚刚小于这一值时，认为开始供油
    //看来上面的方法还不行，必须考虑梯度
    float iDPMax;
    float fOilLevel;
    float iDPMaxPosi;
    float fa, fb;
    float ffOilMax, ffOilMin;
    int   iOilMaxPosi;
    float fOilBackup;
    int istartposi;
    int iendposi;
    int ii;
    int iposi;
    int iLevel35, iLevel15;
    float fOilAngles;
    int iNewPosi;
    int iNewPosi1;
    float fx = 0;
    float fy = 0;
    float fAverX = 0;
    float fAverY = 0;
    float fSumXX = 0;
    float fSumXY = 0;

    fOilLevel = 0.0;
//(1) 先将总体平均的数据赋给待滤波通道
    for( int i = 0; i < iAbstractLength; i++)
    {
        ipOData[1][i] = ipACData[1][i];
    }

    lFilterOriginal(hm, 55, 1);  //900Hz滤波
/*
    FILE* fp = fopen("e:\\oilFilter.dat","w");
    if(fp != NULL)
    {
        for(int i = 0; i < iAbstractLength; i++)
        {
            fprintf(fp, "%d %d %d\n",i,ipOData[1][i],ipOData[2][i]);
        }
        fclose(fp);
    }
*/
//(2) 在滤波后的数据中寻找计算油管压力波的基准 fOilLevel
    istartposi = iTDPosi - 40.0/fAngleStep;
    iendposi   = iTDPosi - 30.0/fAngleStep;
    ffOilMax   = ipOData[2][istartposi];
    ffOilMin   = ipOData[2][istartposi];

    for( ii = istartposi; ii < iendposi; ii ++)
    {
        fOilLevel += ipOData[2][ii];
        if( ffOilMax < ipOData[2][ii])
        {
            ffOilMax = ipOData[2][ii];
        }
        else if( ffOilMin > ipOData[2][ii])
        {
            ffOilMin = ipOData[2][ii];
        }
    }
    fOilLevel /= (float)(iendposi - istartposi);
    fOilBackup = fOilLevel;
    fOilLevel += 0.02*(ffOilMax - ffOilMin);     //加上一点抗干扰的数据
//==========================================================
//(3) 寻找油管压力波的最大值
    istartposi = iTDPosi - 30.0/fAngleStep;
    iendposi   = iTDPosi + 20.0/fAngleStep;
   	iDPMax     = ipOData[2][istartposi];

    iOilMaxPosi = istartposi;
    for( ii = istartposi + 1; ii < iendposi; ii ++)
   	{
       	if(iDPMax < ipOData[2][ii])    //寻找最大值
        {
            iDPMax       = ipOData[2][ii];
            iOilMaxPosi  = ii;
 	    }
    }
    iposi = iOilMaxPosi;
    LFHS.fOilPeak = (float)(iDPMax - fOilBackup);

//-----------------------------------------------------------------------------
    ffOilMax = (float)(iDPMax - fOilBackup) * fLevelEnd   + fOilBackup;     //针对东风4D和东风11
    ffOilMin = (float)(iDPMax - fOilBackup) * fLevelStart + fOilBackup;
    fOilAngles = 30.0 - (1000.0 - LFHS.fEngineSpeed)/30.0;
    istartposi = iOilMaxPosi - fOilAngles/fAngleStep;
    iendposi   = iOilMaxPosi;    //油管波形峰值的最大位置
    iLevel35   = iOilMaxPosi;
// 此时iposi即为供油开始点, 不知抗干扰能力如何
// 接下来的算法用于计算梯度，当梯度值大于时，认为开始

// 还是从前向后找吧　20071015
    iLevel15 = iTDPosi - 40.0/fAngleStep;
    while( ipOData[2][iLevel15] < ffOilMin )
    {
        iLevel15 ++;
        if( iLevel15 > iTDPosi )    //防止程序出现错误
        {
            break;
        }
    }
    iLevel35 = iLevel15;
    while( ipOData[2][iLevel35] < ffOilMax )
    {
        iLevel35 ++;
        if( iLevel35 > iTDPosi )   //防止程序出现错误
        {
            break;
        }
    }
//    }while( ipOData[2][iLevel35] > ffOilMax);

//  以下拟合公式算法
/*
    iLevel15 = iLevel35;
    do
    {
        iLevel15 --;
    }while( ipOData[2][iLevel15] > ffOilMin);
*/

/*
// 测试用
    FILE* fp = fopen("f:\\oilFilter.dat","w");
    if(fp != NULL)
    {
        for(int i = iLevel15- 100; i < iLevel35+100; i++)
        {
            fprintf(fp, "%d %d %d\n",i,ipOData[1][i],ipOData[2][i]);
        }
        fclose(fp);
    }
*/
    for(int i = iLevel15; i< iLevel35; i++)
    {
        fAverX += (float)i;  //mN.m
        fAverY += (float)ipOData[2][i];
    }
    fAverX /= (float)(iLevel35 - iLevel15);
    fAverY /= (float)(iLevel35 - iLevel15);
    for(int i = iLevel15; i< iLevel35; i++)
    {
        fx = (float)i;
        fy = (float)ipOData[2][i];
        fSumXY += (fx - fAverX)*(fy - fAverY);
        fSumXX += (fx - fAverX)*(fx - fAverX);
    }
    if( fabs( fSumXX < 0.000001))
    {
        fb = 1.0;
        fa = 1.0;
    }
    else
    {
        fb = fSumXY/fSumXX;
        fa = fAverY - fb*fAverX;      //求解出了拟合的线性公式
    }
    iNewPosi  = (int)((fOilBackup - fa)/fb);  //此点即为供油点
    fb        = (float)(iLevel35 - iLevel15)/(float)(ipOData[2][iLevel35] - ipOData[2][iLevel15]);
    iNewPosi1 = (fOilBackup - ipOData[2][iLevel15])*fb + iLevel15;
    iNewPosi  = (iNewPosi + iNewPosi1)/2;
//------------------------------------------------------------------------------------------
//******************************************************************************************
// 由于测量油管位置及检爆阀通道长度的影响，
    fOilAngle = (iNewPosi - iTDPosi)*fAngleStep - OIL_DELTA;  //OIL_DELTA = 1.9为定位修正值
    iOilPosi  = iTDPosi + (int)(fOilAngle/fAngleStep);
//******************************************************************************************
//==========================================================================================
    return iNewPosi;
}

void __fastcall lDieselHRBP::CalculateOilParameters(void)
{
    //TODO: Add your source code here
// 以下用于计算油管波形的其它参数
    int iValidStart, iValidEnd;
    float fOilBackup;
    float fOilLevel;
    int   iDPMax;
    float ffOilMax;
    float fTempp[2000];
    iValidStart = iOilPosi - 10.0/fAngleStep;
    iValidEnd   = iOilPosi;
    fOilLevel   = 0.0;
    for(int ii = iValidStart; ii < iValidEnd; ii ++)
    {
        fOilLevel += ipACData[1][ii];
    }
    fOilLevel /= (float)(iValidEnd - iValidStart);
    fOilBackup = fOilLevel;
    iValidStart = iOilPosi;
    iValidEnd   = iOilPosi + 40.0/fAngleStep;
    iDPMax      = ipACData[1][iValidStart];
    for( int ii = iValidStart; ii < iValidEnd; ii ++)
    {
        if(iDPMax < ipACData[1][ii])
        {
            iDPMax = ipACData[1][ii];
        }
    }
    LFHS.fOilPeak = (float)(iDPMax - fOilBackup)/32768.0/fOilGain*2.5*8.0;    //统一按8倍来算

    ffOilMax = (float)(iDPMax - fOilBackup) * 0.35 + fOilBackup;
    iValidStart = iOilPosi;
    iValidEnd   = iTDPosi + 30.0/fAngleStep;
    do
    {
        iValidStart ++;
        if(iValidStart >= iAbstractLength ) break;
    }while(ipACData[1][iValidStart] < ffOilMax);

    do
    {
        iValidEnd --;
    }while(ipACData[1][iValidEnd] < ffOilMax);

    LFHS.fWavePeriod = (iValidEnd - iValidStart)*fAngleStep;        //波形持续时间

    int ihalfLen = 5;
    for(int ii = iValidStart; ii < iValidEnd; ii ++)
    {
        fTempp[ii - iValidStart] = 0.0;
        for(int jj = -ihalfLen; jj < (ihalfLen + 1); jj ++)
        {
            fTempp[ii - iValidStart] += ipACData[1][ii + jj];
        }
        fTempp[ii - iValidStart] /= (float)(2*ihalfLen + 1);
    }

    float ftem ,ffsum = 0.0;
    for(int ii = iValidStart; ii < iValidEnd; ii ++)
    {
        ftem = fTempp[ii - iValidStart] - ipACData[1][ii];
        ffsum += ftem*ftem;
    }
    LFHS.fWaveCoef   = sqrt(ffsum)/(float)(iDPMax - fOilBackup) ;                  //波形系数
//=============================================================================================
}


float __fastcall lDieselHRBP::AnalysisOilAngle(int istart)
{
    //TODO: 判断供油开始角度的算法
    //取上止点前-35.0至-27.0的平均值作为基准，当油管压力波降至刚刚小于这一值时，认为开始供油
    //看来上面的方法还不行，必须考虑梯度
    float iDPMax;
    float fOilLevel;
    float iDPMaxPosi;
    float fa, fb;
    float ffOilMax, ffOilMin;
    int   iOilMaxPosi;
    float fOilBackup;
    int iValidStart, iValidEnd;
    int istartposi;
    int iNewPosi;
    int iendposi;
    int ii;
    int iposi;
    float fAlfa = 0.1;
    int iLevel35, iLevel15;
    float fx = 0;
    float fy = 0;
    float fAverX = 0;
    float fAverY = 0;
    float fSumXX = 0;
    float fSumXY = 0;
    float fStartMax,fStartMin,fStartZero;
    float fTempp[2000];

    FILE* fp;
    fOilLevel = 0.0;
    for( int i = 0; i < iAbstractLength; i++)
    {
        ipOData[1][i] = ipACData[1][i];
    }
    lFilterOriginal(hm, 55, 1);  //900Hz滤波
/*
    int isum;
    for( int i = iAbstractLength/4; i < iAbstractLength*3/4; i++)
    {
        isum = 0;
        for( int j = i - 10; j < i + 10; j++)
        {
            isum += ipACData[1][j];
        }
        ipOData[2][i] = isum / 20;
    }
*/

// 计算油管压力波的基准 fOilLevel
    if(istart == 0)
    {
        istartposi = iTDPosi - 60.0/fAngleStep;
        iendposi   = iTDPosi - 30.0/fAngleStep;
        ffOilMax   = ipOData[2][istartposi];
        ffOilMin   = ipOData[2][istartposi];
    }
    else
    {
        istartposi = istart - 10;
        iendposi   = istart + 10;
        ffOilMax   = ipOData[2][istartposi];
        ffOilMin   = ipOData[2][istartposi];
    }
    for( ii = istartposi; ii < iendposi; ii ++)
    {
        fOilLevel += ipOData[2][ii];
        if( ffOilMax < ipOData[2][ii])
        {
            ffOilMax = ipOData[2][ii];
        }
        else if( ffOilMin > ipOData[2][ii])
        {
            ffOilMin = ipOData[2][ii];
        }
    }
    fStartMax  = ffOilMax - 0.05*(ffOilMax - ffOilMin);
    fStartMin  = ffOilMin + 0.05*(ffOilMax - ffOilMin);
    fOilLevel /= (float)(iendposi - istartposi);
    fOilBackup = fOilLevel;
    fOilLevel += fAlfa*(ffOilMax - ffOilMin);
// 寻找油管压力波的最大值
    if(istart == 0)
    {
        istartposi = iTDPosi - 30.0/fAngleStep;
    }
    else
    {
        istartposi = istart;
    }

    iendposi   = iTDPosi + 20.0/fAngleStep;
   	iDPMax     = ipOData[2][istartposi];
    iposi = istartposi;

    for( ii = istartposi + 1; ii < iendposi; ii ++)
   	{
       	if(iDPMax < ipOData[2][ii])    //寻找最大值
        {
            iDPMax = ipOData[2][ii];
            iposi  = ii;
 	    }
    }
    LFHS.fOilPeak = (float)(iDPMax - fOilBackup);
    iOilMaxPosi = iposi;

    FILE* fppp;
    float fttt,fsum,ftemppp,fsumm0;
    int iiistart, iiiend;
    AnsiString strTemp1;
    strTemp1.printf("Debug\\A_oilChange.dat",fLevelStart, fLevelEnd);
    strTemp1 = FormMain->strExeFilePath + strTemp1;
    iiistart = iOilMaxPosi - 500;
    iiiend   = iOilMaxPosi + 500;
    fsumm0 = 0.0;
    if((fppp = fopen(strTemp1.c_str(),"w"))!= NULL)
    {
        for(int i = iiistart; i < iiiend; i++)
        {
            fprintf(fppp, "%d %d %d\n", i, ipACData[1][i],ipOData[2][i]);
        }
        fclose(fppp);
    }

    int iIterateNum = 0;
    float fOilAngles;
    int iNewPosi1;
    do
    {
//-----------------------------------------------------------------------------
        ffOilMax = (float)(iDPMax - fOilBackup) * fLevelEnd   + fOilBackup;     //针对东风4D和东风11
        ffOilMin = (float)(iDPMax - fOilBackup) * fLevelStart + fOilBackup;
        fOilAngles = 30.0 - (1000.0 - LFHS.fEngineSpeed)/30.0;
        istartposi = iposi - fOilAngles/fAngleStep;
        iendposi   = iOilMaxPosi;    //油管波形峰值的最大位置
        bool bMin = false, bMax = false;
/*
        for( int i = istartposi; i < iendposi; i++)
        {
//ipOData[2] = ipACData[1]
            if( (ipOData[2][i] > ffOilMin) && (!bMin))
            {
                bMin = true;
                iLevel15 = i;
            }
            else if((ipOData[2][i] > ffOilMax) && (!bMax))
            {
                bMax = true;
                iLevel35 = i;
            }
            if(bMax && bMin)
            {
                break;
            }
        }
*/
    iLevel35 = iposi;
    do
    {
   	    iposi --;
        if(iposi < 0)
        {
            break;
        }
    }while(ipACData[1][iposi] > fOilBackup);

// 此时iposi即为供油开始点, 不知抗干扰能力如何
// 接下来的算法用于计算梯度，当梯度值大于时，认为开始
    iNewPosi1 = iposi;
    do
    {
        iLevel35 --;
    }while( ipACData[1][iLevel35] > ffOilMax);

//  以下拟合公式算法
    iLevel15 = iLevel35;
    do
    {
        iLevel15 --;
    }while( ipACData[1][iLevel15] > ffOilMin);

//====================================================================
/*
    FILE* fppp;
    float fttt,fsum,ftemppp,fsumm0;
    int iiistart, iiiend;
    AnsiString strTemp1;
    strTemp1.printf("Debug\\A_oilChange.dat",fLevelStart, fLevelEnd);
    strTemp1 = FormMain->strExeFilePath + strTemp1;
    iiistart = iLevel15 - 100;
    iiiend   = iLevel35 + 100;
    fsumm0 = 0.0;
    if((fppp = fopen(strTemp1.c_str(),"w"))!= NULL)
    {
        for(int i = iiistart; i < iiiend; i++)
        {
            fttt = 0.0;
            for( int j = i - 4; j < i + 4; j++)
            {
                fttt += (float)ipACData[1][i];
            }
            fttt /= 8.0;
            fsum  = 0.0;
            for( int j = i - 4; j < i + 4; j++)
            {
                ftemppp = ((float)ipACData[1][j] - fttt);
                fsum += ftemppp * ftemppp;
            }
            fsumm0 += fsum/(float)(iDPMax*iDPMax);
            fTempp[i - iiistart] = fsumm0;
        }
        for(int i = iiistart; i < iiiend; i++)
        {
            fprintf(fppp, "%d %f %f\n", i, (float)ipACData[1][i],fTempp[i - iiistart]*2000.0);
        }
        fclose(fppp);
    }
*/
/*
        for(int i = iLevel15; i< iLevel35; i++)
        {
            fAverX += (float)i;  //mN.m
            fAverY += (float)ipACData[1][i];
        }
        fAverX /= (float)(iLevel35 - iLevel15);
        fAverY /= (float)(iLevel35 - iLevel15);
        for(int i = iLevel15; i< iLevel35; i++)
        {
            fx = (float)i;
            fy = (float)ipACData[1][i];
            fSumXY += (fx - fAverX)*(fy - fAverY);
            fSumXX += (fx - fAverX)*(fx - fAverX);
        }
        if( fabs( fSumXX < 0.000001))
        {
            fb = 1.0;
            fa = 1.0;
        }
        else
        {
            fb = fSumXY/fSumXX;
            fa = fAverY - fb*fAverX;      //求解出了拟合的线性公式
        }
*/
/*
//  fOilLevel为交点的纵坐标，而供油始点为要求解的横坐标
        fb = (float)(iLevel35 - iLevel15)/(float)(ipACData[1][iLevel35] - ipACData[1][iLevel15]);
        iNewPosi = (fOilBackup - ipACData[1][iLevel15])*fb + iLevel15;
*/
// 显示滤波后的数据进行判断
        for(int i = iLevel15; i< iLevel35; i++)
        {
            fAverX += (float)i;  //mN.m
            fAverY += (float)ipACData[1][i];
        }
        fAverX /= (float)(iLevel35 - iLevel15);
        fAverY /= (float)(iLevel35 - iLevel15);
        for(int i = iLevel15; i< iLevel35; i++)
        {
            fx = (float)i;
            fy = (float)ipACData[1][i];
            fSumXY += (fx - fAverX)*(fy - fAverY);
            fSumXX += (fx - fAverX)*(fx - fAverX);
        }
        if( fabs( fSumXX < 0.000001))
        {
            fb = 1.0;
            fa = 1.0;
        }
        else
        {
            fb = fSumXY/fSumXX;
            fa = fAverY - fb*fAverX;      //求解出了拟合的线性公式
        }

        iNewPosi = (int)((fOilBackup - fa)/fb);  //此点即为供油点
        iNewPosi = iNewPosi1;

//-------------------------------------------------------------------
//如果出现下述这种情况就已不正确了
        if((iNewPosi > iLevel15)||(iNewPosi < 0))
        {
            fLevelEnd    += 0.05;     //针对东风4D和东风11
            fLevelStart  += 0.05;
            iIterateNum ++;
            if(iIterateNum > 6)
            {
                break;
            }
        }
        else
        {
            break;
        }
    }while(true);
//===================================================================

//=======================================================================

    for( ii = iposi; ii < iposi + 200; ii ++)
    {
        fOilLevel = (ipACData[1][ii + 5] - ipACData[1][ii - 5]) / (float)iDPMax /fAngleStep * 100.0;
        if(fOilLevel > 15.0)
        {
            iposi = ii;
            break;
        }
    }

//------------------------------------------------------------------------------------------
//******************************************************************************************
// 由于测量油管位置及检爆阀通道长度的影响，
// 在这里要对供油角度进行修正

//    fOilAngle = (iposi - iTDPosi)*fAngleStep - OIL_DELTA;  //OIL_DELTA = 1.9为定位修正值
    fOilAngle = (iNewPosi - iTDPosi)*fAngleStep - OIL_DELTA;  //OIL_DELTA = 1.9为定位修正值
    iOilPosi  = iTDPosi + (int)(fOilAngle/fAngleStep);
//******************************************************************************************
//==========================================================================================

//--------------------------------------------------------
/*
//  此处测试供油始点判断是正确
    #ifdef SELF_DEBUG
    AnsiString strTemp;
    istartposi = iTDPosi - 50.0/fAngleStep;
    iendposi   = iTDPosi + 30.0/fAngleStep;
    for( int i = istartposi ; i < iNewPosi; i++)
    {
        fTempp[i - istartposi] = fOilBackup;
    }
    for( int i = iLevel35; i < iendposi; i++)
    {
        fTempp[i - istartposi] = (float)iLevel35*fb + fa;
    }
    for( int i = iNewPosi; i < iLevel35; i++)
    {
        fTempp[i - istartposi] = (float)i*fb + fa;
    }
    strTemp.printf("Debug\\AOilAngle_系数_%.2f_%.2f.dat",fLevelStart, fLevelEnd);
    strTemp = FormMain->strExeFilePath + strTemp;
    if((fp = fopen(strTemp.c_str(),"w")) != NULL)
    {
        for(ii = istartposi; ii < iendposi; ii++)
        {
            fprintf(fp, "%d %d %.2f\n",     ii, ipACData[1][ii], fTempp[ii - istartposi]);
        }
        fclose(fp);
    }
    #endif
*/
//-----------------------------------------------------------------------------------------
// 以下用于计算油管波形的其它参数
    iValidStart = iNewPosi;
    iValidEnd   = iTDPosi + 30.0/fAngleStep;
    ffOilMax = (float)(iDPMax - fOilBackup) * 0.35 + fOilBackup;
    do
    {
        iValidStart ++;
        if(iValidStart >= iAbstractLength ) break;
    }while(ipACData[1][iValidStart] < ffOilMax);

    do
    {
        iValidEnd --;
    }while(ipACData[1][iValidEnd] < ffOilMax);

    LFHS.fWavePeriod = (iValidEnd - iValidStart)*fAngleStep;        //波形持续时间

    int ihalfLen = 5;
    for(ii = iValidStart; ii < iValidEnd; ii ++)
    {
        fTempp[ii - iValidStart] = 0.0;
        for(int jj = -ihalfLen; jj < (ihalfLen + 1); jj ++)
        {
            fTempp[ii - iValidStart] += ipACData[1][ii + jj];
        }
        fTempp[ii - iValidStart] /= (float)(2*ihalfLen + 1);
    }

    float ftem ,ffsum = 0.0;
    for(ii = iValidStart; ii < iValidEnd; ii ++)
    {
        ftem = fTempp[ii - iValidStart] - ipACData[1][ii];
        ffsum += ftem*ftem;
    }
    LFHS.fWaveCoef   = sqrt(ffsum)/(float)(iDPMax - fOilBackup) ;                  //波形系数
//=============================================================================================
    return iNewPosi;
}


bool __fastcall lDieselHRBP::DetectTopDeadPosi_New_Two(void)
{
//函数功能：根据压缩过程的特征计算上止点的位置；
//  此时 公有变量 iTDPosi 中保存着最大值所在的位置
//       公有变量 fEngineSpeed 中保存着柴油机的转速
//       公有变量 fTimeInterval 中保存着每一个采样点的时间间隔  毫秒
//       公有变量 fACP2数组中保存着压力升高率的100倍值
// 根据经验，纯压缩过程的最大值出现在上止点前约16度的样子
// 利用变化量来判断是否有燃烧过程

// 20050919 对上止点的定位进行重新修改
// (1) 在对东风11在720r/min时出现了错误,变化量最小值处并不是燃烧开始点
//----------------------------------------------------------
// 2005_02_18的结论
// ***　对上止点位置影响较大的是　fAllAngle 的大小.
//==========================================================

    if(iSampleNum == 0)   //由于没有提取有效数据，所以不再计算各个参数
    {
        bParameterAbstracted = false;
        return false;
    }
    iCombustionPosi  = 0;          //燃烧始点
    iOilPosi         = 0;                 //供油始点

    int iDPMaxPosi;
    int inumber;
    int iNowPosi,iNowPosi1,iNowPosi2;
    int istartposi,iendposi;
    int iposi;
    int icombustionposi;
    int iognum;
    int iITNum;
    int istPosi,ienPosi;
    bool bCombustionStart = false;
    int i;
    int ii,jj;
    int inum;
    int ii1,ii2,ii3;

    float ftemp;
    float fdpmax;              //压力升高率的最大值
    float fstep;
    float fmax;
    float fDPMAngle;           //压力升高率局部极大值出现的位置
    float fbuffer1[300];
    float forarray[300];
    float forBackup[300];
    float fdpdfdf[600];
    float ffNowAngle;
    float ffPreAngle;
    float ffNextAngle;
    int   iMaxPosi1,iMaxPosiAll;
    float fntemp;
    float ftopangle;
    float fLevel09;
    float fLevel05;

//    bool  bLocalMaxExist = false;
//    bool  bLocalMinExist = false;
    int   iLocalMaxPosi  ;
//    float fLocalMin = 0.0;
    int   iZeroPosi ;
    float fMeanSlope;
    bool  bOver = true;
    bool  bdpdfdfmin = false;
    bTDPosiCalculated = false;  //先设上止点没有计算出来
//=====================================================================
//fAngleStep   每一个采样点间隔曲轴转过的角度
//inumber    大致到达容积最大点的位置iNowPosi

    iNowPosi1  = fDPDFMaxPosi; //iNowPosi中保存的是估计的纯压缩过程变化率最大的位置

   
//---------------------------------------------------------------------------------
//以下程序用于判断是否是含有燃烧过程
// 2005年02月17日
// 具体方法是将一段范围内的压力升高率取平均值，然后计算波动情况，大于1时认为有燃烧
//---------------------------------------------------------------------------------

    float fLevel03 = 0.03;
    int   iWin = 15;
    float fsummm[1000];
    ii1 = fDPDFMaxPosi;
    ii2 = fDPDFMaxPosi;


    float ftempt ,faverage = 0.0;
    
//--------------------------------------------
// 压力升高率达到0.05时的位置，用于帮助定位
    int iLevel005;
    bool bLevel005Valid = true;
    iLevel005 = iAbstractLength/4;
    do
    {

        iLevel005 ++;
        if(iLevel005 == iAbstractLength)
        {
            bLevel005Valid = false;
            break;
        }
    }while(fpDPDF[iLevel005] < 0.05);
    if(!bLevel005Valid)
    {
        return false;     //表明此时的数据无效
    }
//=============================================
//------------------------------------------------------------
// 以下用于判断是否有燃烧过程
// 取燃烧过程的0.03至下降为0的曲轴转角范围进行燃烧判断
/*
    do
    {
        ii1 --;
        if(ii1 <= 0 )
        {
            return;
        }
    }while(fpDPDF[ii1] > fLevel03);
*/
    ii1 = iLevel005;
    do
    {
        ii2 ++;
        if( ii2 == iAbstractLength)
        {
            return false;
        }
    }while(fpDPDF[ii2] > 0.0);  // fLevel03;
    ii3 = ii2 + (int)(20.0/fAngleStep);
    if(ii3 - ii1 > 1000)
    {
        ii1 = ii3 - 1000;
    }

    for( int i = ii1; i < ii3; i++)
    {
        fsummm[ i - ii1] = 0.0;
        for(int j = i - iWin; j <= i + iWin; j++)
        {
            fsummm[i - ii1] += fpDPDF[j];
        }
        fsummm[i - ii1] /= (float)(2*iWin + 1);
    }
    for(int i = ii1; i < ii2; i++)
    {
        ftempt = fpDPDF[i] - fsummm[i-ii1];
        faverage += ftempt*ftempt;
    }
    fDetect  = faverage*10000.0;
    
// 燃烧始点的判断
    bCombustion = true;
    for( int i = ii1; i < ii3; i++)
    {
       fsummm[i - ii1] = (fpDPDF[i] - fsummm[i - ii1])*200.0;
    }
    ii2 = 0;
    ftempt = fsummm[0];
    float fll,fllevel;

//????????????????????????????????????????????????????????????????????????????????????
    fll     = 0.5  + (fEn - 400.0)/1200.0;     //原为0.5 现已改为0.3
    fllevel = 0.18 + (fEn - 400.0)/1200.0;
//------------------------------------------------------------------
//??????????????????????????????????????????????????????????????????
//???????????? 此处用于测试,请记住关闭
/*
    FILE * fp;
    fp = fopen("e:\\atest.dat","w");
    if(NULL != fp)
    {
        for( int i = 1; i < ii3 - ii1; i++)
        {
            fprintf(fp,"%d %f\n",ii1 + i,fsummm[i]);
        }
        fclose(fp);
    }
*/
//===================================================================
    for( int i = 1; i < ii3 - ii1; i++)
    {
        if(fsummm[i] > fll)    //如果最大值大于0.2，那这就开始燃烧了，
        {
            bCombustion = true;
            ftempt      = fsummm[i];
            ii2 = i;
            break;
        }
        if( fsummm[i] > ftempt)
        {
            ftempt = fsummm[i];
            ii2    = i;
        }
    }
    do
    {
        ii2 --;
        if( ii2 <= 0)
        {
            break;
        }
    }while( fsummm[ii2] > fsummm[ ii2 - 1]);
    ii2 = ii2 + ii1;     //ii3保存的是燃烧始点
    if(ftempt > fllevel)
    {
        bCombustion = true;
    }
    else
    {
        bCombustion = false;
    }
// 在调试的时候可以用于判断压力升高率的变化过程
//---------------------------------------------------------------------------
//??????????????????????????????????????????????????????????????????????????????

        FILE* fp;
        AnsiString strTemp;
        strTemp = FormMain->strExeFilePath + "Debug\\dpchange.dat";
        if((fp = fopen(strTemp.c_str(), "w")) != NULL)
        {
           for(int i = ii1; i < ii3; i ++)
           {
              fprintf( fp, "%d %.5f %.5f\n", i, fpDPDF[i], fsummm[i - ii1]);
           }
           fclose(fp);
        }

//???????????????????????????????????????????????????????????????????????????????
//=============================================================================

    if(bCombustion)
    {
        ftempt          = fpDPDF[ii2];
        iposi           = ii2;
//        icombustionposi = iposi;    //将燃烧始点保存好
        //在DF11的时下面这个很少满足情况
        for( int i = ii2; i > ii2 - 60; i --)
        {
            if(fpDPDF[i+1] < fpDPDF[i])
            {
                iposi  = i + 2;
                break;
            }
        }

        icombustionposi = iposi;     //???????????????????????????????????????????????????
        ii3             = iposi;
        ii2             = ii3;
        ii1 = ii2 - 60.0/fAngleStep;    //从燃烧始点向前取60度
        ftempt = fpDPDF[iposi];
        for( int i = ii2; i > ii1; i -- )  //在这一范围内寻找局部最大值
        {
            if( ftempt < fpDPDF[i])
            {
                ftempt = fpDPDF[i];
                iposi  = i;
            }
        }
        if( iposi != ii2)               //说明燃烧始点处的压升率小于局部最大值
        {
            if( fpDPDF[ii2] > ftempt*0.9)
            {
                faverage = fpDPDF[ii2 -1];
            }
            else
            {
                faverage = ftempt*0.9;
            }
            ii1    = iposi;
            ii2    = iposi;
            do
            {
                if(fpDPDF[ii1] < faverage )
                {
                    break;
                }
                ii1 --;
            }while(true);

            do
            {
                if(fpDPDF[ii2] < faverage )
                {
                    break;
                }
//------------------------------------------------------------------
//????????????????????????????????????????????????????????????????????????????????????
                if(ii2 > icombustionposi)
                {
                    break;
                }
//==================================================================
                ii2 ++;
            }while(true);
            iLocalMaxPosi = ( ii2 + ii1 ) /2;
        }
        else
        {
            iLocalMaxPosi = iposi - 10;
        }
    }
    else
    {
        faverage = fpDPDF[(int)fDPDFMaxPosi]*0.9;
        ii1    = fDPDFMaxPosi;
        ii2    = fDPDFMaxPosi;
        do
        {
            if(fpDPDF[ii1] < faverage )
            {
                break;
            }
            ii1 --;
        }while(true);

        do
        {
            if(fpDPDF[ii2] < faverage )
            {
                break;
            }
            ii2 ++;
        }while(true);
        iLocalMaxPosi = ( ii2 + ii1 ) /2;
    }

    fdpmax        = fpDPDF[iLocalMaxPosi];
//==============================================================================
// 初步估计上止点的位置
    iNowPosi1 = iLocalMaxPosi + (int)(fDeltaAngle/fAngleStep);
                               //iNowPosi1 :初步计算得到的上止点位置
    iposi   = iLocalMaxPosi;
                               //iposi　   :压力升高率局部极大值的位置


// 最新加入的部分，现在为止，仪器内还没有添加这一算法
// 最后再仔细核实一下数据是否正确
//???????????????????????????????????????????????????????????????????????????????????
    if(  (fCPMaxPosi - iposi   > 30.0/fAngleStep)        //如果不能满足这个条件，那么上止点的位置肯定错了
        ||(fCPMaxPosi - iposi  < 14.0/fAngleStep)
      )
    {
        iposi         = fCPMaxPosi - 25.0/fAngleStep;
        iLocalMaxPosi = iposi;
        iNowPosi1     =  iLocalMaxPosi + (int)(fDeltaAngle/fAngleStep);
        fdpmax        = fpDPDF[iposi];
    }
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
/*
//-------------------------------------------------------------------------------
//试验部分
//根据气缸压力最大值的位置初步设定一个局部极大值位置，然后再通过迭代的方法来求角
//通过实际计算发现：在判断压缩过程还是误差比较大的
// 2005年09月08日
    iposi         = fCPMaxPosi - 20.0/fAngleStep;
    iLocalMaxPosi = iposi;
    iNowPosi1     =  iLocalMaxPosi + (int)(fDeltaAngle/fAngleStep);
    fdpmax        = fpDPDF[iposi];
// 试验部分
//===============================================================================
*/
//--------------------------------------------------------------
// 如果不进行相关分析，那么下面这句话就可以计算出上止点了
//    iTDPosi   = iLocalMaxPosi + fDeltaAngle/fAngleStep;
// 计算用于相关分析的模板，0.2度一个数据,共计算300个
//==============================================================
    float ffftemp;
    for(i = 300; i >0; --i)   //上止点前60度至0度
    {
        ffNowAngle = (float)(i+1)/5.0;     //生成0.2度一个间隔
        ffftemp    = (ffNowAngle/fAngleStep);
        istPosi    = iNowPosi1 - (int)ffftemp;
        ffftemp    = ffftemp - (int)ffftemp;
        ienPosi    = istPosi + 1;
        if( (istPosi < 0)||(ienPosi < 0))
        {
            return false;
        }
		ftemp            = (fpDPDF[ienPosi] - fpDPDF[istPosi]);
        forBackup[300-i] = fpDPDF[istPosi] + ffftemp*ftemp;
    }

//------------------------------------------------------------------
//以下通过相关分析进一步确定上止点的位置
//inum是模板数据的长度,fModal[]是模板数据，同时也是全局变量
//    inum = 146;    //修改前
//根据相关分析判断压力升高率最大值的位置  r = 1.3
//------------------------------------------------------------------
    inum = 66;       //修改后
    iITNum = 0;

    do
    {
        if(fdpmax < 0.0)
        {
            fdpmax = 1.0;
        }
        for( i = 0; i < 300; i++)
        {
            forarray[i] = forBackup[i]/fdpmax;       //将压力升高率归一化处理
        }
        for( ii = 0; ii < 229; ii++)      //改后
        {
            fbuffer1[ii] = 0.0;
            for(jj = 0; jj < inum; jj++)
            {
                fntemp = fModal[jj] - forarray[jj + ii];
                fbuffer1[ii] += fntemp*fntemp;
            }
        }
        iMaxPosi1 = 0;
        fntemp = fbuffer1[0];
        for( ii = 1; ii < 220; ii++)
        {
            if((fbuffer1[ii - 1] > fbuffer1[ii])
              &&(fbuffer1[ii] < fbuffer1[ii+1]))
            {
                if(fntemp > fbuffer1[ii])
                {
                    iMaxPosi1 = ii;
                    fntemp = fbuffer1[ii];
                }
            }
        }
/*
//------------------------------------------------------------------
    fpp = fopen("e:\\fbuffer.dat","w");
    for(int i = 0; i < 300; i++)
    {
        fprintf(fpp,"%d %.7f %.7f %.7f\n",i, forBackup[i], forarray[i],fbuffer1[i]);
    }
    fclose(fpp);
//=====================================================================
*/
        iMaxPosiAll = iMaxPosi1;        //这个位置与上止点之间的距离是35度

         //从预估上止点处向前取60度
         //模板是从上止点前35度开始取的,fAllAngle,对上止点的位置影响较大
         //                             fDeltaAngle 影响不大，
         //(iNowPosi1 = iLocalMaxPosi + (int)(fDeltaAngle/fAngleStep);)

//--------------------------------------------------------------------------------------
//????????????????????????????????????????????????????????????????????????????????????
        istartposi = iTDPosi;
//======================================================================================
        iTDPosi   = iNowPosi1 + (fAllAngle - (300 - iMaxPosiAll)*0.2)/fAngleStep;
//        iNowPosi1 = iTDPosi;    //????????????????
        fDPMAngle = (float)(iTDPosi - iposi)*fAngleStep;   //应出现在上止点前16度左右

        if((fDPMAngle > (fDeltaAngle + 0.2))||(fDPMAngle < (fDeltaAngle - 0.2)))
        {
            if(iITNum > 10)                                    //如果迭代10还不收敛，则退出
            {
                break;
            }
            else
            {
                iposi  = iTDPosi - (8.0 + fDPMAngle/2.0)/fAngleStep;  //修正后的压力升高率局部极大值位置
//----------------------------------------------------------
//??????????????????????????????????????????????????????????????????????????????????????????????????
                if(bCombustion)
                {
                    if(iposi > icombustionposi)
                    {
                        if( iITNum >= 1)
                        {
                            iTDPosi = istartposi;     //istartposi是一个备份值　
                        }
                        break;
                    }
                }
//=========================================================
                fdpmax = fpDPDF[iposi];
                fDPDFLocalMax  = fdpmax;
                iITNum ++;
            }
        }
        else
        {
            break;
        }
    }while(true);

    iOilShiftNum = 0;

/*
    if(bCombustion)        //如果是有燃烧过程，则不再判断是否是
    {
        LFHS.chOil = 1;     //表示有供油过程
    }
    else
    {
    }
*/
/*
*/
    float fmaxoil,fsquare, foillevel;
    LFHS.chOil    = 0;     //先假设没有供油过程
    bOilSupply    = false;

    istartposi = iTDPosi - 40.0/fAngleStep;
    iendposi   = iTDPosi - 30.0/fAngleStep;
    foillevel = 0.0;
    if(istartposi < 0)
    {
        istartposi = 0;
    }
    if(iendposi < 0)
    {
        iendposi = 0;
    }
    for( ii = istartposi; ii < iendposi; ii ++)
    {
        foillevel += ipACData[1][ii];
    }
    foillevel /= (float)(iendposi - istartposi);
    istartposi = iTDPosi - 30.0/fAngleStep;
    iendposi   = iTDPosi;
    ftemp      = 0.0;
    fmaxoil    = ipACData[1][istartposi];
    for( ii = istartposi ; ii < iendposi; ii ++)
   	{
        fsquare = ipACData[1][ii] - foillevel;
       	ftemp +=  fsquare*fsquare;

        if(fmaxoil < ipACData[1][ii])
        {
            fmaxoil = ipACData[1][ii];
        }
    }
    ftemp /= 32768.0;
    ftemp *= fAngleStep;
    if( ftemp > OIL_LEVEL )
    {
         LFHS.chOil = 1;     //供油过程是存在的
         bOilSupply = true;
    }
    else
    {
//        bCombustion = false;
    }
//------------------------------------------------------------------
/*
    #ifdef SELF_DEBUG
    FILE* fpp;
    strTemp = FormMain->strExeFilePath + "Debug\\foil.dat";
    fpp = fopen(strTemp.c_str(),"w");
    for(int i = istartposi; i < iendposi; i++)
    {
        fprintf(fpp,"%d %d\n",i, ipACData[1][i]);
    }
    fclose(fpp);
    #endif
*/
//=====================================================================

    FormMain->LabelOil->Caption = ftemp;
    if(bCombustion) //如果是燃烧过程,则计算燃烧始点、及供油始点；
    {
         //计算燃烧提前角度，实际是压力升高率突然增大的角度至上止点的位置
        fCombustionAngle = (icombustionposi - iTDPosi)*fAngleStep;
        iCombustionPosi  = icombustionposi;
    }
    else   //如果不是燃烧过程，那么就置燃烧始点为0
    {
        fCombustionAngle = 0.0;
        while(fpDPDF[iTDPosi] > 0.0)
        {
            iTDPosi ++;
        }
        iCombustionPosi  = iTDPosi;
    }

    if(bOilSupply)
    {
//------------------------------------------------------------------------
//  此段代码用于修正时间滞后 ,分别考虑了油管及测压通道的滞后现象　
        float fL,fA,fOilL,fOilA,ftemp1,ftemp2,ftemp3;
        fL = 0.4;                                     //气缸内距检爆阀端部的距离
        fA = 400.0 + (fEn - 400.0)*300.0/600.0;       //检爆阀内气体传播速度
//        fOilL = 0.15;                                 //夹持式传感器距喷油泵端的距离

        fOilL = 0.25;                                 //夹持式传感器距喷油泵端的距离

        fOilA = 700.0 + (fEn - 400.0)*600.0/600.0;    //燃烧传播的音速
        ftemp1 = 6.0*fEn*fOilL/fOilA;
        ftemp2 = 6.0*fEn*fL/fA;                       //滞后的度数
//  下面这个公式主要是考虑了进油孔节流的问题          //假设每100转内变化1.2度

//        ftemp3 = 1.5 + (fEn - 400.0)*1.1/100.0;
        ftemp3 = 0.0;

        iOilShiftNum = (ftemp3 + ftemp2 - ftemp1)/fAngleStep; //  fL = 320mm　燃烧室至传感器的距离
                                      //  fA = 600m/s 通道内音速

//------------------------------------------------
// 暂时先不考虑测量数据的滞后现象
// 2006年4月21日
        iOilShiftNum = 0;
//将油管数据移至相应位置

        CorrectOilPosi();
//========================================================================================
//========================================================================================
        if(   (LFHS.siPassageStatus[1] == 1)  //如果通道二是处于打开状态，
          )
        {
            float iDPMax;
            //-----------------------------------
            //先设波形标准为0.15和0.35
            fLevelStart = 0.10;
            fLevelEnd   = 0.30;
            //===================================
//            iOilPosi = AnalysisOilAngle(0);
            iOilPosi = CalculateOilPosi();
            if( (iCombustionPosi - iOilPosi)*fAngleStep > 28.0 )
            {
                fLevelStart = 0.15;
                fLevelEnd   = 0.35;
            //===================================
                iOilPosi = CalculateOilPosi();
            }
            CalculateOilParameters();
        }
    }
    else
    {
        iOilPosi             = iTDPosi;
        iCombustionPosi      = iTDPosi;
        LFHS.fWavePeriod     = 0.0;
        LFHS.fWaveCoef       = 0.0;
        LFHS.iOilPosi        = iTDPosi;
        LFHS.iCombustionPosi = iTDPosi;
    }
    iTDPosiBackup     = iTDPosi;
    iTDCStep          = 0;
    bTDPosiCalculated = true;    //表示上止点已计算出来
    FormMain->LabelDPDF->Caption = fDPDFLocalMax;
    return true;
}


void __fastcall lDieselHRBP::lFilterOriginal(float * fhh, int ihlen, int ip)
{
    //TODO: Add your source code here
    //对输入数据fodata进行滤波处理，
    //输入：
    //　ipac 原始数据
    //　fFData 保存滤波后的数据
    //  h      滤波器数据
    //　ilen   原始数据长度
    //  ihlen  滤波器长度
/*
    float* fhh: 滤波器数组
    int   ihlen: 滤波器长度
*/
    //输出：
    //　fFData　为滤波处理后的数据
 	int ib,id;
    float fb;
    float ftemp;
    int   itemp;
    int ilen;
    int iCStart;
    int iCEnd;
    ilen = iOriginalLength;     //提取出来的数据长度
    iCStart = ihlen/2;
    iCEnd   = ilen - iCStart;   
    ipOData[2][0] = (ipOData[ip][0]+ipOData[ip][1])/2 ;
    for( id = 1; id < iCStart;  ++id)
    {
    	 itemp = 0;
    	 for(ib = id - 1; ib <= id +1; ++ ib)
    	 {
    	 	itemp += ipOData[ip][ib];
    	 }
    	 ipOData[2][id] = itemp/3;
    }

    for(id = iCStart; id < iCEnd; ++ id)
    {
    	fb = 0.0;
/*
        for(ib=0;ib<ihlen;ib++)
        {
        	if((id-ib-iCStart)<0)
        	{
        		break;
        	}
        	itemp = ipac[id - ib];
        	ftemp = (float)itemp;
        	fb += h[ib]*ftemp;
        }
*/
        for(ib=0; ib<ihlen; ++ib)
        {
//        	itemp = ipac[id - iCStart + ib];
            itemp = ipOData[ip][id - 27 + ib];
        	ftemp = (float)itemp;
        	fb   += fhh[ib]*ftemp;
        }

        ipOData[2][id] = fb;
    }

    ipOData[2][ilen - 1] = (ipOData[ip][ilen-2]+ipOData[ip][ilen -1])/2.0;
    for( id = iCEnd; id < iOriginalLength - 1;  ++id)
    {
    	 itemp = 0;
    	 for(ib = id - 1; ib <= id +1; ++ ib)
    	 {
    	 	itemp += ipOData[ip][ib];
    	 }
    	 ipOData[2][id] = itemp/3.0;
    }

//------------------------------------------------------------
/*
//对滤波数据进行测试
    FILE* fp;
    AnsiString strTemp;
    if(ip == 0)
    {
        strTemp = FormMain->strExeFilePath + "AFir_Test_P1.dat";
    }
    else
    {
        strTemp = FormMain->strExeFilePath + "AFir_Test_P2.dat";
    }
    if(( fp = fopen(strTemp.c_str(), "w")) != NULL)
    {
        for( int i  = 0; i < iOriginalLength;  ++i )
        {
            fprintf(fp, "%d %d %d\n", i,ipOData[ip][i], ipOData[2][i]);
        }
        fclose(fp);
    }
//============================================================
*/
}
void __fastcall lDieselHRBP::lFilterData(float * fhh, int ihlen)
{
    //对输入数据fodata进行滤波处理，
    //输入：
    //　ipac 原始数据
    //　fFData 保存滤波后的数据
    //  h      滤波器数据
    //　ilen   原始数据长度
    //  ihlen  滤波器长度
/*
    float* fhh: 滤波器数组
    int   ihlen: 滤波器长度
*/
    //输出：
    //　fFData　为滤波处理后的数据
 	int ib,id;
    float fb;
    float ftemp;
    int   itemp;
    int ilen;
    int iCStart;
    int iCEnd;
    ilen = iAbstractLength;     //提取出来的数据长度
    iCStart = ihlen/2;
    iCEnd   = ilen - iCStart;
    fpFData[0] = (ipac[0]+ipac[1])/2 ;
    for( id = 1; id < iCStart;  ++id)
    {
    	 itemp = 0;
    	 for(ib = id - 1; ib <= id +1; ++ ib)
    	 {
    	 	itemp += ipac[ib];
    	 }
    	 fpFData[id] = itemp/3;
    }

    for(id = iCStart; id < iCEnd; ++ id)
    {
    	fb = 0.0;
/*
        for(ib=0;ib<ihlen;ib++)
        {
        	if((id-ib-iCStart)<0)
        	{
        		break;
        	}
        	itemp = ipac[id - ib];
        	ftemp = (float)itemp;
        	fb += h[ib]*ftemp;
        }
*/
        for(ib=0; ib<ihlen; ++ib)
        {
//        	itemp = ipac[id - iCStart + ib];
            itemp = ipac[id - 27 + ib];
        	ftemp = (float)itemp;
        	fb   += fhh[ib]*ftemp;
        }

        fpFData[id] = fb;
    }

    fpFData[ilen - 1] = (ipac[ilen-2]+ipac[ilen -1])/2.0;
    for( id = iCEnd; id < iAbstractLength - 1;  ++id)
    {
    	 itemp = 0;
    	 for(ib = id - 1; ib <= id +1; ++ ib)
    	 {
    	 	itemp += ipac[ib];
    	 }
    	 fpFData[id] = (float)itemp/3.0;
    }
}

void __fastcall lDieselHRBP::CalibrateData(float *fnew,float* fold,int ilen)
{
//  将测量的数据转换为具体的物理量
	int i;
	GetfST0(0);                        //获取第一通道的标定系数
	for(i=0; i<ilen; ++i)
	{
		fnew[i] = fST0*fold[i]/32767.0;
	}
}

void __fastcall lDieselHRBP::LocatePeak(void)
{
// LocatePeak 计算所测量波形的峰值个数及位置
// 根据燃烧压力曲线来确定
// iTopPosi[50];最多保存50个峰值的位置
// iTopNum ;    峰值的个数
    int i,k;
    float ftemp;
    int  itemp;
    bool  bGetOne;
    int iStart,iEnd;
    int iAbStartPosi = 500;
    int iAbStractLength;
    int ibyposi;
    int iposition;
    int iposi;

    float fratio;
    float fAbMax,fmax1,fmax2;
    int kkey;
// 先设缸压位于通道1
    bGetOne = false;
    ipData = ipOData[0];
    ipa    = ipAData[0];
    ipac   = ipACData[0];
    iSampleNum = 0;
    if(ipData != NULL)
    {
  		if(iCycleNum == 0)
  		{
  			iSampleNum = 0;
  			return;
  		}
        while(TRUE)
        {
 	        do
    	    {
        	    if((iAbStartPosi+iAbstractLength) > iOriginalLength)
            	{
                	bGetOne = FALSE;
	                break;
    	        }
        	    itemp  = ipData[iAbStartPosi];
            	iStart = iAbStartPosi+1;
	            iEnd   = iAbStartPosi + 2*IHALFLENGTH;
    	        for(i  = iStart; i<iEnd;i++)
        	    {
            	    if(itemp<ipData[i])
                	{
	                    itemp = ipData[i];
    	                iposi = i;
        	        }
            	}
            	if( iposi + (iAbstractLength - IHALFLENGTH) > iOriginalLength)
	            {
    	            bGetOne = FALSE;
        	        break;
            	}
	            if(iposi > IHALFLENGTH)
    	        {
        	        bGetOne = TRUE;
        			for(k = 0; k < PASSAGENUM; k++)
        			{
            	    	if(LFHS.siPassageStatus[k] == 1) //如果该通道处于打开状态
            	    	{
            	    		for(i = 0; i<iAbstractLength;i++)
	                		{
    	                		ipAData[k][i] = ipOData[k][iposi - IHALFLENGTH + i];
    	                	}
						}
                	}
                	fAbMax = (float)itemp;
	                if(iSampleNum == 0)
    	            {
        	            fAbMax = (float)itemp;
        	            fmax1 = fAbMax;
    	    			for(k = 0; k < PASSAGENUM; k++)
	    	   			{
            		    	if(LFHS.siPassageStatus[k] == 1) //如果该通道处于打开状态
            		    	{
            	    			for(i = 0; i<iAbstractLength;i++)
	                			{
    	                			ipACData[k][i] = ipAData[k][i];
		  	                	}
							}
            	    	}
            	        iTDPosi = iposi - iAbStartPosi;  //暂时将上止点位置定在最大压力位置
            	        if(iSampleNum < 50)
            	        {
							iTopPosi[iSampleNum] = iposi;
							iTopNum              = iSampleNum + 1;
						}
                	}
	                else
    	            {
        	            fratio = (fAbMax - (float)itemp)/fAbMax;
	                    ibyposi = DetectPosi(ipa,ipac);
    	                if( fabs(fratio)<1.5)   //剔除突变的压力值
        	            {

	         				for(k = 0; k < PASSAGENUM; k++)
		        			{
    		        	    	if(LFHS.siPassageStatus[k] == 1) //如果该通道处于打开状态
        		    	    	{
            			    		for(i = 0; i<iAbstractLength;i++)
	            		    		{
                        		    	iposition = iposi - IHALFLENGTH + ibyposi + i;
                            			ipACData[k][i] += ipOData[k][iposition];
    	                			}
								}
    		            	}
    		            	iTDPosi = iposi - iAbStartPosi;
    		            	if(iSampleNum < 50)
    		            	{
    		            		iTopPosi[iSampleNum] = iposi;
    		            		iTopNum              = iSampleNum + 1;
    		            	}
                	        fAbMax = (fAbMax + ftemp)/2.0;
                    	}
	                    else
    	                {
        	                bGetOne = FALSE;
            	        }
                	}
            	}
            	else
	            {
    	            bGetOne = FALSE;
        	    }
            	iAbStartPosi += iAbstractLength;
        	}while(!bGetOne);

		 	if(!bGetOne)                        //已没有可用于提取的数据了
    		{
        		if(iSampleNum !=0)
        		{
    	    		for(k = 0; k < PASSAGENUM; k++)
	    	   		{
            	    	if(LFHS.siPassageStatus[k] == 1)        //如果该通道处于打开状态
            	    	{
            	   			for(i = 0; i<iAbstractLength;i++)
	               			{
	               				ipACData[k][i]  /= iSampleNum;
		  	               	}
						}
            	   	}
        		}
	       		break;
    		}
    		else
    		{
            	if(iSampleNum == 0)
                {
                	fmax1 = fAbMax;
        	    }
            	else
            	{
                	fmax2 = fAbMax;
                	if(fabs((fmax1-fmax2)/fmax1)>1.5)   //剔除波形峰值不正常的
                	{
                    	iDeleteNum++;
                    	continue;
                	}
            	}
            	iSampleNum ++;                          //使获取的样本数加一
            }
        } //--------------------------------------------- end of while(TRUE)
    }   //----------------------------------------------- end of if(ipData != NULL)
}

//2005_02_16添加,当程序中只保留总体平均后，调用此函数

bool __fastcall lDieselHRBP::ReadOriginalDataHead(char* strfileName)
{
    //TODO: Add your source code here
    bool bRet = false;
    FILE * fp;
    void * ptLFHS;
    AnsiString strNN;
    ptLFHS  = (void*)&LFHS;
    strNN   = AnsiString( strfileName);
    strNN   = ::ExtractFileExt(strNN);
    strNN   = strNN.UpperCase();

    if(strNN == ".ORG")
    {
        if((fp = fopen(strfileName,"rb")) != NULL)
        {
            fread(ptLFHS,sizeof(lFileHeadStruct),1,fp);
            strNN = LFHS.str902Mark;
            if(strNN == "902" )
            {
                bRet = true;
            }
            fclose(fp);
        }
    }
    return bRet;
}

bool __fastcall lDieselHRBP::ReadOriginalData_New(char* strfileName, bool bCalculate)
{
    //TODO: Add your source code here
    float ftemp1,ftemp2,ftemp;
    int   inum = 0;
    int   ireadsize = 0;

    int countmid = 0 , countstart=0 , countend=0 ;      /////////FX：后添加，用于二通道显示

    FILE * fp;
    FILE * fpsave;
    void * ptLFHS;
    AnsiString strNN;
    lShort    ls;
    ptLFHS = (void*)&LFHS;
    bOrgFileOpened = false;
    iDeleteNum     = 0;      //初始化剔除的数据样本个数
    iSampleNum     = 0;      //初始化提取出来的数据样本个数

    strNN          = AnsiString( strfileName);
    strNN          = ::ExtractFileExt(strNN);
    strNN          = strNN.UpperCase();
    if(strNN == ".ORG")
    {
        if((fp = fopen(strfileName,"rb")) != NULL)
        {
            fread(ptLFHS,sizeof(lFileHeadStruct),1,fp);
            strNN = LFHS.str902Mark;
//            int isze = sizeof(float);
            if(strNN != "902" )
            {
                Application->MessageBox("文件格式不对!","提示",MB_OK|MB_ICONINFORMATION);
                fclose(fp);
                return false;
            }
            if((LFHS.siTrainType == 4)    //8B
               ||(LFHS.siTrainType == 5)  //11
               ||(LFHS.siTrainType == 9)  //11G
               )
            {
                fAllAngle = 35.8;
                fDeltaAngle = 15.0;
            }
            else
            {
                fAllAngle = 36.0;
                fDeltaAngle = 16.0;
            }

            if(strTempData != NULL)
            {
                delete [] strTempData;
                strTempData = NULL;
            }
            iOriginalLength = LFHS.iLength;
            //调试暂时修改处
            /*
            ////////////////////////////////////////////////////////////////
            //////////////////////////FX修改处//////////////////////////////
            ////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////
            LFHS.siPassOpenNum      = 1;       //////////////////FX注释：此处临时添加,打开通道临时改为1
            LFHS.siPassageStatus[0] = 0;       //////////////////FX注释：此处临时添加，关闭二通道数据读取，我们是单通道分析
            LFHS.siPassageStatus[1] = 1;
            LFHS.siDataValid        = 0;       //////////////////FX注释：此处临时添加，为了让程序后面进入数据分析 GetfEn，表示数据无效，不是原数据
            LFHS.iRFrequency        = 5000;    //////////////////FX注释：此处临时添加， 采集频率有10K和5K可能，前面几次采集都是5K
            LFHS.siFrequency        = 15;
            LFHS.fSensitivity[0]    =210;      //////////////////FX注释：灵敏度此处是传感器用的21，然后*10
            LFHS.siSignalGain[1]    = 2;
            LFHS.siSignalGain[0]    = 2;
            ////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////
            */
            ireadsize = 2*((LFHS.siPassOpenNum)*iOriginalLength);
            strTempData = new unsigned char[ireadsize];
            if(strTempData == NULL)
            {
                return false;
            }
            ptLFHS = (void*) strTempData;
            fread(ptLFHS,ireadsize,1,fp);
            fclose(fp);

            iAbstractLength = LFHS.iAbstractLength;
            inum            = iOriginalLength;
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }

    if(!FormMain->SetDieselInfo(LFHS.siTrainType, false))
    {
        return false;
    }
    //分配内存
    if(!AllocateOriginalMemory(inum))
    {
        return false;
    }
    int itemplen;
    int ippnum = 0;

// 读入第一通道的数据
//------------------------------------------------------
    if(LFHS.siPassageStatus[0] == 1)  //如果该通道打开，
    {
        for(int j=0; j<inum; j++)
        {
            itemplen = 2*(ippnum*iOriginalLength + j);
            ls.ch[0] = strTempData[itemplen];
            ls.ch[1] = strTempData[itemplen + 1];
            ipOData[0][j] =  ls.iData;
        }
        ippnum++;
    }
    else                          //如果没有打开就置为零
    {
        for(int j=0;j<inum;j++)
        {
            ipOData[0][j] = 0;
        }
    }
//=======================================================

// 读入第二通道的数据
    if(LFHS.siPassageStatus[1] == 1)
    {
        for(int j = 0; j < inum; j ++)
        {
            itemplen       = 2*(ippnum*iOriginalLength + j);
            ls.ch[0]       = strTempData[itemplen];
            ls.ch[1]       = strTempData[itemplen + 1];
            ipOData[1][j]  = ls.iData;
        }

        ippnum++;
    }
    else
    {
        for(int j=0; j<inum; j++)
        {
            ipOData[1][j] = 0;
        }
    }
//============================================================

// 读入第三通道的数据
//------------------------------------------------------------
    if(LFHS.siPassageStatus[2] == 1)
    {
        for(int j=0; j<inum; j++)
        {
            itemplen = 2*(ippnum*iOriginalLength + j);
            ls.ch[0] = strTempData[itemplen];
            ls.ch[1] = strTempData[itemplen + 1];
            ipOData[2][j] = ls.iData;
        }
        ippnum++;
    }
    else
    {
        for(int j=0; j<inum; j++)
        {
            ipOData[2][j] = 0;
        }
    }

    if(LFHS.siDataValid == 1)    // 如果数据有效，则读入最大值的参数
    {
            // 读入各个波形的峰值
        for(int i = 0; i < LFHS.siSetSampleNum; i ++ )
        {
            itemplen = 2*(iAbstractLength + i);
            ls.ch[0] = strTempData[itemplen];
            ls.ch[1] = strTempData[itemplen + 1];
            fAbMMax[i] = ls.iData;
        }
    }
    if(LFHS.siPassageStatus[1] == 1)
    {
        int iimin,iimax,iimaxposi;
//        iGetMinMax(ipOData[1], iAbstractLength, iimin, iimax, iimaxposi);
//        fOilPMin   = (float)iimin;
//        fOilPMax   = (float)iimax;
    }

//=======================================================
//删除数据缓存区
//-------------------------------------------------------
    if(strTempData != NULL)
    {
        delete [] strTempData;
        strTempData = NULL;
    }
//=======================================================
// 对原始数据进行滤波处理，并保存到第三通道的位置上去，以便绘图
    lFilterOriginal(hm, 55, 0);
    //计算柴油机转速
    //计算柴油机转速

////////////////////////////////////////////////////
////FX：后来加上，为了显示第二通道采集部分
////////////////////////////////////////////////////

 if( LFHS.siPassageStatus[0] != 0)
 {
    if( LFHS.siDataValid == 0) //如果数据无效
    {
        fEn = GetfEn(false,0,LFHS.iRFrequency*2.56);
    }
    else
    {
        fEn             = LFHS.fEn;
        fEngineSpeed    = fEn;
        fTimeInterval   = LFHS.fTimeInterval;
        fAngleStep      = LFHS.fAngleStep;    //近似计算曲轴转角间隔
        iAbstractLength = LFHS.iAbstractLength;
        fCPMax          = LFHS.fCPMax;
        fDelta          = LFHS.fP1RMS;
    }

    if(fEn > 100.0)
    {
        if(!AllocateAbstractMemory(iAbstractLength))
        {
            return false;
        }

        if( LFHS.siDataValid == 0)
        {
            //数据叠加后再进行滤波处理，主要是保持与测试仪的同步
            bParameterAbstracted = false;
//        GetMinMax(fpFData,iAbstractLength,fCPMin,  fCPMax,  fCPMaxPosi,false);
            LocatePeak();               //确定波形的峰值位置
                                        //对波形进行叠加计算结束之后
        }
        else   //对数据缓冲区进行设置
        {
                // 将数据移至累加的地址上去
            for(int i = 0; i < iAbstractLength; i ++)
            {
                ipACData[0][i] = ipOData[0][i];
                ipACData[1][i] = ipOData[1][i];
                ipACData[2][i] = ipOData[2][i];
            }
            ipData = ipOData[0];
            ipa    = ipAData[0];
            ipac   = ipACData[0];
            iSampleNum = LFHS.siSetSampleNum;
        }
//　第0步：测试------------------------------------------------------------- //Debug
/*
        for(int i = 0; i < iAbstractLength; i ++)
        {
            fpFData[i] = ipACData[0][i];
        }
    	GetMinMax(fpFData,iAbstractLength,fCPMin,  ftemp1,  fCPMaxPosi,false);
*/
//--------------------------------------------------------------------------
//　第1步：对原始数据进行滤波       hh:400Hz

        lFilterData(hh,55);         //用hh滤波器对提取数据的数据进行滤波处理
//    	GetMinMax(fpFData,iAbstractLength,fCPMin,  ftemp1,  fCPMaxPosi,false);     //Debug

//        lDirectData();            //看看在不滤波状态下的数据情况
//==========================================================================

//--------------------------------------------------------------------------
//  第2步：对提取的数据进行标定
        CalibrateData(fpFData,fpFData,iAbstractLength);       //对提取出来的数据进行标定

    	GetMinMax(fpFData,iAbstractLength,fCPMin,  ftemp1,  fCPMaxPosi,false);      //Debug
//--------------------------------------------------------------------------
//  第3步：对压力进行光顺处理
//        lSmoothCurve(fpFData,fpSMData,iAbstractLength);
//==========================================================================

//      	lDPDF(ipOData[0],ipOData[2],iOriginalLength);
//--------------------------------------------------------------------------
// 第4步：计算压力升高率    2004-05-21 将程序改得与仪器一样
        lDPDF(fpFData,fpSMDPDF,iAbstractLength);

    	GetMinMax(fpSMDPDF, iAbstractLength,fDPDFMin,fDPDFMax,fDPDFMaxPosi,false);
//==========================================================================

// 第5步：对压力升高率进行滤波处理
//--------------------------------------------------------------------------
          lFilterData(fpSMDPDF,fpDPDF,iAbstractLength,0);
    	  GetMinMax(fpDPDF, iAbstractLength,fDPDFMin,fDPDFMax,fDPDFMaxPosi,false);

//        lFilterData(fpDPDF,fpSMDPDF,iAbstractLength,0);   //2004-05-021
//==========================================================================

        if(!FormMain->CheckBoxValue->Checked)
        {
// 2005_01_26
//--------------------------------------------------------------------------
// 第6步 将滤波后的数据反置给fpDPDF;
            for(int i = 0; i < 55; i++)
            {
                fpDPDF[i] = 0.0;
            }
            for(int i = iAbstractLength - 55; i<iAbstractLength; i++)
            {
                fpDPDF[i] = 0.0;
            }
//==========================================================================

//--------------------------------------------------------------------------
//	        DetectTopDeadPosi_New();  //判断上止点的位置, iTop ReadOriginal_New
            if(!DetectTopDeadPosi_New_Two())  //判断上止点的位置, iTop ReadOriginal_New
            {
                return false;
            }
//==========================================================================

//--------------------------------------------------------------------------
//    上止点确定以后，重新用较高的滤波器对原始数据滤波
            lFilterData(hm,55);   //用hm滤波器对提取数据的数据进行滤波处理
            CalibrateData(fpFData,fpFData,iAbstractLength);       //对提取出来的数据进行标定
            lDPDF(fpFData,fpSMDPDF,iAbstractLength);
// test -------------------------------------------------------------------------------
            GetMinMax(fpSMDPDF, iAbstractLength,fDPDFMin,fDPDFMax,fDPDFMaxPosi,false);
//=====================================================================================
//            lFilterData(fpSMDPDF,fpDPDF,iAbstractLength,0);
//            SetArrayZero(fpDPDF, iAbstractLength, 110);
            for( int i = 0; i < iAbstractLength; i++)
            {
                fpDPDF[i] = fpSMDPDF[i];
            }
//            GetMinMax(fpDPDF, iAbstractLength,fDPDFMin,fDPDFMax,fDPDFMaxPosi,false);
            fDPDFMaxPosi = (fDPDFMaxPosi - iTDPosi)*LFHS.fAngleStep;
//===========================================================================

//      lDPDF(ipACData[0],ipACData[2],iAbstractLength);
            if(!bTDPosiCalculated)
            {
                return false;
            }
//            iNormalLength = 1440;        //原来是1440个数据点
            iNormalLength = iNumPerAngle*720;
            if(!AllocateMemory(3600))//iNormalLength))  //  iNormalLength = 3600
            {
                return false;
            }
        	AbstractNormalP();  //在这里对压力升高率进行了计算

            LFHS.fTimeInterval = fTimeInterval;
            LFHS.fAngleStep    = fAngleStep;
            LFHS.siCombustion  = bCombustion;
            LFHS.fEngineSpeed  = fEn;
            LFHS.fOilAngle     = fOilAngle;
            LFHS.fCombustionAngle = fCombustionAngle;
            sprintf(LFHS.strTrainNum,"%04d\0",LFHS.iTrainNum);

            if(bCalculate)  //如果要对提取的数据进行计算
            {
                GetMinMax(fOldP,iNormalLength,fMinOldP,fMaxOldP,fMaxOldPPosi,true);
   //             fMaxOldP -= fMinOldP;
                ModifyPressure(fNewP,iNormalLength);
                CalculateFactor();                    //计算绝热指数

                GetMinMax(fNewP,iNormalLength,fNormalPMin, fNormalPMax,fNormalPMaxPosi,true);
                GetMinMax(farDPDF,iNormalLength,fDPDFMin, fDPDFMax,    fDPDFMaxPosi,true);
                fDPDFMaxFai = fDPDFMaxPosi;
                fPMaxFai    = fNormalPMaxPosi;
   //             fNormalPMax -= fNormalMin;
//如果把下一行关闭，则压力升高率是通过插值计算出来的
//        lDPDF(fNewP,farDPDF,fFFFai,iNormalLength);
// 如果在此处计算压力升高率，则计算结果与仪器中的不一样 ????????????????????????????
//                GetMinMax(farDPDF,iNormalLength,fDPDFMin, fDPDFMax,    fDPDFMaxPosi,true);
         	    GetMinMax(farV,iNormalLength,   fCVMin,   fCVMax,      ftemp,false);
                GetLogPLogV();
    	        GetMinMax(farLogP,iNormalLength,fLogPMin, fLogPMax,    ftemp,false);
                GetMinMax(farLogV,iNormalLength,fLogVMin, fLogVMax,    ftemp,false);
                fFFFaiMin = fFFFai[0];
                fFFFaiMax = fFFFai[iNormalLength - 1];
                iPLength = iNormalLength;
                CalculateFFTP();     //计算频域数据
                LFHS.fHeatAll  = 0.0;
                LFHS.fCPower   = 0.0;
                if(bCombustion)
                {
                  //  TJHeatRelease();     //计算放热率
                    HeatRelease();
                    CalculateCHRR();     //计算累积放热率
                    GetMinMax(fDHDF,iNormalLength,fHRRMin,fHRRMax,fDHDFMaxFai,true);
                    GetMinMax(fCDHDF,iNormalLength,fCHRRMin,fCHRRMax,fCDHDFMaxFai,false);
                    LFHS.fHeatAll      = fCHRRMax;       //总放热量
                    FormMain->iCCStart = iStartFai;
                    FormMain->iCCEnd   = iEndFai;
                }
                else
                {   //如果没有燃烧过程，则要对它进行初始化
                    fHRRMin          = 0.0;
                    fHRRMax          = 0.0;
                    fDHDFMaxFai      = 0.0;
                    fCHRRMin         = 0.0;
                    fCHRRMax         = 0.0;
                    fCDHDFMaxFai     = 0.0;
                    fFirstDHDFMax    = 0.0;
                    fFaiFirstDHDFMax = 0.0;
                    fDHDFMax         = 0.0;
                    fFaiDHDFMax      = 0.0;
                }
                CalculatePower();  //计算循环功
                LFHS.fCPower       = fCPower;        // 循环功

            }

// 2005_01_26
        }
        else
        {
            CalibrationData();
        }
        return true;
    }
    return false;
  }
 else   //对数据缓冲区进行设置     //////////////FX修改
 {
      //分配地址
      iAbstractLength = 0.5*GetfEn2_length(false,1,LFHS.iRFrequency*2.56);    //////////////数据长度

      if(!AllocateAbstractMemory(iAbstractLength))
        {
            return false;
        }
      if(!AllocateMemory(3600))//iNormalLength))  //  iNormalLength = 3600
            {
                return false;
            }
        /*
        for(int i = 1; i < iOriginalLength; i ++)
        {
         if( ( ipOData[1][i] <= ipOData[1][i - 1] ) && ( ipOData[1][i] > 1000)  )    //当且仅当该值比前面值大，且最大值比1000大
           {
            countmid =  i-1 ;

             break ;
             }
          }
         ////////////////////////防止越界///////////////////////////////
         if ( countmid == 0)
         	    
             return false ;
         if ( (countmid - int(iAbstractLength/2)) < 0 )
             countstart = 0 ;
         else
             countstart = countmid - int(iAbstractLength/2);
         if ( (countmid + int(iAbstractLength/2)) > iOriginalLength )
             countend = iOriginalLength ;
         else 
             countend = countmid + int(iAbstractLength/2);
          */
         //////////////////////载入采样数组///////////////////////////// 	       
         for(int a = 0  ; a < iAbstractLength; a ++)
           {
            ipACData[0][a] = 0;
            ipACData[1][a] = ipOData[1][a + iAbStartPosi];
             }
         return true;
    }
}

int __fastcall lDieselHRBP::GetfEn2_length(bool bFrom,int iP,float fFre)
{
//    bool  bFrom: true:从通道1的测试数据中计算
//    int   iP :        通道标识     1：通道一   2：通道二   3:通道三
//    float fFre :      信号的采样频率
//    原始数据保存在f
//TODO: Add your source code here
    float fSpeed = 0.0;
    int  * ipData = NULL;
    switch( iP )
    {
        case 0:
        {
            ipData = ipOData[0];
            break;
        }
        case 1:
        {
            ipData = ipOData[1];
            break;
        }
        case 2:
        {
            ipData = ipOData[2];
            break;
        }
        default:
        {
            return 0.0;
        }
    }
    int   fmax = 0.0;
    int   iZeroMax = 0;
    int   istartposi,iendposi;
    int   iPosi,iPosi1, iPosi2,iPosi3;
    int   iMaxNum = 0;

    int   isWinLen = 1000;
    int   isStepLen = 200;
    int   ibacklimit;
    int   iAverage = 0;
    bool  bPosi1 = false,bPosi2 = false,bPosi3 = false;
    bool  bValue = false;
    int i,j;

    ibacklimit = isWinLen - 30;
    iendposi = 14000;
    if(iendposi > iOriginalLength)
    {
        iendposi = iOriginalLength;
    }
    for(int ii=0; ii<iendposi; ii += 10)
    {
        iAverage += ipData[ii];
        if( iZeroMax < ipData[ii] )
        {
            iZeroMax = ipData[ii];
        }
    }
    iAverage = iAverage * 10 /iendposi;
    /*
    if((iZeroMax - iAverage) < 500)    //用于判断是否含有有效数据,如果小于1500则认为不是有效数据
    {
    	fEn        = 0.0;
    	iSampleNum = 0;
    	iCycleNum  = 0;
		return  0.0;
    }   */
    iZeroMax = iAverage + ((iZeroMax - iAverage) *3)/5;
    
    for( i = 0; i < iOriginalLength - isWinLen; i += isStepLen) //(????????)
    {
        fmax = ipData[i];
        for( j = i; j< i + isWinLen; j += 4)        // (1) 由2改为4
        {
            if( ipData[j] > fmax ) //iZeroMax)
            {
                fmax = ipData[j];
                istartposi = j;
            }
        }
        if( ( istartposi < i + 30 )||( istartposi > i + ibacklimit ) )
        {
            continue;
        }
        if(fmax < iZeroMax)
        {
            continue;
        }
        if(istartposi < 2500)      //如果这个点位于2500以后，否则重新查找不太容易找到整个循环
        {
            continue;
        }
        if(!bValue)
        {
            iPosi = istartposi ;
            fmax = 0.0;
            bValue = true;
            iMaxNum = 1;
        }
        else
        {
            if(iPosi == istartposi)
            {
                iMaxNum ++;
                if(iMaxNum < 2)   //此处的判断是用于这个峰值至少应出现3次才行
                {
                    continue;
                }
                if(!bPosi1)
                {
                    iPosi1 = istartposi;
                    bPosi1 = true;
                    bValue = false;
                    fmax = 0;
                    iMaxNum = 0;
                    i += isWinLen*2;
                }
                else if(!bPosi2)
                {
                    iPosi2 = istartposi;
                    bPosi2 = true;
                    bValue = false;
                    fmax   = 0;
                    iMaxNum = 0;
                    i += isWinLen*2;
                }
                else if(!bPosi3)
                {
                    iPosi3 = istartposi;
                    bPosi3 = true;
                    bValue = false;
                    iMaxNum = 0;
                    break;
                }
            }
            else
            {
                iPosi = istartposi;
            }
        }
    }
    if (bPosi1&&bPosi2&&bPosi3)
    {
        iCycleNum = (iPosi3 - iPosi1)/2;
        IHALFLENGTH = iCycleNum/4;
        iaStartPosi = iPosi2 - IHALFLENGTH;
    }
    else if( bPosi1 && bPosi2)
    {
        iCycleNum = iPosi2 - iPosi1;
        IHALFLENGTH = iCycleNum/4;
        iaStartPosi = iPosi2 - IHALFLENGTH;
    }
    else if( bPosi1)
    {
        iCycleNum = iPosi1*2;
        IHALFLENGTH = iCycleNum/4;
        iaStartPosi = iPosi1 /2;
       }
    else
    {
        iCycleNum = 0;
        IHALFLENGTH = iCycleNum/4;
        iaStartPosi = 0;
    }
     //  FX:  提高鲁棒性操作
     if ((bPosi1&&bPosi2&&bPosi3)&&( iaStartPosi<0 ) )
          {    iaStartPosi = iPosi3 - IHALFLENGTH;
               if(iaStartPosi<0 )
                  iaStartPosi = 0 ; }
     if ((bPosi1&&bPosi2&&(!iPosi3))&&( iaStartPosi<0 ) )
               iaStartPosi = 0;


     iAbstractLength = iCycleNum;
     iAbStartPosi    = iaStartPosi;

     //防止终点大于数据长度
     if ((iaStartPosi +iAbstractLength/2) > iOriginalLength )
           iAbstractLength = (iOriginalLength - iAbStartPosi-1)*2;
              
     return iAbstractLength;
 }

bool __fastcall lDieselHRBP::ReadOriginal(char* strfileName, bool bCalculated)
{
    bool ret;
    if( ReadOriginalDataHead(strfileName) )  //如果可以打开文件头
    {
        if(LFHS.chVersion != 0)
        {
            ret = ReadOriginalData_New(strfileName,bCalculated);
        }
        else
        {
            ret = ReadOriginalData(strfileName, bCalculated);
        }
    }
    return ret;
}

bool __fastcall lDieselHRBP::ReadOriginalData(char *strfileName,bool bCalculate)
{
    //TODO: Add your source code here
    float ftemp1,ftemp2,ftemp;
    int   inum = 0;
    int   ireadsize = 0;
    FILE * fp;
    FILE * fpsave;
    void * ptLFHS;
    AnsiString strNN;
    lShort    ls;
    ptLFHS = (void*)&LFHS;
    bOrgFileOpened = false;
    iDeleteNum     = 0;      //初始化剔除的数据样本个数
    iSampleNum     = 0;      //初始化提取出来的数据样本个数
    strNN          = AnsiString( strfileName);
    strNN          = ::ExtractFileExt(strNN);
    strNN          = strNN.UpperCase();
    if(strNN == ".ORG")
    {
        if((fp = fopen(strfileName,"rb")) != NULL)
        {
            fread(ptLFHS,sizeof(lFileHeadStruct),1,fp);
            strNN = LFHS.str902Mark;
            if(strNN != "902" )
            {
                Application->MessageBox("文件格式不对!","提示",MB_OK|MB_ICONINFORMATION);
                fclose(fp);
                return false;
            }
            if((LFHS.siTrainType == 4)    //8B
               ||(LFHS.siTrainType == 5)  //11
               ||(LFHS.siTrainType == 9)  //11G
               )
            {
                fAllAngle = 34.5;
                fDeltaAngle = 15.0;
            }
            else
            {
                fAllAngle = 35.0;
                fDeltaAngle = 15.8;
            }
            if(strTempData != NULL)
            {
                delete [] strTempData;
                strTempData = NULL;
            }
            ireadsize = 2*(LFHS.siPassOpenNum)*(LFHS.iLength);
            if(ireadsize == 0)
            {
                fclose(fp);
                Application->MessageBox("数据无效!","提示",MB_OK|MB_ICONINFORMATION);
                return false;
            }
            strTempData = new unsigned char[ireadsize];
            if(strTempData == NULL)
            {
                return false;
            }
            ptLFHS = (void*) strTempData;
            fread(ptLFHS,ireadsize,1,fp);
            fclose(fp);
            iOriginalLength = LFHS.iLength;
            inum = iOriginalLength;
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }

    if(!AllocateOriginalMemory(inum))
    {
        return false;
    }
    int itemplen;
    int ippnum = 0;

// 读入第一通道的数据
//------------------------------------------------------
    if(LFHS.siPassageStatus[0] == 1)  //如果该通道打开，
    {
        for(int j=0; j<inum; j++)
        {
            itemplen = 2*(ippnum*inum + j);
            ls.ch[0] = strTempData[itemplen];
            ls.ch[1] = strTempData[itemplen + 1];
            ipOData[0][j] =  ls.iData;
        }
        ippnum++;
    }
    else                          //如果没有打开就置为零
    {
        for(int j=0;j<inum;j++)
        {
            ipOData[0][j] = 0;
        }
    }
//=======================================================

// 读入第二通道的数据
    if(LFHS.siPassageStatus[1] == 1)
    {
        for(int j = 0; j < inum; j ++)
        {
            itemplen = 2*(ippnum*inum + j);
            ls.ch[0] = strTempData[itemplen];
            ls.ch[1] = strTempData[itemplen + 1];
            ipOData[1][j]  = ls.iData;
        }
        ippnum++;
    }
    else
    {
        for(int j=0; j<inum; j++)
        {
            ipOData[1][j] = 0;
        }
    }
//============================================================

// 读入第三通道的数据
//------------------------------------------------------------
    if(LFHS.siPassageStatus[2] == 1)
    {
        for(int j=0; j<inum; j++)
        {
            itemplen = 2*(ippnum*inum + j);
            ls.ch[0] = strTempData[itemplen];
            ls.ch[1] = strTempData[itemplen + 1];
            ipOData[2][j] = ls.iData;
        }
        ippnum++;
    }
    else
    {
        for(int j=0; j<inum; j++)
        {
            ipOData[2][j] = 0;
        }
    }
//=======================================================
    lFilterOriginal(hm, 55, 0);
//  	GetMinMax(fpFData,iAbstractLength,fCPMin,  fCPMax,  fCPMaxPosi,false);
    int iimin,iimax,iimaxposi;
    iGetMinMax(ipOData[2], iOriginalLength, iimin, iimax, iimaxposi);

//删除数据缓存区
//-------------------------------------------------------
    if(strTempData != NULL)
    {
        delete [] strTempData;
        strTempData = NULL;
    }
//=======================================================

    iOriginalLength = inum;
/*
    fpsave = fopen("e:\\save.dat","w");
    for(int m = iOriginalLength/2; m < iOriginalLength; m++)
    {
        fprintf(fpsave,"%d %d\n",m,ipOData[0][m]);
    }
    fclose(fpsave);
*/
    //计算柴油机转速
    float fre;
    fre = GetFrequency(LFHS.siFrequency);
    fEn = GetfEn(false,0,fre*2.56);

    if(fEn > 100.0)
    {
        if(!AllocateAbstractMemory(iAbstractLength))
        {
            return false;
        }

        //数据叠加后再进行滤波处理，主要是保持与测试仪的同步
        bParameterAbstracted = false;
//        GetMinMax(fpFData,iAbstractLength,fCPMin,  fCPMax,  fCPMaxPosi,false);
        LocatePeak();             //确定波形的峰值位置
//对波形进行叠加计算结束之后

//--------------------------------------------------------------------------
//　第1步：对原始数据进行滤波       hh:400Hz
        lFilterData(hh,55);         //用hh滤波器对提取数据的数据进行滤波处理
    	GetMinMax(fpFData,iAbstractLength,fCPMin,  fCPMax,  fCPMaxPosi,false);
//        lDirectData();            //看看在不滤波状态下的数据情况
//==========================================================================
/*
    FILE * fpp;
    fpp = fopen("e:\\filter650.dat","w");
    for(int i = 0; i< iAbstractLength; i++)
    {
        fprintf(fpp,"%d %d %.1f\n",i,ipACData[0][i],fpFData[i]);
    }
    fclose(fpp);
*/
//--------------------------------------------------------------------------
//  第2步：对提取的数据进行标定
        CalibrateData(fpFData,fpFData,iAbstractLength);       //对提取出来的数据进行标定
    	GetMinMax(fpFData,iAbstractLength,fCPMin,  fCPMax,  fCPMaxPosi,false);
//--------------------------------------------------------------------------
//  第3步：对压力进行光顺处理
//        lSmoothCurve(fpFData,fpSMData,iAbstractLength);
//==========================================================================

//      	lDPDF(ipOData[0],ipOData[2],iOriginalLength);
//--------------------------------------------------------------------------
// 第4步：计算压力升高率    2004-05-21 将程序改得与仪器一样
        lDPDF(fpFData,fpSMDPDF,iAbstractLength);
    	GetMinMax(fpSMDPDF, iAbstractLength,fDPDFMin,fDPDFMax,fDPDFMaxPosi,false);
//==========================================================================

// 第5步：对压力升高率进行滤波处理
//--------------------------------------------------------------------------
          lFilterData(fpSMDPDF,fpDPDF,iAbstractLength,0);
    	  GetMinMax(fpDPDF, iAbstractLength,fDPDFMin,fDPDFMax,fDPDFMaxPosi,false);
//        lFilterData(fpDPDF,fpSMDPDF,iAbstractLength,0);   //2004-05-021
//==========================================================================

        if(!FormMain->CheckBoxValue->Checked)
        {
// 2005_01_26
//--------------------------------------------------------------------------
// 第6步 将滤波后的数据反置给fpDPDF;
            for(int i = 0; i < 55; i++)
            {
                fpDPDF[i] = 0.0;
            }
            for(int i = iAbstractLength - 55; i<iAbstractLength; i++)
            {
                fpDPDF[i] = 0.0;
            }
//==========================================================================
//--------------------------------------------------------------------------
//	        DetectTopDeadPosi_New();  //判断上止点的位置, iTop ReadOriginal_New
            if(!DetectTopDeadPosi_New_Two())  //判断上止点的位置, iTop ReadOriginal_New
            {
                return false;
            }
//==========================================================================

//--------------------------------------------------------------------------
//    上止点确定以后，重新用较高的滤波器对原始数据滤波
            lFilterData(hm,55);   //用hm滤波器对提取数据的数据进行滤波处理
            CalibrateData(fpFData,fpFData,iAbstractLength);       //对提取出来的数据进行标定
            lDPDF(fpFData,fpSMDPDF,iAbstractLength);
            lFilterData(fpSMDPDF,fpDPDF,iAbstractLength,0);
            SetArrayZero(fpDPDF, iAbstractLength, 110);
            GetMinMax(fpDPDF, iAbstractLength,fDPDFMin,fDPDFMax,fDPDFMaxPosi,false);
//===========================================================================

//      lDPDF(ipACData[0],ipACData[2],iAbstractLength);
            if(!bTDPosiCalculated) //如果没有计算出上止点，那么退出
            {
                return false;
            }
//            iNormalLength = 1440;      //原来是每度2个数据点
            iNormalLength = 720*iNumPerAngle;        //现在改为每度5个数据点
            if(!AllocateMemory(iNormalLength))
            {
                return false;
            }
        	AbstractNormalP();

            LFHS.fTimeInterval = fTimeInterval;
            LFHS.fAngleStep    = fAngleStep;
            LFHS.siCombustion  = bCombustion;
            LFHS.fEngineSpeed  = fEn;
            LFHS.fOilAngle     = fOilAngle;
            LFHS.fCombustionAngle = fCombustionAngle;
            sprintf(LFHS.strTrainNum,"%04d\0",LFHS.iTrainNum);
            if(bCalculate)  //如果要对提取的数据进行计算
            {
                GetMinMax(fOldP,iNormalLength,fMinOldP,fMaxOldP,fMaxOldPPosi,true);
   //             fMaxOldP -= fMinOldP;
                ModifyPressure(fNewP,iNormalLength);
                GetMinMax(fNewP,iNormalLength,fNormalPMin, fNormalPMax,fNormalPMaxPosi,true);
   //             fNormalPMax -= fNormalMin;
//如果把下一行关闭，则压力升高率是通过插值计算出来的
//        lDPDF(fNewP,farDPDF,fFFFai,iNormalLength);
                GetMinMax(farDPDF,iNormalLength,fDPDFMin, fDPDFMax,    fDPDFMaxPosi,true);
         	    GetMinMax(farV,iNormalLength,   fCVMin,   fCVMax,      ftemp,false);
                GetLogPLogV();
    	        GetMinMax(farLogP,iNormalLength,fLogPMin, fLogPMax,    ftemp,false);
                GetMinMax(farLogV,iNormalLength,fLogVMin, fLogVMax,    ftemp,false);
                fFFFaiMin = fFFFai[0];
                fFFFaiMax = fFFFai[iNormalLength - 1];
                iPLength = iNormalLength;
                CalculateFFTP();     //计算频域数据
                if(bCombustion)
                {
                   // TJHeatRelease();     //计算放热率
                    HeatRelease();
                    CalculateCHRR();     //计算累积放热率
    	            CalculatePower();  //计算循环功
                    GetMinMax(fDHDF,iNormalLength,fHRRMin,fHRRMax,fDHDFMaxFai,true);
                    GetMinMax(fCDHDF,iNormalLength,fCHRRMin,fCHRRMax,fCDHDFMaxFai,true);
                    FormMain->iCCStart = iStartFai;
                    FormMain->iCCEnd   = iEndFai;
                }
            }

// 2005_01_26
        }
        else
        {
            CalibrationData();
        }
        return true;
    }
    return false;
}

void __fastcall lDieselHRBP::GetfST0(int ip)
{
//根据灵敏度系数、增益等对提取的数据进行标定
//    fT[0] = fGuiYiCoef1/(LFHS.fSensitivity[0]*LFHS.siGain[0]);
//    fT[1] = fGuiYiCoef2/(LFHS.fSensitivity[1]*LFHS.siGain[1]);
	float ftemp;
	float ftgain = 1.0;
	int i;
    int igain = 1;

    ftgain = 1.0;
    for(i=0; i< LFHS.siSignalGain[ip]; ++i)
    {
        ftgain *= 2.0;
        igain  *= 2;
    }
    if( LFHS.chVersion == 1)
    {
        switch(igain)
        {
            case 1:   ftgain = 0.987;   break;
            case 2:   ftgain = 1.94;    break;
            case 4:   ftgain = 3.756;   break;
            case 8:   ftgain = 7.068;   break;
            case 16:  ftgain = 12.547;  break;
            case 32:  ftgain = 20.636;  break;
            case 64:  ftgain = 30.547;  break;
        }
    }
    else if(LFHS.chVersion == 2)
    {
        ftgain /= 4.0;
    }
    else
    {
        ftgain = ftgain;
    }

    fEnlarge = ftgain;
  	ftemp = LFHS.fSensitivity[ip];
//    ftemp = 170.6;
//    fST0 = 2000.0*VSCOPE/(ftemp*ftgain);  //转换值乘以这个常数为物理量值
//    ftemp = 161.0;
//    ftemp = 210.0;
    if(LFHS.chVersion == 1)
    {
        fST0 = VCAPCATOR/(ftemp*ftgain);  //转换值乘以这个常数为物理量值
    }
    else
    {
        fST0 = VCAPCATOR*VSCOPE/(ftemp*ftgain);  //转换值乘以这个常数为物理量值
    }
}

void __fastcall lDieselHRBP::lDPDF(int *ip,int *idpdf,int ilen)
{       //计算压力升高率
    int i;
    idpdf[0] = 0;
    idpdf[1] = 0;
    idpdf[ilen-2] = 0;
    idpdf[ilen-1] = 0;
    for(i=2;i<ilen-2;i++)
    {
        idpdf[i] =   ( ip[i-2]
                    - 8*ip[i-1]
                    + 8*ip[i+1]
                    - ip[i+2])/12;
        //(12.0*(fpNormalA[i+1] - fpNormalA[i]));原来是除以这个数
    }
}

void __fastcall lDieselHRBP::lDPDF(float *fp,float*fdpdf,int ilen)
{       //计算压力升高率
    int i;
    fdpdf[0] = 0.0;
    fdpdf[1] = 0.0;
    fdpdf[ilen-2] = 0.0;
    fdpdf[ilen-1] = 0.0;
    for( i = 2 ; i < ilen - 2; i ++)
    {
        fdpdf[i] =   (    fp[i-2]
                    - 8.0*fp[i-1]
                    + 8.0*fp[i+1]
                    - fp[i+2]
                      )/12.0;
        fdpdf[i] /= fAngleStep;
        //(12.0*(fpNormalA[i+1] - fpNormalA[i]));原来是除以这个数
    }

}
void __fastcall lDieselHRBP::lDPDF(float *fp,float *fdpdf,float *fang,int ilen)
{       //计算压力升高率
    int i;
    fdpdf[0] = 0;
    fdpdf[1] = 0;
    fdpdf[ilen-2] = 0;
    fdpdf[ilen-1] = 0;
    for(i=2;i<ilen-2;i++)
    {
        fdpdf[i] =   ( fp[i-2]
                    - 8.0*fp[i-1]
                    + 8.0*fp[i+1]
                    - fp[i+2])/(12.0*(fang[i+1] - fang[i]));
        //(12.0*(fpNormalA[i+1] - fpNormalA[i]));原来是除以这个数
    }
}

void __fastcall lDieselHRBP::AbstractNormalP(void) //从压力数据中提取压力值每隔0.5度，取出一个点
{
    int i,j,k;
    int istart;              //iTDPosi处为0度曲轴转角
    int iend;
    int istPosi,ienPosi;
    float ffNowAngle,ffPreAngle;
    float ftemp;

    float ftempNewP[100];
    float ftempOldP[100];
    float ftempFFFai[100];
    float ftempDPDF[100];
    float ftempV[100];
    float ftempOilP[100];

    istart = (float)iTDPosi*fAngleStep;
    iend   = (float)(iAbstractLength - iTDPosi)*fAngleStep;
    if(istart >= 360)
    {
        istart = 360;
    }
    if(iend >= 360)
    {
        iend   = -360;
    }
    else
    {
        iend = -iend;
    }
/*
    if(iend > 720)
    {
        iend = istart - 720;
    }
    else
    {
        iend = istart - iend;
    }
*/

//
//  int iNumPerAngle = 2;
    for(i = istart; i > iend; --i)
    {
    	for( j = 0; j<iNumPerAngle; ++j)
    	{
    		ffNowAngle = (float)i - (float)j/(float)iNumPerAngle;     //生成0.5度一个间隔
//20040602 (1)
//	        istPosi    = iTDPosi - (int)((ffNowAngle/fAngleStep) + 0.5 );
	        istPosi    = iTDPosi - (int)((ffNowAngle/fAngleStep));
//            istPosi --;
    	    ienPosi    = istPosi + 1;

    	    if(istPosi < 0)
    	    {
    	    	istPosi = 0;
    	    }
    	    else if(istPosi >= iAbstractLength)
    	    {
    	    	istPosi = iAbstractLength - 1;
    	    }
    	    if(ienPosi < 0)
    	    {
    	    	ienPosi = 0;
    	    }
    	    else if(ienPosi >= iAbstractLength)
    	    {
    	    	ienPosi = iAbstractLength - 1;
    	    }
            if(istPosi == ienPosi)
            {
                if(istPosi > 0)
                {
                    istPosi --;
                }
                else
                {
                    istPosi ++;
                }
            }

        	ffPreAngle  = (float)(iTDPosi - istPosi)*fAngleStep;
			ftemp = (fpFData[ienPosi] - fpFData[istPosi])/(float(ienPosi - istPosi)*fAngleStep);
			k = iNumPerAngle*(istart - i)+j;
//20040602 (2)
    	    fNewP[k]      = fpFData[istPosi]  + (ffPreAngle - ffNowAngle)*ftemp;

            fOldP[k]   = fNewP[k];
            siConvertBuffer[0][k] = (short int)(fNewP[k]*32767.0/fST0);
            siConvertBuffer[1][k] = (short int)(ipACData[1][istPosi]);
            fpOilP[k]             = (float)(siConvertBuffer[1][k]);
            siConvertBuffer[2][k] = (short int)(ipACData[2][istPosi]);
            farDPDF[k] = fpSMDPDF[istPosi]
                         + (ffNowAngle - ffPreAngle)
                           *(fpSMDPDF[ienPosi] - fpSMDPDF[istPosi])/fAngleStep;
//            farDPDF[k] /= fAngleStep;
        	fFFFai[k] = - ffNowAngle;
        	farV[k] = GetVolumn(-ffNowAngle,ftemp)*1000.0;  //以升为单位
        }
    }
    farDPDF[0] = 0.0;
    farDPDF[iNormalLength - 2] = 0.0;

//------------------------------------------------------------------
    float ftgain = 1.0;
    float fftemp;
    for(int i = 0; i< LFHS.siSignalGain[1]; ++i)
    {
        ftgain *= 2.0;
    }
    fpOilP[0] = (float)siConvertBuffer[1][0];
    fpOilP[1] = (float)siConvertBuffer[1][1];
    fpOilP[iNormalLength - 1] = (float)siConvertBuffer[1][iNormalLength - 1];
    fpOilP[iNormalLength - 2] = (float)siConvertBuffer[1][iNormalLength - 2];
    for(int j=2; j<iNormalLength - 1; j++)
    {
        fftemp = 0.0;
        for(int m = -1; m < 2; m ++)
        {
            fftemp += (float)siConvertBuffer[1][j + m];
        }
        fpOilP[j] = fftemp/ftgain/5.0;
    }
    GetMinMax(fpOilP,iNormalLength,fOilPMin,fOilPMax,fOilPMaxPosi,true);
    fMaxOldPPosi = iMaxPosi;
//=========================================================================
/*
    FILE* fp;
    fp = fopen("e:\\original.dat","w");
    for(int m = 0; m<iAbstractLength; m++)
    {
        fprintf(fp,"%d %.5f\n",m,fpFData[m]);
    }
    fclose(fp);
*/
    iNormalLength = iNumPerAngle*(istart - iend);
    ffNowAngle    = fFFFai[0];
    istart = (int)((ffNowAngle + 360)*(float)iNumPerAngle);
    if(istart > 0)
    {
        for( int i = iNormalLength - 1; i > istart; i--)
        {
            fNewP[i]  =  fNewP[   i - istart];
            fOldP[i]  =  fOldP[   i - istart];
            fFFFai[i] =  fFFFai[  i - istart];
            farDPDF[i] = farDPDF[ i - istart];
            farV[i]    = farV[    i - istart];
            fpOilP[i]  = fpOilP[  i - istart];
        }
        for( int i = 0; i < iNormalLength; i++)
        {
            fFFFai[i] = (float)i/(float)iNumPerAngle - 360.0;
        }
    }
    else if(istart < 0)
    {
        istart = -istart;
        for( int i = 0; i < iNormalLength - istart; i++)
        {
            fNewP[i]  =  fNewP[   i + istart];
            fOldP[i]  =  fOldP[   i + istart];
            fFFFai[i] =  fFFFai[  i + istart];
            farDPDF[i] = farDPDF[ i + istart];
            farV[i]    = farV[    i + istart];
            fpOilP[i]  = fpOilP[  i + istart];
        }
        for( int i = 0; i < iNormalLength; i++)
        {
            fFFFai[i] = (float)i/(float)iNumPerAngle - 360.0;
        }
    }

}

void  __fastcall lDieselHRBP::GetLogPLogV(void)  //用于获取压力与容积的对数据值
{
	int i;
    float ftemp;
	for( i =0; i<iNormalLength; i++)
	{
		ftemp = fNewP[i];
        if(ftemp < 1.0e-10)
        {
           ftemp = 1.0e-5;
        }
        else if(ftemp > 100.0)
        {
            ftemp = 1.0;
        }
		farLogP[i] = 20.0*log10(ftemp);
		ftemp = farV[i];
        if(ftemp < 1.0e-5)
        {
           ftemp = 1.0e-5;
        }
        else if(ftemp > 100.0)
        {
            ftemp = 1.0;
        }
		farLogV[i] = 20.0*log10(ftemp);
	}
}

int __fastcall lDieselHRBP::DetectPosi(int * ipa, int *ipac)
{
//  通过计算相似性来判断不同样本之间的差异
//  此函数返回相似点距最大值点的偏移量
//  所用的参数
//  fAP0 　被提出来的当前样本数据
//  fOldP　累积的各个样本的总和
//  返回值　： 相似点距最大值点的偏移量
    float fTry[60];
    float ftemp ,fsum;
    int iiiposi;
    int istart,iend;
    int istep;    
    int ICOLENGTH,IHALFWINDOW;  
    int i,j;
    ICOLENGTH = 60;
    IHALFWINDOW = 120;

    for(i=0; i<ICOLENGTH; i++)
    {
        fsum = 0.0;
        for(j=0;j<2*IHALFWINDOW;j++)
        {
            istep = IHALFLENGTH - IHALFWINDOW + j;
            ftemp = (ipa[istep+i-ICOLENGTH/2] - ipac[istep]/(float)iSampleNum);
            fsum += ftemp*ftemp;
        }
        fTry[i] = fsum;
    }
    ftemp = fTry[0];
    iiiposi = 0;
    for(i=1;i<ICOLENGTH;i++)
    {
         if(ftemp > fTry[i])
         {
            ftemp = fTry[i];
            iiiposi = i;
         }
    }
    return iiiposi - ICOLENGTH/2;
}
void __fastcall lDieselHRBP::ModifyPressure(float* fp,int inum) //修正低压部分
{
     int i;
     float fNewPMin,fNewPMax;
     float *fbuffer = NULL;
//   int iwidth = 6;
     GetCPMinMax(fp, inum, fNewPMin, fNewPMax);
//     fNewPMin = GetPressureAngle(fInCloseAngle);
          //在进气压力为170kPa时，局部最大值为0.22左右，ftemp为进气压力修正值
     LFHS.fLocalDPDFMax   = fDPDFLocalMax;      //压力升高率的局部最大值
     fBarP0      = 0.1 + (fDPDFLocalMax - 0.07)/0.15*0.17;
     LFHS.fBarP0 = fBarP0;             //进气压力
     fDeltaP = fBarP0 - fNewPMin;           //假设增压器压力为2.0个大气压
//     fDeltaP = -fMinOldP;
//    float ftemp = 0.0;
     for(i = 0; i< inum; i++)             //fBaseP为增压器压力
     {
         fp[i] += fDeltaP;
//         ftemp += fp[i];
     }
//     LFHS.fAverageP = ftemp/(float)inum;
//-------------------------------------------------------------
// 以下代码用于对通道效应进行修正
/*
     fbuffer = new float[inum];
     if(fbuffer != NULL)
     {
        for( int i = 0 ; i < iwidth; i ++)
        {
            fbuffer[i] = fp[i];
        }
        for( int i = inum - iwidth; i < inum; i ++)
        {
            fbuffer[i] = fp[i];
        }
        for( int i = iwidth; i < inum - iwidth; i ++)
        {
            fbuffer[i] = (fp[i - iwidth] + fp[i + iwidth])/2.0;
        }
        for( int i = 0; i < inum; i ++)
        {
            fp[i] = fbuffer[i];
        }
        delete [] fbuffer;
     }
*/
//====================================================================
}
void __fastcall lDieselHRBP::CalculatePower(void)      //计算此循环的功
{
	int i;                     
	float fDW;
    float fvmin,fvmax;
	fCPower = 0.0;
	for( i = 0; i < iNormalLength - 1; i++)
	{
        fDW = (fNewP[i]+fNewP[i+1])*(farV[i+1] - farV[i])/2.0;
        fCPower += fDW;
        farDW[i] = fDW/(1.0/(float)iNumPerAngle);
        farW[i] = fCPower;  //压力是以MPa为单位，容积是以升为单位, kJ
    }
    fCPower = fCPower;
    farW[iNormalLength - 1] = farW[iNormalLength - 2];
    GetMinMax(farV, iPLength, fvmin, fvmax, fDW, false);
    LFHS.fAverageP = fCPower /(fvmax - fvmin);
    GetMinMax(farW,iPLength,fWMin,fWMax,fDW,false);
    GetMinMax(farDW,iPLength,fDWMin,fDWMax,fWMaxFai,true);
//-----------------------------------------------------------
/*
    FILE* fp;
    fp = fopen("e:\\farW.dat","w");
    for( i = 0; i < iNormalLength; i ++)
    {
        fprintf(fp,"%d %.2f %.5f\n",i,fNewP[i],farW[i]);
    }
    fclose(fp);
*/
//==============================================================
//    fCPower *= 100.0;      //将bar转换为帕斯卡 ,单位为千焦
}

void __fastcall lDieselHRBP::ModifyTDC()
{
    //上止点后的数据调整
    //数据长度为 iNormalLength;
    //压力值需要调整       fpNormalP
    //压力对数值需要调整   fpNormalLogP
    //压力升高率需要调整   fpNormalDPDF
    //iTDCStep为移动步长
    int i;
    int k;
    int in;
    int istep;
    in = abs(iTDCStep);
    float *fbufferoldp;
    float *fbufferp;
    float *fbufferlogp;
    float *fbufferdpdf;
    float ftemp;
    if(in == 0)  //没有对上止点进行有效的调整
    {
        return;
    }
    fbufferoldp = new float[in];
    fbufferp    = new float[in];
    fbufferlogp = new float[in];
    fbufferdpdf = new float[in];
    if(  (fbufferp    == NULL)
       ||(fbufferlogp == NULL)
       ||(fbufferdpdf == NULL)
       ||(fbufferoldp == NULL)
      )
    {
        return;
    }
    if(iTDCStep < 0 )  //向左移动上止点
    {
        k = - iTDCStep;
        in = iNormalLength + iTDCStep;
        for(i = 0; i < k; ++i)
        {
            fbufferoldp[i] = fOldP[i];
            fbufferp[i]    = fNewP[i];
            fbufferlogp[i] = farLogP[i];
            fbufferdpdf[i] = farDPDF[i];
        }
        for(i = 0; i < in; ++i)
        {
            istep      = i + k;
            fOldP[i]   = fOldP[istep];
            fNewP[i]   = fNewP[istep];
            farLogP[i] = farLogP[istep];
            farDPDF[i] = farDPDF[istep];
        }
        for(i = in; i<iNormalLength; i++)
        {
            istep      = i - in;
            fOldP[i]   = fbufferoldp[istep];
            fNewP[i]   = fbufferp[istep];
            farLogP[i] = fbufferlogp[istep];
            farDPDF[i] = fbufferdpdf[istep];
        }
    }
    else               //向右移动上止点
    {
        k = iTDCStep;
        in = iNormalLength + iTDCStep;
        for(i = 0; i < k; ++i)
        {
            istep = iNormalLength - iTDCStep + i;
            fbufferoldp[i] = fOldP[istep];
            fbufferp[i]    = fNewP[istep];
            fbufferlogp[i] = farLogP[istep];
            fbufferdpdf[i] = farDPDF[istep];
        }
        for(i = iNormalLength - 1; i >= k; --i)
        {
            istep      = i - k;
            fOldP[i]   = fOldP[istep];
            fNewP[i]   = fNewP[istep];
            farLogP[i] = farLogP[istep];
            farDPDF[i] = farDPDF[istep];
        }
        for(i = 0; i < k; ++i)
        {
            fOldP[i]   = fbufferoldp[i];
            fNewP[i]   = fbufferp[i];
            farLogP[i] = fbufferlogp[i];
            farDPDF[i] = fbufferdpdf[i];
        }
    }
    if(bCombustion) //如果是燃烧过程,那么对燃烧过程的参数进行修正
    {
        ftemp             = 0.5*(float)iTDCStep;
        fOilAngle        -= ftemp;       /*显示供油提前角*/
        fCombustionAngle -= ftemp;
    }
    delete []fbufferoldp;
    delete []fbufferp;
    delete []fbufferlogp;
    delete []fbufferdpdf;
}

void __fastcall lDieselHRBP::lDirectData(void)
{
    //TODO: Add your source code here
    int id;
    for( id = 0; id < iAbstractLength;  ++ id)
    {
    	 fpFData[id] = ipACData[0][id];
    }
}

void __fastcall lDieselHRBP::lSmoothCurve(float * forig, float * fnew, int ilen)
{
    //TODO: Add your source code here
    //此函数用于计算压力曲线的光顺值  是七点光顺方法
    //输入：
    //        float* forig   需要处理的数据
    //        float* fnew    新生成的数据（已光顺过）
    //        int    ilen    数据长度
    float ftemp;
    fnew[0] = ( 39.0*forig[0] + 8.0*forig[1] - 4.0*forig[2] -   4.0*forig[3]
                   + forig[4] + 4.0*forig[5] - 2.0*forig[6])/42.0;
    fnew[1] = (  8.0*forig[0] + 19.0*forig[1] + 16.0*forig[2]  + 6.0*forig[3]
                +4.0*forig[4]  - 7.0*forig[5] +  4.0*forig[6])/42.0;
    fnew[2] = ( -4.0*forig[0] + 16.0*forig[1] + 19.0*forig[2] + 12.0*forig[3]
                +2.0*forig[4] -  4.0*forig[5] +      forig[6])/42.0;
    fnew[ilen -3 ] = (forig[ilen-7] -4.0*forig[ilen-6] + 2.0*forig[ilen-5]
               +12.0*forig[ilen-4] +19.0*forig[ilen-3] +16.0*forig[ilen-2]
                 -4.0*forig[ilen-1])/42.0;
    fnew[ilen-2] = (4.0*forig[ilen-7] -7.0*forig[ilen-6] -4.0*forig[ilen-5]
                  +6.0*forig[ilen-4] +16.0*forig[ilen-3] +19.0*forig[ilen-2]
                  +8.0*forig[ilen-1])/42.0;
    fnew[ilen-1] = ( -2.0*forig[ilen-7] +4.0*forig[ilen-6] + forig[ilen-5]
                     -4.0*forig[ilen-4] -4.0*forig[ilen-3] +8.0*forig[ilen-2]
                     +39.0*forig[ilen-1])/42.0;
    for(int i = 3; i<ilen - 3; i++)
    {

        ftemp = (-2.0*(forig[i-3] + forig[i+3])+3.0*(forig[i-2]+forig[i+2])
                 +6.0*(forig[i-1] + forig[i+1])+7.0*forig[i])/21.0;
        fnew[i] = ftemp;
    }
}

void __fastcall lDieselHRBP::lFilterData(float* fold, float* fnew, int iLen,int iH)
{
    //TODO: Add your source code here
    //对输入数据fodata进行滤波处理，
    //输入：
    //　ipac 原始数据
    //　fFData 保存滤波后的数据
    //  h      滤波器数据
    //　ilen   原始数据长度
    //  ihlen  滤波器长度
    //输出：
    //　fFData　为滤波处理后的数据
 	int ib,id;
    float fb;
    float ftemp;
    int ilen;
    int ihlen = 55;             //55阶滤波器
    int iCStart;
    int iCEnd;
    float* h;
    if(iH == 0)
    {
        h = hl;
    }
    else
    {
        h = hh;
    }
    ilen = iLen;     //提取出来的数据长度
    iCStart = ihlen/2;
    iCEnd   = ilen - iCStart;
    fnew[0] = (fold[0]+fold[1])/2.0;
    for( id = 1; id < iCStart;  ++id)
    {
    	 ftemp = 0;
    	 for(ib = id - 1; ib <= id +1; ++ ib)
    	 {
    	 	ftemp += fold[ib];
    	 }
    	 fnew[id] = ftemp/3.0;
    }

    for(id = iCStart; id < iCEnd; ++ id)
    {
    	fb = 0.0;
        for(ib=0; ib<ihlen; ++ib)
        {
        	ftemp = fold[id - iCStart + ib];
        	fb += h[ib]*ftemp;
        }

        fnew[id] = fb;
    }                               

    fnew[ilen - 1] = (fold[ilen-2] + fold[ilen -1])/2.0;
    for( id = iCEnd; id < iLen - 1;  ++id)
    {
    	 ftemp = 0;
    	 for(ib = id - 1; ib <= id +1; ++ ib)
    	 {
    	 	ftemp += fold[ib];
    	 }
    	 fnew[id] = (float)ftemp/3.0;
    }

}

bool __fastcall lDieselHRBP::ConverToPCP(AnsiString& strFileName)
{
    //TODO: Add your source code here
    AnsiString strTemp;
    FILE * fp;
    int ilen;
    bool bret = false;
    static int itime = 0;
    strTemp = strFileName.SubString(1,strFileName.Length() - 3);
    strTemp += "PCP";
            itime ++;
            if(itime >= 38)
            {
                itime = itime;
            }
    if(ReadOriginal(strFileName.c_str(),true))
    {
        if((fp = fopen(strTemp.c_str(),"wb")) != NULL)
        {
            LFHS.iNormalLength = iNormalLength;           //备份数据长度
            LFHS.iNumPerAngle  = iNumPerAngle;
            LFHS.fDiameter      = fDiameter;      //1 气缸直径
            LFHS.fStroke        = fStroke;        //2 活塞冲程
            LFHS.fPodLength     = fPodLength;     //3 连杆长度
            LFHS.fCRatio        = fCRatio;        //4 压缩比
            LFHS.fLMDa          = fLMDa;          //5 冲程/连杆之比
            LFHS.fInOpenAngle   = fInOpenAngle;   //6 进气门开启角度
            LFHS.fInCloseAngle  = fInCloseAngle;  //7　进气门关闭角度
            LFHS.fOutOpenAngle  = fOutOpenAngle;  //8　排气门开启角度
            LFHS.fOutCloseAngle = fOutCloseAngle; //9　排气门关闭角度
            LFHS.siInfoValid    = 1;              //表示数据有效

            LFHS.fMinOldP       = fMinOldP;
            LFHS.fMaxOldP       = fMaxOldP;  //原始数据的最大值和最小值
            LFHS.fOilPMin       = fOilPMin;
            LFHS.fOilPMax       = fOilPMax;  //油管压力波形的最大值和最小值
//            LFHS.fCPMax         = fCPMax;    //不更新气缸压力最大值，以免产生较大的误差
//            LFHS.fCPMin         = fCPMin;
            LFHS.fNormalPMin    = fNormalPMin;
            LFHS.fNormalPMax    = fNormalPMax;   //修正后的气缸压力最大值和最小值
            LFHS.fDPDFMax       = fDPDFMax;
            LFHS.fDPDFMin       = fDPDFMin;       //压力升高率的最大值和最小值
            LFHS.fHRRMin        = fHRRMin;
            LFHS.fHRRMax        = fHRRMax;        //放热率最大值和最小值
            LFHS.fCHRRMax       = fCHRRMax;
            LFHS.fCHRRMin       = fCHRRMin;       //累积放热率最大值和最小值
            LFHS.fMaxFFTP       = fMaxFFTP;
            LFHS.fMinFFTP       = fMinFFTP;       //频谱的最大值和最小值
            LFHS.fTMax          = fTMax;
            LFHS.fTMin          = fTMin;          //气缸温度的最大值和最小值
            LFHS.fDWMax         = fDWMax;
            LFHS.fDWMin         = fDWMin;         //瞬时功的最大值和最小值
            LFHS.fWMax          = fWMax;          //瞬时功的最大值和最小值
            LFHS.fWMin          = fWMin;
            LFHS.iStartFai      = iStartFai;
            LFHS.iEndFai        = iEndFai;
            LFHS.fFFFaiMin      = fFFFaiMin;
            LFHS.fFFFaiMax      = fFFFaiMax;
            LFHS.fCPower        = fCPower;
            LFHS.iFFTLength     = iFFTLength;
            LFHS.fLogPMin       = fLogPMin;
            LFHS.fLogPMax       = fLogPMax;
            LFHS.fLogVMin       = fLogVMin;
            LFHS.fLogVMax       = fLogVMax;

            LFHS.fFirstDHDFMax      = fFirstDHDFMax;   //放热率第一峰值
            LFHS.fFaiFirstDHDFMax   = fFaiFirstDHDFMax;   //放热率第一峰值对应的曲轴转角
            
            LFHS.fFaiPMax       = fPMaxFai;   //最大气缸压力所对应的曲轴转角
            LFHS.fFaiDPDFMax    = fDPDFMaxFai;   //最大压力升高率对应的曲轴转角
            LFHS.fFaiDHDFMax    = fDHDFMaxFai;   //最大放热率对应的曲轴转角
            LFHS.fFaiTMax       = fTMaxFai;   //最高温度对应的曲轴转角

            LFHS.fCombustionAngle = (float)(iCombustionPosi - iTDPosi)*fAngleStep;   // ConvertToIEEE(myOwn);         //第一通道的均方根值
            LFHS.fOilAngle        = (float)(iOilPosi        - iTDPosi)*fAngleStep;   // ConvertToIEEE(myOwn);         //第一通道的压力最大值

//----------------------------------------------------
// 由于进行了压缩处理，处理后要将修改的数据重新恢复
            int iOldNL;
            iOldNL = iNormalLength;
//            CompressData();

            LFHS.iNormalLength    = iNormalLength;
            LFHS.iCombustionPosi = iCombustionPosi;     //(10)                         4
            LFHS.iOilPosi        = iOilPosi;            //(11)                         4
            LFHS.iTDPosi         = iTDPosi;              //(12)                        4
            LFHS.iStartFai        = iStartFai;
            while( fFFFai[iEndFai] > 150.0)     //放热率不能持续到上止点后　150度
            {
                iEndFai --;
                if(iEndFai <= 0)
                {
                    break;
                }
            }
            LFHS.iEndFai          = iEndFai;
//===================================================================

            fwrite((void*)(&LFHS),sizeof(lFileHeadStruct),1,fp);    //写入文件头

            ilen = sizeof(float);

            fwrite((void*)(fFFFai), ilen*iNormalLength,1,fp);       //写入曲轴转角
            fwrite((void*)(farDPDF),ilen*iNormalLength,1,fp);       //写入压力升高率
            fwrite((void*)(farV),   ilen*iNormalLength,1,fp);       //写入气缸容积

            ilen = sizeof(short int);
            for(int i = 0; i < PASSAGENUM; i++)
            {
                if(LFHS.siPassageStatus[i] == 1)  //如果该通道打开，仍然保持原来的数据长度
                {
                    fwrite((void*)(siConvertBuffer[i]),3600*ilen,1,fp);
                }
            }

            ilen = sizeof(float);
//1
            fwrite((void*)(fOldP),iNormalLength*ilen,1,fp);         //写入原始数据
//2
            fwrite((void*)(fNewP),iNormalLength*ilen,1,fp);         //写入修正数据
//3
            fwrite((void*)(fDHDF),iNormalLength*ilen,1,fp);         //写入放热率数据
//4
            fwrite((void*)(fCDHDF),iNormalLength*ilen,1,fp);        //写入累积放热率数据
//5
            fwrite((void*)(fTT),iNormalLength*ilen,1,fp);           //写入气缸温度数据
//6
            fwrite((void*)(farDW),iNormalLength*ilen,1,fp);         //写入瞬时功数据
//7
            fwrite((void*)(farW),iNormalLength*ilen,1,fp);          //写入累积功数据
//8
            fwrite((void*)(farFFTPr),iFFTLength*ilen,1,fp);         //写入频谱
//9
            fwrite((void*)(farFFTPi),iFFTLength*ilen,1,fp);         //写入频谱
//10
            fwrite((void*)(farLogP), iNormalLength*ilen,1,fp);
//11
            fwrite((void*)(farLogV), iNormalLength*ilen,1,fp);
//12
            fwrite((void*)(fpOilP),  iNormalLength*ilen,1,fp);
            fclose(fp);
            bret = true;
        }
//---------------------------------------------------------------------
/*
    #ifdef SELF_DEBUG
        FILE* fp;
        fp = fopen("e:\\farW.dat","w");
        for( int i = 0; i < iNormalLength; i ++)
        {
            fprintf(fp,"%d %.2f %d\n",i,fNewP[i],siConvertBuffer[1][i]);
        }
        fclose(fp);
    #endif
//=====================================================================
*/
    }

    return bret;
}

void __fastcall lDieselHRBP::CompressData(void)
{
//TODO: Add your source code here
// 对数据进行压缩处理，
// 具体方法是：上止点前-360CA ~ 50CA压缩为1度一个点,
//          -50 ~ 150 CA 之间的数据保持原状
// 　　　　　　上止点后 150CA ~ 360CA压缩为1度一个点
    int iNum = 0;  //用于指向当前的点
    int iNLength;
    int iAngle;
    int iDeleteNum = 0;
    int i = 0;
    iNLength = iNormalLength;
    while( ((fFFFai[i] - 359.8) < 0.01)&& (i < iNormalLength))   //如果曲轴转角小于上止点前50度
    {
        iAngle = fFFFai[i];
        if( fabs(fFFFai[i] - iAngle) < 0.01) //说明这是一个整数曲轴转角
        {
            fFFFai[iNum]  = fFFFai[i];
            farDPDF[iNum] = farDPDF[i];
            farV[iNum]    = farV[i];
// 为了保证压力波的数据，不对原始数据进行压缩处理
/*
            for(int j = 0; j < PASSAGENUM; j++)
            {
                if(LFHS.siPassageStatus[j] == 1)  //如果该通道打开，
                {
                    siConvertBuffer[j][iNum] = siConvertBuffer[j][i];
                }
            }
*/
            fOldP[iNum]   = fOldP[i];         //写入原始数据
//2
            fNewP[iNum]   = fNewP[i];         //写入修正数据
//3
            fDHDF[iNum]   = fDHDF[i];         //写入放热率数据
//4
            fCDHDF[iNum]  = fCDHDF[i];        //写入累积放热率数据
//5
            fTT[iNum]     = fTT[i];           //写入气缸温度数据
//6
            farDW[iNum]   = farDW[i];         //写入瞬时功数据
//7
            farW[iNum]    =  farW[i];          //写入累积功数据
//10
            farLogP[iNum] = farLogP[i];
//11
            farLogV[iNum] = farLogV[i];
//12
            fpOilP[iNum]  = fpOilP[i];
            iNum ++;
        }
        else
        {
            iDeleteNum ++;
        }
        i++;
        if( i == iStartFai )
        {
            iStartFai -= iDeleteNum;
        }
        if(i == iEndFai )
        {
            iEndFai -= iDeleteNum;
        }
    }
    iNormalLength = iNum;
/*
    while( (fFFFai[i] + 0.2) < 0.01) //50.2) < 0.01)   //如果曲轴转角小于上止点前50度
    {
        iAngle = fFFFai[i];
        if( fabs(fFFFai[i] - iAngle) < 0.01) //说明这是一个整数曲轴转角
        {
            fFFFai[iNum]  = fFFFai[i];
            farDPDF[iNum] = farDPDF[i];
            farV[iNum]    = farV[i];
            for(int j = 0; j < PASSAGENUM; j++)
            {
                if(LFHS.siPassageStatus[j] == 1)  //如果该通道打开，
                {
                    siConvertBuffer[j][iNum] = siConvertBuffer[j][i];
                }
            }

            fOldP[iNum]  = fOldP[i];         //写入原始数据
//2
            fNewP[iNum]  = fNewP[i];         //写入修正数据
//3
            fDHDF[iNum]  = fDHDF[i];         //写入放热率数据
//4
            fCDHDF[iNum] = fCDHDF[i];        //写入累积放热率数据
//5
            fTT[iNum]    = fTT[i];           //写入气缸温度数据
//6
            farDW[iNum]  = farDW[i];         //写入瞬时功数据
//7
            farW[iNum]   = farW[i];          //写入累积功数据
//10
            farLogP[iNum] = farLogP[i];
//11
            farLogV[iNum] = farLogV[i];
//12
            fpOilP[iNum]  = fpOilP[i];
            iNum ++;
        }
        else
        {
            if( i < iStartFai)
            {
                iDeleteNum ++;
            }
        }
        i++;
        if( i == iStartFai )
        {
            iStartFai -= iDeleteNum;
        }
    }

    iStartFai       -= iDeleteNum;
    iCombustionPosi -= iDeleteNum;     //(10)                         4
    iOilPosi        -= iDeleteNum;            //(11)                         4
    iTDPosi         -= iDeleteNum;              //(12)                        4


    while( (fFFFai[i] - 5.0) < 0.0) //149.9) < 0.0)
    {
            fFFFai[iNum]  = fFFFai[i];
            farDPDF[iNum] = farDPDF[i];
            farV[iNum]    = farV[i];
            for(int j = 0; j < PASSAGENUM; j++)
           {
                if(LFHS.siPassageStatus[j] == 1)  //如果该通道打开，
                {
                    siConvertBuffer[j][iNum] = siConvertBuffer[j][i];
                }
            }
            fOldP[iNum]  = fOldP[i];         //写入原始数据
            fNewP[iNum]  = fNewP[i];         //写入修正数据
            fDHDF[iNum]  = fDHDF[i];         //写入放热率数据
            fCDHDF[iNum] = fCDHDF[i];        //写入累积放热率数据
            fTT[iNum]    = fTT[i];           //写入气缸温度数据
            farDW[iNum]  = farDW[i];         //写入瞬时功数据
            farW[iNum]   = farW[i];          //写入累积功数据
            farLogP[iNum] = farLogP[i];
            farLogV[iNum] = farLogV[i];
            fpOilP[iNum]  = fpOilP[i];
            iNum ++;
            i ++;
    }

    while( ((fFFFai[i] - 359.8) < 0.01)&& (i < iNormalLength))   //如果曲轴转角小于上止点前50度
    {
        iAngle = fFFFai[i];
        if( fabs(fFFFai[i] - iAngle) < 0.01) //说明这是一个整数曲轴转角
        {
            fFFFai[iNum]  = fFFFai[i];
            farDPDF[iNum] = farDPDF[i];
            farV[iNum]    = farV[i];
            for(int j = 0; j < PASSAGENUM; j++)
            {
                if(LFHS.siPassageStatus[j] == 1)  //如果该通道打开，
                {
                    siConvertBuffer[j][iNum] = siConvertBuffer[j][i];
                }
            }

            fOldP[iNum]  = fOldP[i];         //写入原始数据
//2
            fNewP[iNum]  = fNewP[i];         //写入修正数据
//3
            fDHDF[iNum]  = fDHDF[i];         //写入放热率数据
//4
            fCDHDF[iNum] = fCDHDF[i];        //写入累积放热率数据
//5
            fTT[iNum]    = fTT[i];           //写入气缸温度数据
//6
            farDW[iNum]  = farDW[i];         //写入瞬时功数据
//7
            farW[iNum]   = farW[i];          //写入累积功数据
//10
            farLogP[iNum] = farLogP[i];
//11
            farLogV[iNum] = farLogV[i];
//12
            fpOilP[iNum]  = fpOilP[i];
            iNum ++;
        }
        else
        {
            if( i < iEndFai )
            {
                iDeleteNum ++;
            }
        }
        i++;

        if( i == iStartFai )
        {
            iStartFai -= iDeleteNum;
        }

    }
    iEndFai -= iDeleteNum;
    iNormalLength = iNum;
*/
}

bool __fastcall lDieselHRBP::LoadPCPFile(char * strfilename)
{
    //TODO: Add your source code here
    float ftemp1,ftemp2,ftemp;
    int   inum      = 0;
    int   ilen;
//    int   ippnum    = 0;
    FILE * fp;
    void * ptLFHS;
    AnsiString strNN;
    lShort    ls;
    ptLFHS = (void*)&LFHS;
    bOrgFileOpened = false;
    iDeleteNum = 0;      //初始化剔除的数据样本个数
    iSampleNum = 0;      //初始化提取出来的数据样本个数
    strNN = AnsiString( strfilename);
    strNN = ::ExtractFileExt(strNN);
    strNN = strNN.UpperCase();
    if(strNN == ".PCP")
    {
        if((fp = fopen(strfilename,"rb")) != NULL)
        {
            fread(ptLFHS,sizeof(lFileHeadStruct),1,fp);
            fTimeInterval    = LFHS.fTimeInterval;
            fAngleStep       = LFHS.fAngleStep;
            bCombustion      = (bool)LFHS.siCombustion;
            fEn              = LFHS.fEngineSpeed;
            fEngineSpeed     = LFHS.fEngineSpeed;
            strNN            = LFHS.str902Mark;
            fOilAngle        = LFHS.fOilAngle;
            fCombustionAngle = LFHS.fCombustionAngle;
            iDieselNum       = LFHS.siDieselNum;
//----------------------------------------------------------
            SetTrainInfo();
//-----------------------------------------------------------------------
            fMinOldP       = LFHS.fMinOldP;
            fMaxOldP       = LFHS.fMaxOldP;  //原始数据的最大值和最小值
            fOilGain       = 1.0;
            for( int i = 0; i < LFHS.siSignalGain[1]; i++)
            {
                fOilGain *= 2.0;
            }
            fOilPMin       = LFHS.fOilPMin;
            fOilPMax       = LFHS.fOilPMax;  //油管压力波形的最大值和最小值
//            bOilSupply     = (bool)LFHS.chCombustion;
            bOilSupply     = (bool)LFHS.chOil;
            fCPMax         = LFHS.fCPMax;
//            fCPMin         = LFHS.fCPMin;
            fNormalPMin    = LFHS.fNormalPMin;
            fNormalPMax    = LFHS.fNormalPMax;   //修正后的气缸压力最大值和最小值
            fDPDFMax       = LFHS.fDPDFMax;
            fDPDFMin       = LFHS.fDPDFMin;       //压力升高率的最大值和最小值
            fHRRMin        = LFHS.fHRRMin;
            fHRRMax        = LFHS.fHRRMax;        //放热率最大值和最小值
            fCHRRMax       = LFHS.fCHRRMax;
            fCHRRMin       = LFHS.fCHRRMin;       //累积放热率最大值和最小值
            fMaxFFTP       = LFHS.fMaxFFTP;
            fMinFFTP       = LFHS.fMinFFTP;       //频谱的最大值和最小值
            fTMax          = LFHS.fTMax;
            fTMin          = LFHS.fTMin;          //气缸温度的最大值和最小值
            fDWMax         = LFHS.fDWMax;
            fDWMin         = LFHS.fDWMin;         //瞬时功的最大值和最小值
            fWMax          = LFHS.fWMax;          //瞬时功的最大值和最小值
            fWMin          = LFHS.fWMin;
            fFFFaiMin      = LFHS.fFFFaiMin;
            fFFFaiMax      = LFHS.fFFFaiMax;
            fCPower        = LFHS.fCPower;

            iStartFai      = LFHS.iStartFai;
            iEndFai        = LFHS.iEndFai;

            iFFTLength     = LFHS.iFFTLength;
            fLogPMin       = LFHS.fLogPMin;
            fLogPMax       = LFHS.fLogPMax;
            fLogVMin       = LFHS.fLogVMin;
            fLogVMax       = LFHS.fLogVMax;
            fFirstDHDFMax  = LFHS.fFirstDHDFMax;
            fDHDFMax       = LFHS.fDHDFMax;   //放热率第一峰值
            fPMaxFai       = LFHS.fFaiPMax;   //最大气缸压力所对应的曲轴转角
            fDPDFMaxFai    = LFHS.fFaiDPDFMax;   //最大压力升高率对应的曲轴转角
            fDHDFMaxFai    = LFHS.fFaiDHDFMax;   //最大放热率对应的曲轴转角
            fTMaxFai       = LFHS.fFaiTMax;   //最高温度对应的曲轴转角
            fFaiDHDFMax    = LFHS.fFaiDHDFMax;   //放热率第一峰值对应的曲轴转角
//===========================================================================

            if(LFHS.siInfoValid == 1)
            {
                iNormalLength = LFHS.iNormalLength;           //备份数据长度
                iNumPerAngle  = LFHS.iNumPerAngle;
                fDiameter      = LFHS.fDiameter;      //1 气缸直径
                fStroke        = LFHS.fStroke;        //2 活塞冲程
                fPodLength     = LFHS.fPodLength;     //3 连杆长度
                fCRatio        = LFHS.fCRatio;        //4 压缩比
                fLMDa          = LFHS.fLMDa;          //5 冲程/连杆之比
                fInOpenAngle   = LFHS.fInOpenAngle;   //6 进气门开启角度
                fInCloseAngle  = LFHS.fInCloseAngle;  //7　进气门关闭角度
                fOutOpenAngle  = LFHS.fOutOpenAngle;  //8　排气门开启角度
                fOutCloseAngle = LFHS.fOutCloseAngle; //9　排气门关闭角度
                fDPDFLocalMax  = LFHS.fLocalDPDFMax;      //压力升高率的局部最大值

            }

            sprintf(LFHS.strTrainNum,"%04d\0",LFHS.iTrainNum);
            if(strNN != "902" )
            {
                Application->MessageBox("文件格式不对!","提示",MB_OK|MB_ICONINFORMATION);
                fclose(fp);
                return false;
            }
            iNormalLength = LFHS.iNormalLength;
            inum          = iNormalLength;
            iPLength      = iNormalLength;
            if(!AllocateMemory(3600)) //iNormalLength))    //iNormalLength = 720
            {
                return false;
            }
            ilen = sizeof(float);
            fread((void*)(fFFFai), ilen*iNormalLength,1,fp); //读入角度
            fread((void*)(farDPDF),ilen*iNormalLength,1,fp);
            fread((void*)(farV),   ilen*iNormalLength,1,fp);
// 读入第一通道的数据
//------------------------------------------------------
            if(LFHS.siPassageStatus[0] == 1)  //如果该通道打开，
            {
                ilen = sizeof(short int);
                fread((void*)(siConvertBuffer[0]),ilen*3600,1,fp);
//                ippnum++;
            }
            else                          //如果没有打开就置为零
            {
                for(int j=0;j<inum;j++)
                {
                    siConvertBuffer[0][j] = 0;
                }
            }
//=======================================================

// 读入第二通道的数据
            if(LFHS.siPassageStatus[1] == 1)
            {
                ilen = sizeof(short int);
                fread((void*)(siConvertBuffer[1]),ilen*3600,1,fp);
//                ippnum++;
        //        fOilPMax *= 2.0;
            }
            else
            {
                for(int j=0; j<inum; j++)
                {
                    siConvertBuffer[1][j] = 0;
                    fpOilP[j] = 0.0;
                }
            }
//============================================================

// 读入第三通道的数据
//------------------------------------------------------------
            if(LFHS.siPassageStatus[2] == 1)
            {
                ilen = sizeof(short int);
                fread((void*)(siConvertBuffer[2]),ilen*3600,1,fp);
//                ippnum++;
            }
            else
            {
                for(int j=0; j<inum; j++)
                {
                    siConvertBuffer[2][j] = 0;
                }
            }

            ilen = sizeof(float);
//1
            fread((void*)(fOldP),iNormalLength*ilen,1,fp);         //读入原始数据
//2
            fread((void*)(fNewP),iNormalLength*ilen,1,fp);         //读入修正数据
//3
            fread((void*)(fDHDF),iNormalLength*ilen,1,fp);         //读入放热率数据
//4
            fread((void*)(fCDHDF),iNormalLength*ilen,1,fp);        //读入累积放热率数据
//5
            fread((void*)(fTT),iNormalLength*ilen,1,fp);           //读入气缸温度数据
//6
            fread((void*)(farDW),iNormalLength*ilen,1,fp);         //读入瞬时功数据
//7
            fread((void*)(farW), iNormalLength*ilen,1,fp);          //读入累积功数据
//8
            fread((void*)(farFFTPr),iFFTLength*ilen,1,fp);         //读入频谱
//9
            fread((void*)(farFFTPi),iFFTLength*ilen,1,fp);         //读入频谱
//10
            fread((void*)(farLogP), iNormalLength*ilen, 1, fp);
//11
            fread((void*)(farLogV), iNormalLength*ilen, 1, fp);
//12
            fread((void*)(fpOilP),  iNormalLength*ilen, 1, fp);
            fclose(fp);
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
/*
    for(int i = 0; i<iNormalLength; ++i)
    {
        fOldP[i] = siConvertBuffer[0][i];
    }

    CalibrateData(fOldP,fOldP,iNormalLength);       //对提取出来的数据进行标定
    for(int i = 0; i<iNormalLength; i++)
    {
        fNewP[i] = fOldP[i];
    }

    GetMinMax(fOldP,iNormalLength,fMinOldP,fMaxOldP,fMaxOldPPosi,true);
    ModifyPressure(fNewP,iNormalLength);
    GetMinMax(fNewP,iNormalLength,fNormalPMin, fNormalPMax, fNormalPMaxPosi,true);

//如果把下一行关闭，则压力升高率是通过插值计算出来的
//        lDPDF(fNewP,farDPDF,fFFFai,iNormalLength);
    GetMinMax(farDPDF,iNormalLength,fDPDFMin, fDPDFMax,    fDPDFMaxPosi,true);
    GetMinMax(farV,iNormalLength,   fCVMin,   fCVMax,      ftemp,       false);
    GetLogPLogV();
    GetMinMax(farLogP,iNormalLength,fLogPMin, fLogPMax,    ftemp,       false);
   	GetMinMax(farLogV,iNormalLength,fLogVMin, fLogVMax,    ftemp,       false);
    fFFFaiMin = fFFFai[0];
    fFFFaiMax = fFFFai[iNormalLength - 1];
    iPLength  = iNormalLength;
    CalculateFFTP();     //计算频域数据
    if(LFHS.chCombustion)
    {
    //    TJHeatRelease();     //计算放热率
        HeatRelease();
        CalculateCHRR();     //计算累积放热率
        CalculatePower();  //计算循环功
        GetMinMax(fDHDF,iNormalLength,fHRRMin,fHRRMax,fDHDFMaxFai,true);
        GetMinMax(fCDHDF,iNormalLength,fCHRRMin,fCHRRMax,ftemp,false);
        GetMinMax(fNewP,iNormalLength,fNormalPMin, fNormalPMax, fNormalPMaxPosi,true);
        fNormalPMax -= fNormalPMin;
        LFHS.fHeatAll      = fCHRRMax;       //总放热量
        LFHS.fCPower       = fCPower;        // 循环功
    }
    if(LFHS.siPassageStatus[1] == 1)
    {
        GetMinMax(fpOilP,iNormalLength,fOilPMin,fOilPMax,fOilPMaxPosi,true);
        fMaxOldPPosi = iMaxPosi;
    }
*/
    FormMain->iCCStart = iStartFai;
    FormMain->iCCEnd   = iEndFai;
    fStartAngle        = fFFFaiMin;

    return true;
}

int __fastcall lDieselHRBP::GetTopDead(void)
{
    //TODO: Add your source code here
    int iposi;
    iposi = 0;
    for(int i = 600; i < 800; i ++)
    {
        if(  (fFFFai[i-1] < 0.0)
           &&(fFFFai[i+1] > 0.0)
           )
        {
            iposi = i;
            break;
        }
    }
    return iposi;
}

void __fastcall lDieselHRBP::Set3DData(int ipart,int idrawkind)
{
    //TODO: Add your source code here
    if(lsAllDrawKind == drawOriginal)                 //没有修正过的原始数据
    {
        for(int i = 0; i < iPLength; i ++)
        {
            f3DData[ipart][i] = fOldP[i];
        }
        my3DInfo[ipart].fMaxValue    = fMaxOldP;
        my3DInfo[ipart].fMaxAngle    = fMaxOldPPosi;
        my3DInfo[ipart].iDieselNum   = LFHS.siDieselNum;
        my3DInfo[ipart].iTopDeadPosi = GetTopDead();
    }
    else if((lsAllDrawKind == drawPT)||(lsAllDrawKind == drawPPWave))
    {
        for(int i = 0; i < iPLength; i ++)
        {
            f3DData[ipart][i] = fNewP[i];
        }
        my3DInfo[ipart].fMaxValue   = fNormalPMax;
        my3DInfo[ipart].fMaxAngle   = fNormalPMaxPosi;
        my3DInfo[ipart].iDieselNum  = LFHS.siDieselNum;
        my3DInfo[ipart].iTopDeadPosi = GetTopDead();
    }
    else if(lsAllDrawKind == drawDPDF)
    {
        for(int i = 0; i < iPLength; i ++)
        {
            f3DData[ipart][i] = farDPDF[i];
        }
        my3DInfo[ipart].fMaxValue   = fDPDFMax;
        my3DInfo[ipart].fMaxAngle   = fDPDFMaxPosi;
        my3DInfo[ipart].iDieselNum  = LFHS.siDieselNum;
        my3DInfo[ipart].iTopDeadPosi = GetTopDead();
    }
    else if(lsAllDrawKind == drawPWave)  //绘制油管压力图形
    {
        for(int i = 0; i < iPLength; i ++)
        {
            f3DData[ipart][i] = fpOilP[i]*4.0/32768.0;
        }
        my3DInfo[ipart].fMaxValue   = fOilPMax*4.0/32768.0;
        my3DInfo[ipart].fMaxAngle   = fOilPMaxPosi;
        my3DInfo[ipart].iDieselNum  = LFHS.siDieselNum;
        my3DInfo[ipart].iTopDeadPosi = GetTopDead();
    }
    else if(lsAllDrawKind == drawHRR)
    {
        for(int i = 0; i < iPLength; i ++)
        {
            f3DData[ipart][i] = fDHDF[i];
        }
        my3DInfo[ipart].fMaxValue    = fHRRMax;
        my3DInfo[ipart].fMaxAngle    = fDHDFMaxFai;
        my3DInfo[ipart].iDieselNum   = LFHS.siDieselNum;
        my3DInfo[ipart].iTopDeadPosi = GetTopDead();
    }
    else if(lsAllDrawKind == drawCHRR)
    {
        for(int i = 0; i < iPLength; i ++)
        {
            f3DData[ipart][i] = fCDHDF[i];
        }
        my3DInfo[ipart].fMaxValue    = fCHRRMax;
        my3DInfo[ipart].fMaxAngle    = fCDHDFMaxFai;
        my3DInfo[ipart].iDieselNum   = LFHS.siDieselNum;
        my3DInfo[ipart].iTopDeadPosi = GetTopDead();
    }
    else if(lsAllDrawKind == drawTT)
    {
        for(int i = 0; i < iPLength; i ++)
        {
            f3DData[ipart][i] = fTT[i];
        }
        my3DInfo[ipart].fMaxValue    = fTMax;
        my3DInfo[ipart].fMaxAngle    = fTMaxFai;
        my3DInfo[ipart].iDieselNum   = LFHS.siDieselNum;
        my3DInfo[ipart].iTopDeadPosi = GetTopDead();
    }
    else if(lsAllDrawKind == drawDW)
    {
        for(int i = 0; i < iPLength; i ++)
        {
            f3DData[ipart][i] = farDW[i];
        }
        my3DInfo[ipart].fMaxValue    = fDWMax;
        my3DInfo[ipart].fMaxAngle    = fWMaxFai;
        my3DInfo[ipart].iDieselNum   = LFHS.siDieselNum;
        my3DInfo[ipart].iTopDeadPosi = GetTopDead();
    }
    else if(lsAllDrawKind == drawW)
    {
        for(int i = 0; i < iPLength; i ++)
        {
            f3DData[ipart][i] = farW[i];
        }
        my3DInfo[ipart].fMaxValue    = fWMax;
        my3DInfo[ipart].fMaxAngle    = fWMaxFai;
        my3DInfo[ipart].iDieselNum   = LFHS.siDieselNum;
        my3DInfo[ipart].iTopDeadPosi = GetTopDead();
    }
    for(int i = iPLength; i < 3600; i++)
    {
        f3DData[ipart][i] = 0.0;
    }
    iCylinderNum = ipart + 1;
}

void __fastcall lDieselHRBP::NormalData(void)
{
    //TODO: Add your source code here
    int istep;
    float ftemp[100];
    if(iCylinderNum > 1)
    {
        for( int i = iCylinderNum - 2; i >= 0  ; i --)
        {
            istep = my3DInfo[i].iTopDeadPosi - my3DInfo[iCylinderNum - 1].iTopDeadPosi;
            if( istep == 0)
            {
                continue;
            }
            else
            {
                if(istep > 0)
                {
                    for(int j = 0; j < istep; j++)
                    {
                        ftemp[j] = f3DData[i][j];
                    }
                    for(int j = 0; j < 1440 - istep; j++)
                    {
                        f3DData[i][j] = f3DData[i][j+istep];
                    }
                    for(int j = 1440 - istep; j < 1440; j ++)
                    {
                        f3DData[i][j] = ftemp[j + istep - 1440];
                    }
                }
                else
                {
                    istep *= -1;
                    for(int j = 1440 - istep; j < 1440; j++)
                    {
                        ftemp[j + istep - 1440] = f3DData[i][j];
                    }
                    for(int j = 1439; j > 1440 - istep; j--)
                    {
                        f3DData[i][j] = f3DData[i][j-istep];
                    }
                    for(int j = 0; j < istep; j ++)
                    {
                        f3DData[i][j] = ftemp[j];
                    }
                }
            }
        }
    }
}

void __fastcall lDieselHRBP::iGetMinMax(int* idata, int ilen, int& imin, int& imax, int& imaxposi)
{
    //TODO: Add your source code here
    //用于在给定长度的数据中找到最大值及最小值　
    int iHLen = 55;
    imin      = idata[iHLen];
    imax      = idata[iHLen];
    imaxposi  = iHLen;
    for(int i = iHLen; i<ilen - iHLen; i++)
    {
        if(idata[i]<imin)
        {
            imin = idata[i];
        }
        else if(idata[i]>imax)
        {
            imax = idata[i];
            imaxposi = i;
        }
    }
}

void __fastcall lDieselHRBP::SetArrayZero(float* fdata, int idatalen, int izlen)
{
    //TODO: Add your source code here
    for(int i = 0; i< izlen; i++)
    {
        fdata[i] = 0.0;
    }
    for(int i = idatalen - izlen; i < idatalen; i++)
    {
        fdata[i] = 0.0;
    }
}

bool __fastcall lDieselHRBP::ChangeSensitivity(char * strfilename)
{
    //TODO: Add your source code here
    float ftemp1,ftemp2,ftemp;
    int   inum ;
    char  chBuffer[512];
    FILE * fp, *fpWrite;
    void * ptLFHS,*ptVoid;
    AnsiString strNN,strWriteFile;
    lShort    ls;
    ptLFHS = (void*)(&LFHS);
    ptVoid = (void*)(&chBuffer[0]);
    bOrgFileOpened = false;

    strNN          = AnsiString( strfilename);
    strWriteFile   = strNN;
    strNN          = ::ExtractFileExt(strNN);
    strNN          = strNN.UpperCase();
    inum           = strWriteFile.Length();
    strWriteFile.c_str()[inum - 1] = 'm';

    if((strNN == ".ORG")||(strNN == ".PCP"))
    {
        if((fpWrite = fopen(strWriteFile.c_str(),"wb")) == NULL)
        {
            return false;
        }
        if((fp = fopen(strfilename,"rb")) != NULL)
        {
            fread(ptLFHS,sizeof(lFileHeadStruct),1,fp);
            strNN = LFHS.str902Mark;
            if(strNN != "902" )
            {
                Application->MessageBox("文件格式不对!","提示",MB_OK|MB_ICONINFORMATION);
                fclose(fp);
                fclose(fpWrite);
                return false;
            }                            
//            LFHS.fSensitivity[0] = 225.0;
            LFHS.chVersion  = 2;
            fwrite(ptLFHS,sizeof(lFileHeadStruct),1,fpWrite);

            while(true)
            {
                inum = fread(ptVoid,512,1,fp);
                if(inum > 0)
                {
                    fwrite(ptVoid,512,1,fpWrite);
                }
                else
                {
                    break;
                }
            };
            fclose(fp);
            fclose(fpWrite);
            DeleteFile(AnsiString(strfilename));
            RenameFile(strWriteFile, AnsiString(strfilename));
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
    return true;
}



void __fastcall lDieselHRBP::CalibrationData(void)
{
    //TODO: Add your source code here
    int itemp = 0;
    int ii2;
    float fsum;
    float fvalue;
//计算平均值
    for( int i = 1; i < iOriginalLength;  i++)
    {
    	 itemp += ipOData[0][i];
    }
//
    itemp /= iOriginalLength;
    fsum = 0.0;
    for( int i = 0; i < iOriginalLength; i++)
    {
        ii2 = ipOData[0][i] - itemp;
        fsum += (float)(ii2*ii2);
    }
    fsum = sqrt(fsum/(float)iOriginalLength);
    float fCalCap,fCalVol,fCalReal;
    fCalCap = StrToFloat(FormMain->EditCapicator->Text);
    fCalVol = StrToFloat(FormMain->EditVoltage->Text);
    fsum = fsum/32768.0*(VCAPCATOR/fCalCap);
    fvalue = fsum/fEnlarge;
    fCalReal = fsum/fCalVol;
    AnsiString strTemp;
    strTemp.printf("%.4f",fvalue);
    FormMain->LabelValue->Caption = strTemp;
    strTemp.printf("%.2f",fEnlarge);
    FormMain->EditEnlarge->Text   = strTemp;
    strTemp.printf("%.3f",fCalReal);
    FormMain->EditReadEnlarge->Text = strTemp;
    strTemp.printf("%.3f",fsum);
    FormMain->LabelRealValue->Caption = strTemp;
    //1000.0 标定时电荷棒的电容值
}

float __fastcall lDieselHRBP::GetFrequency(short int iindex)
{
    //TODO: Add your source code here
    float fret;
    switch(iindex)
    {
         case 0:   {  fret = 10.0;     break;}
         case 1:   {  fret = 50.0;     break;}
         case 2:   {  fret = 100.0;    break;}
         case 3:   {  fret = 200.0;    break;}
         case 4:   {  fret = 300.0;    break;}
         case 5:   {  fret = 400.0;    break;}

         case 6:   {  fret = 500.0;    break;}
         case 7:   {  fret = 600.0;    break;}
         case 8:   {  fret = 700.0;    break;}
         case 9:   {  fret = 800.0;    break;}
         case 10:  {  fret = 900.0;    break;}
         case 11:  {  fret = 1000.0;   break;}

         case 12:  {  fret = 2000.0;   break;}
         case 13:  {  fret = 3000.0;   break;}
         case 14:  {  fret = 4000.0;   break;}
         case 15:  {  fret = 5000.0;   break;}
         case 16:  {  fret = 6000.0;   break;}
         case 17:  {  fret = 7000.0;   break;}

         case 18:  {  fret = 8000.0;   break;}
         case 19:  {  fret = 9000.0;   break;}
         case 20:  {  fret = 10000.0;  break;}
         case 21:  {  fret = 12000.0;  break;}
         case 22:  {  fret = 15000.0;  break;}
         default:  {  fret = 8000.0;   break;}
    }
    return fret;
}

void __fastcall lDieselHRBP::GetDrawSlope(int &istart, int &iend)
{
    //TODO: Add your source code here
    bool bstart = false;
    for(int i = 0; i < iPLength; i++)
    {
        if(!bstart)
        {
            if( fFFFai[i] >= -90.0)     //-30
            {
                istart = i;
                bstart = true;
            }
        }
        else
        {
            if( fFFFai[i] >= 180)       //-90
            {
                iend = i;
                break;
            }
        }
    }

//-----------------------------------------------------------
// 计算燃烧持续期
//
    int iistart,iiend,izero;
    float fangle;
    float fmean = 0.0;
//    iiend = iend;
/*
    fangle  = (fFFFai[iend] - fFFFai[iend-1]);
    izero   = iend - (int)(90.0/fangle);
    iistart = iend - (int)(30.0/fangle);
    iiend   = iend - (int)(10.0/fangle);
    for(int i = iistart; i < iiend; i ++)
    {
        fmean += fCDHDF[i];
    }
    fmean /= (float)(iiend - iistart);
    fmean *= 0.95;
*/
//首先找到累积放热率的最大值
// 然后向前数，到达0.95时，认为燃烧结束
    izero = istart;
    for(int i = istart; i < iend; i++)
    {
        if( fCDHDF[i] > fmean )
        {
            fmean = fCDHDF[i];
            izero = i;
        }
    }
    fmean *= 0.95;
    do
    {
        izero --;
    }while(fCDHDF[izero] > fmean);
    fCombustionPeriod = fFFFai[izero] - fCombustionAngle;
    LFHS.fCombustionPeriod = fCombustionPeriod;
    
//============================================================
}



float __fastcall lDieselHRBP::GetPressureAngle(float fangle)
{
    //TODO: Add your source code here
    float ftemp;
    int   iposi;
    ftemp = fFFFai[0];
    iposi = (fangle - ftemp)*iNumPerAngle;
    return fNewP[iposi];
}

void __fastcall lDieselHRBP::HeatRelease(void)
{
    //TODO: Add your source code here
    TJHeatRelease();
//    CarsHeatRelease();
//    ZYFHeatRelease();
    GetDrawSlope(iStartFai, iEndFai);     //获取绘制范围
}


bool __fastcall lDieselHRBP::GetPCPHead(AnsiString& strfilename)
{
    //TODO: Add your source code here
    bool bRet = false;
    FILE * fp;
    void * ptLFHS;
    AnsiString strNN;
    ptLFHS  = (void*)&LFHS;
    strNN   = AnsiString( strfilename);
    strNN   = ::ExtractFileExt(strNN);
    strNN   = strNN.UpperCase();

    if(strNN == ".PCP")
    {
        if((fp = fopen(strfilename.c_str(),"rb")) != NULL)
        {
            fread(ptLFHS,sizeof(lFileHeadStruct),1,fp);
            strNN = LFHS.str902Mark;
            if(strNN == "902" )
            {
                bRet = true;
            }
            fclose(fp);
        }
    }
    return bRet;
}



void __fastcall lDieselHRBP::SetTrainInfo(void)
{
/*
    switch(LFHS.siTrainType)
    {
        case 0:
        {
            strTrainType = "东风4A";
            break;
        }
        case 1:
        {
            strTrainType = "东风4B";
            break;
        }
        case 2:
        {
            strTrainType = "东风4C";
            break;
        }
        case 3:

        {
            strTrainType = "东风4D";
            break;
        }
        case 4:
        {
            strTrainType = "东风8B";
            break;
        }
        case 5:
        {
            strTrainType = "东风11";
            break;
        }
        default:
        {
            strTrainType = "其它";
            break;
        }
    }
*/
    strTrainType.printf("%s",LFHS.strTrainType);
    strTrainNumber.printf("%s",LFHS.strTrainNum);
    strDieselNumber.printf("%d",LFHS.siDieselNum);
}

void __fastcall lDieselHRBP::GetValidPipe(float* fp, int istart, int ilen)
{
    //TODO: Add your source code here
    float ftgain = 1.0;
    for(int i = 0; i < LFHS.siSignalGain[1]; ++i)
    {
        ftgain *= 2.0;
    }
    int ishift;
    ishift = (360 + istart )*5;
    for( int i = 0; i < ilen; i++)
    {
        fp[i] = siConvertBuffer[1][i + ishift ] / ftgain;
    }
}

bool __fastcall lDieselHRBP::LoadPCPFromRAM(TMemoryStream* pms)
{
    //TODO: Add your source code here
    bool bret = true;
    float ftemp1,ftemp2,ftemp;
    int   inum      = 0;
    int   ilen;
//  int   ippnum    = 0;

    void * ptLFHS;
    AnsiString strNN;
    lShort    ls;
    ptLFHS = (void*)&LFHS;
    pms->Position = 0;
            pms->Read(ptLFHS,sizeof(lFileHeadStruct));
            fTimeInterval    = LFHS.fTimeInterval;
            fAngleStep       = LFHS.fAngleStep;
            bCombustion      = (bool)LFHS.siCombustion;
            fEn              = LFHS.fEngineSpeed;
            fEngineSpeed     = LFHS.fEngineSpeed;
            strNN            = LFHS.str902Mark;
            fOilAngle        = LFHS.fOilAngle;
            fCombustionAngle = LFHS.fCombustionAngle;
            iDieselNum       = LFHS.siDieselNum;
            bOilSupply       = (bool)LFHS.chOil;
//----------------------------------------------------------
            SetTrainInfo();
//-----------------------------------------------------------------------
            fMinOldP       = LFHS.fMinOldP;
            fMaxOldP       = LFHS.fMaxOldP;  //原始数据的最大值和最小值

            fOilPMin       = LFHS.fOilPMin;
            fOilPMax       = LFHS.fOilPMax;  //油管压力波形的最大值和最小值
            fOilGain       = 1.0;
            for( int i = 0; i < LFHS.siSignalGain[1]; i++)
            {
                fOilGain *= 2.0;
            }
            fNormalPMin    = LFHS.fNormalPMin;
            fNormalPMax    = LFHS.fNormalPMax;   //修正后的气缸压力最大值和最小值
            fDPDFMax       = LFHS.fDPDFMax;
            fDPDFMin       = LFHS.fDPDFMin;       //压力升高率的最大值和最小值
            fHRRMin        = LFHS.fHRRMin;
            fHRRMax        = LFHS.fHRRMax;        //放热率最大值和最小值
            fCHRRMax       = LFHS.fCHRRMax;
            fCHRRMin       = LFHS.fCHRRMin;       //累积放热率最大值和最小值
            fMaxFFTP       = LFHS.fMaxFFTP;
            fMinFFTP       = LFHS.fMinFFTP;       //频谱的最大值和最小值
            fTMax          = LFHS.fTMax;
            fTMin          = LFHS.fTMin;          //气缸温度的最大值和最小值
            fDWMax         = LFHS.fDWMax;
            fDWMin         = LFHS.fDWMin;         //瞬时功的最大值和最小值
            fWMax          = LFHS.fWMax;          //瞬时功的最大值和最小值
            fWMin          = LFHS.fWMin;
            fFFFaiMin      = LFHS.fFFFaiMin;
            fFFFaiMax      = LFHS.fFFFaiMax;
            fCPower        = LFHS.fCPower;
            iStartFai      = LFHS.iStartFai;
            iEndFai        = LFHS.iEndFai;
            iFFTLength     = LFHS.iFFTLength;
            fLogPMin       = LFHS.fLogPMin;
            fLogPMax       = LFHS.fLogPMax;
            fLogVMin       = LFHS.fLogVMin;
            fLogVMax       = LFHS.fLogVMax;
            fFirstDHDFMax  = LFHS.fDHDFMax;   //放热率第一峰值
            fPMaxFai       = LFHS.fFaiPMax;   //最大气缸压力所对应的曲轴转角
            fDPDFMaxFai    = LFHS.fFaiDPDFMax;   //最大压力升高率对应的曲轴转角
            fDHDFMaxFai    = LFHS.fFaiDHDFMax;   //最大放热率对应的曲轴转角
            fTMaxFai       = LFHS.fFaiTMax;   //最高温度对应的曲轴转角
            fFaiFirstDHDFMax  = LFHS.fFaiFirstDHDFMax;   //放热率第一峰值对应的曲轴转角
            fCPMax         = LFHS.fCPMax;
//===========================================================================

            if(LFHS.siInfoValid == 1)
            {
                iNormalLength = LFHS.iNormalLength;           //备份数据长度
                iNumPerAngle  = LFHS.iNumPerAngle;
                fDiameter      = LFHS.fDiameter;      //1 气缸直径
                fStroke        = LFHS.fStroke;        //2 活塞冲程
                fPodLength     = LFHS.fPodLength;     //3 连杆长度
                fCRatio        = LFHS.fCRatio;        //4 压缩比
                fLMDa          = LFHS.fLMDa;          //5 冲程/连杆之比
                fInOpenAngle   = LFHS.fInOpenAngle;   //6 进气门开启角度
                fInCloseAngle  = LFHS.fInCloseAngle;  //7　进气门关闭角度
                fOutOpenAngle  = LFHS.fOutOpenAngle;  //8　排气门开启角度
                fOutCloseAngle = LFHS.fOutCloseAngle; //9　排气门关闭角度
                fDPDFLocalMax  = LFHS.fLocalDPDFMax;      //压力升高率的局部最大值

            }

            sprintf(LFHS.strTrainNum,"%04d\0",LFHS.iTrainNum);
            if(strNN != "902" )
            {
                return false;
            }
            iNormalLength = LFHS.iNormalLength;
            iPLength      = iNormalLength;
            if(!AllocateMemory(3600)) //iNormalLength))       //iNormalLength = 720
            {
                return false;
            }
            ilen = sizeof(float);
            pms->Read((void*)(fFFFai), ilen*iNormalLength); //读入角度
            pms->Read((void*)(farDPDF),ilen*iNormalLength);
            pms->Read((void*)(farV),   ilen*iNormalLength);
// 读入第一通道的数据
//------------------------------------------------------
            if(LFHS.siPassageStatus[0] == 1)  //如果该通道打开，
            {
                ilen = sizeof(short int);
               pms->Read((void*)(siConvertBuffer[0]),ilen*3600);
//                ippnum++;
            }
            else                          //如果没有打开就置为零
            {
                for(int j=0;j<inum;j++)
                {
                    siConvertBuffer[0][j] = 0;
                }
            }
//=======================================================

// 读入第二通道的数据
            if(LFHS.siPassageStatus[1] == 1)
            {
                ilen = sizeof(short int);
                pms->Read((void*)(siConvertBuffer[1]),ilen*3600);
//                ippnum++;
        //        fOilPMax *= 2.0;
            }
            else
            {
                for(int j=0; j<inum; j++)
                {
                    siConvertBuffer[1][j] = 0;
                    fpOilP[j] = 0.0;
                }
            }
//============================================================

// 读入第三通道的数据
//------------------------------------------------------------
            if(LFHS.siPassageStatus[2] == 1)
            {
                ilen = sizeof(short int);
                pms->Read((void*)(siConvertBuffer[2]),ilen*3600);
//                ippnum++;
            }
            else
            {
                for(int j=0; j<inum; j++)
                {
                    siConvertBuffer[2][j] = 0;
                }
            }

            ilen = sizeof(float);
//1
            pms->Read((void*)(fOldP),iNormalLength*ilen);         //读入原始数据
//2
            pms->Read((void*)(fNewP),iNormalLength*ilen);         //读入修正数据
//3
            pms->Read((void*)(fDHDF),iNormalLength*ilen);         //读入放热率数据
//4
            pms->Read((void*)(fCDHDF),iNormalLength*ilen);        //读入累积放热率数据
//5
            pms->Read((void*)(fTT),iNormalLength*ilen);           //读入气缸温度数据
//6
            pms->Read((void*)(farDW),iNormalLength*ilen);         //读入瞬时功数据
//7
            pms->Read((void*)(farW), iNormalLength*ilen);          //读入累积功数据
//8
            pms->Read((void*)(farFFTPr),iFFTLength*ilen);         //读入频谱
//9
            pms->Read((void*)(farFFTPi),iFFTLength*ilen);         //读入频谱
//10
            pms->Read((void*)(farLogP), iNormalLength*ilen);
//11
            pms->Read((void*)(farLogV), iNormalLength*ilen);
//12
            pms->Read((void*)(fpOilP),  iNormalLength*ilen);
/*
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
*/
    return bret;
}

void __fastcall lDieselHRBP::CalculateFactor(void)
{
    //TODO: Add your source code here
    int istart, iend;
    bool bPositive = true;
    float fAverX,fAverY;
    float fx, fy;
    float fSumXX, fSumXY;
    istart = 300*iNumPerAngle;
    iend   = 340*iNumPerAngle;
    for( int i = istart; i< iend; i++)
    {
        if( fNewP[i] <= 0.0)
        {
            bPositive = false;
            break;
        }
    }
    if(!bPositive)
    {
        LFHS.fCompressFactor = 0.0;
        return;
    }   
    for(int i = istart; i< iend; i++)
    {
        fAverX += log(farV[i]) ;  //mN.m
        fAverY += log(fNewP[i]);
    }
    fAverX /= (float)(iend - istart);
    fAverY /= (float)(iend - istart);
    for(int i = istart; i< iend; i++)
    {
        fx = log(farV[i]);
        fy = log(fNewP[i]);
        fSumXY += (fx - fAverX)*(fy - fAverY);
        fSumXX += (fx - fAverX)*(fx - fAverX);
    }
    LFHS.fCompressFactor = -fSumXY/fSumXX ;
}





